
/* JS HEAD SECTION START */
/*
                       _                     _ _
                      | |                   (_) |
  ___ _   _ _ __   ___| |__  _ __ ___  _ __  _| |_  ___
 / __| | | | '_ \ / __| '_ \| '__/ _ \| '_ \| | __|/ _ \
 \__ \ |_| | | | | (__| | | | | | (_) | | | | | |_|  __/
 |___/\__, |_| |_|\___|_| |_|_|  \___/|_| |_|_|\__|\___|
       __/ |
      |___/
   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.
  / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / collaborative
 `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`- web services

 Copyright (c) 2012-2019, LivePerson Germany GmbH, All Rights Reserved.
*/
!function(n,t,e){function c(n){return n&&"object"==typeof n&&!Array.isArray(n)}
function i(n,t){null==n&&(n={});for(var e=Object(n),r=1;r<arguments.length;r++){
var o=arguments[r];if(null!=o)for(var c in o
)Object.prototype.hasOwnProperty.call(o,c)&&(e[c]=o[c])}return e}function a(e,r
){var o=i({},e);return c(e)&&c(r)&&Object.keys(r).forEach(function(n){var t;c(r[
n])?n in e?o[n]=a(e[n],r[n]):((t={})[n]=r[n],i(o,t)):((t={})[n]=r[n],i(o,t))}),o
}var r=n.document,o=n.synchroniteConfig=n.synchroniteConfig||{};t&&(o=a(t,o)),(
o=e?a(o,e):o).locale||(t="lang",e=r.documentElement,
r=r.body||r.getElementsByTagName("body")[0],o.locale=e&&e.getAttribute(t
)||r&&r.getAttribute(t)),n.synchroniteConfig=o}(window,{"skipVisitorConfirmation":false,"urlBlacklist":[],"quickstartAction":"receive","hasCustomUI":true,"annotations":false,"uiSession":{"highlightSymbol":"solidCircle","highlightColor":"#FFEB53","clickBlurRadius":10,"companyLogo":"","favIcon":"","docTitle":"Co-Browsing: ${title}","customizedTexts":{}},"resizeAgentsScreen":true,"skipEnterDetailsWhenVisitorIsKnown":false,"httpToken":["idpLastSiteId","idpLastDomain"],"tenantHost":"36478212.lo.cobrowse.liveperson.net","uiPointers":{"telepointer":[{"cursor":"yellow","color":"#FFEB53"},{"cursor":"white","color":"#CCC"},{"cursor":"pink","color":"#F9B5FF"},{"cursor":"turquoise","color":"#41FFFA"},{"cursor":"green","color":"#58FF43"}],"useCustom":false},"supportCoBrowsingInIFrame":true,"button":{"backgroundColor":"#005892","borderColor":"#FFF","cssClass":"synchronite-button","position":"right","label":"LIVE SUPPORT","fontColor":"#FFF","font":"Arial,Helvetica,sans-serif"},"showTelepointerHint":true,"restoreDocumentCookies":false,"noGlobals":true,"disableWebsockets":false,"preventDuplicateSessions":true,"cobrowseEngine":"proxyless","synchronizeFocus":false,"restrictToDomains":[],"trackingAPI":"disabled","stickyMenubar":true,"enableMobileOverlay":true,"checkAgentAvailability":true,"protectedFields":[".PII"],"protectAreasByClassName":[],"enableEscapingInCssUrlsOnAgentBrowser":true,"proxyMode":null,"proxyHost":"lo.cobrowse.liveperson.net","serviceIdLength":6,"showJobOffer":false,"visitorNameRequired":true,"cometUrl":"36478212-sync.lo.cobrowse.liveperson.net","livepersonHandover":true,"chat":{"position":"se"},"supportDialog":{"supportDialogImage":"${serverUrl}\u002Fimages\u002Fagent.jpg"},"rewriteTargets":false,"integration":{"features":{"showJobOffer":false,"noconflict":false,"realtimeTracking":false,"startDelay":25,"hasCustomUI":true,"trustedEmails":[]},"termsOfServiceURL":"${serverUrl}\u002Fterms","mail":false,"enableLiveButton":false,"termsOfService":"hide","serviceKey":"-","scripts":{"onStateSet":"","extractFullname":"","onSynchroniteLoad":"","onStateGet":""}},"trackingAnonymous":false,"realtimeTracking":false,"startDelay":25,"protectAreasById":[]},
{"isDebug":false,"baseUrl":"https:\u002F\u002F36478212.lo.cobrowse.liveperson.net\u002Fjs\u002F","paths":{"dojo":"dojo","dijit":"dijit","bootstrap":"bootstrap","uglify-js":"uglify-js","synchronite":"synchronite","org":"org","dojox":"dojox"},"dojoBlankHtmlUrl":"\u002Fblank","cacheBust":"298886937617","selectorEngine":"acme"});
/* JS HEAD SECTION END */


;(function() {
var i18next_options, libs_i18next, libs_i18next_xhr_backend, libs_i18next_browser_languageDetector, i18next_loader, i18next_inlineLocales, dojo_has, dojo_sniff, dojo__base_config, dojo__base_kernel, dojo__base_lang, dojo__base_window, dojo_dom, dojo_on, dojo_dom_style, dojo_dom_geometry, dojo__base_event, dojo_errors_create, dojo_errors_CancelError, dojo_promise_Promise, dojo_Deferred, dojo_aspect, dojo_regexp, dojo_cookie, dojo_errors_RequestError, dojo_io_query, dojo__base_array, dojo_request_util = {}, dojo_errors_RequestTimeoutError, dojo_request_watch, dojo_json, dojo_request_handlers, dojo_request_xhr, dojo_request, synchronite_constants_strings, dojox_encoding_base64, synchronite__base_base64, synchronite__base_analytics, synchronite_integration_visitor_info, dojo_string, org_cometd, dojox_main, dojox, dojo__base_sniff, dojo_dom_form, dojo_when, dojo__base_Deferred, dojo__base_json, dojo__base_xhr, dojo_request_script, dojox_cometd, dojo_domReady, synchronite_proxyless_lib_lpSecureStorageAMD, dojo__base_url, synchronite_libs_sizzle, synchronite__base_query, synchronite__base_url, synchronite_proxyless_storage, org_cometd_ReloadExtensionLP, synchronite_constants_constants, dojox_cometd_reloadLP, dojo__base_unload, liveperson_visitor_common, synchronite__base_goog, synchronite_micro_dom, synchronite__base_cookie, synchronite__base_window, synchronite__base_state, synchronite_integration_session, synchronite__base_session_link, synchronite__base_page_visibility, synchronite__base_locale, synchronite_libs_lz_string, synchronite_cometd_LargeMessageExtension, synchronite_integration_io, synchronite_integration_ajax_status, synchronite_integration_tracking_ga, synchronite_integration_tracking_piwik, synchronite_integration_tracking_wt, synchronite_integration_tracking_lpEvents, synchronite_integration_tracking_tealium, synchronite_integration_tracking_loader, dojo_selector__loader, dojo_query, dojo_Evented, dojo_topic, dojo_mouse, dojo_keys, dojo__base_connect, dojo_dom_prop = {}, dojo_dom_attr = {}, dojo_dom_construct = {}, dojo_text, dojo_text_synchronite_integration_templates_EnterServiceIdDialoghtml, dojo_text_synchronite_integration_templates_ShowServiceIdDialoghtml, synchronite_integration_dialog_service, dojo_NodeList_data, bootstrap_Support, dojo__base_declare, dojo_dom_class, dojo_NodeList_dom, dojo_NodeList_traverse, dojo_NodeList_manipulate, bootstrap_Modal, synchronite_integration_main, synchronite_integration_button, dojo__base_Color, dojo__base_fx, dojo_text_synchronite_integration_templates_SupportDialoghtml, synchronite_integration_dialog_support, synchronite_integration_run, synchronite_integration_run_build;
(function () {
  i18next_options = function () {
    function appenPath(url, path) {
      if (!/\/$/.test(url)) {
        url += '/';
      }
      return url + path;
    }
    var jsPath = 'js', nlsPath = 'synchronite/i18n', baseUrl;
    if (typeof synchroniteConfig != 'undefined') {
      baseUrl = synchroniteConfig.serverUrl || 'https://' + synchroniteConfig.tenantHost;
      baseUrl = appenPath(baseUrl, jsPath + '/' + nlsPath);
    } else if (typeof require != 'undefined') {
      baseUrl = appenPath(require.toUrl(''), nlsPath);
    } else {
      baseUrl = '/' + jsPath + '/' + nlsPath;
    }
    var options = {
      'ns': [],
      'defaultNS': [
        'session',
        'integration',
        'common'
      ],
      // default namespace used if not passed to translation function
      'load': 'all',
      'fallbackLng': ['en-US'],
      'whitelist': [
        'Cy-sr-SP',
        'ar-AE',
        'bg-BG',
        'cs-CZ',
        'da-DK',
        'de-DE',
        'el-GR',
        'en-US',
        'es-419',
        'es-ES',
        'et-EE',
        'fi-FI',
        'fr-CA',
        'fr-FR',
        'he-IL',
        'hi-IN',
        'hr-HR',
        'hu-HU',
        'id-ID',
        'it-IT',
        'ja-JP',
        'ko-KR',
        'lt-LT',
        'lv-LV',
        'mk-MK',
        'ms-MY',
        'nb-NO',
        'nl-NL',
        'pl-PL',
        'pt-BR',
        'pt-PT',
        'ro-RO',
        'ru-RU',
        'sk-SK',
        'sl-SI',
        'sv-SE',
        'th-TH',
        'tr-TR',
        'uk-UA',
        'vi-VN',
        'zh-CN',
        'zh-HK',
        'zh-TW'
      ],
      'nonExplicitWhitelist': true,
      'preload': false,
      //	array of languages to preload
      'debug': false,
      //(typeof synchroniteConfig !== "undefined") && synchroniteConfig.isDebug,
      'interpolation': {
        'prefix': '${',
        'suffix': '}'
      },
      'keySeparator': '....',
      'backend': {
        'crossDomain': true,
        'allowMultiLoading': false,
        'loadPath': baseUrl + '/${lng}.json'
      },
      'detection': {
        //  Language Detector
        'lookupQuerystring': 'locale',
        'order': [
          'localStorage',
          'querystring',
          'navigator'
        ]
      }
    };
    if (typeof XDomainRequest !== 'undefined') {
      // IE 8-9 cross-origin ajax
      options.backend.ajax = function (url, options, callback, data) {
        var xdr = new XDomainRequest();
        if (url.indexOf('://') !== -1) {
          url = window.location.protocol + url.substring(url.indexOf('//'));
        }
        xdr.open(data ? 'POST' : 'GET', url, 1);
        // Unfortunately the XDomainRequest object does not provide status codes
        // http://stackoverflow.com/a/23554313
        xdr.onload = function () {
          callback(xdr.responseText, { status: 200 });
        };
        xdr.ontimeout = xdr.onerror = function () {
          callback(xdr.responseText, { status: 400 });
        };
        // Empty event handlers needs to be there, because IE9 is flawed
        // http://rudovsky.blogspot.dk/2012/09/microsoft-shit-xdomainrequest.html
        xdr.onprogress = function () {
        };
        xdr.send();
      };
    }
    return options;
  }();
  (function (f) {
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = f();
    } else if (true) {
      libs_i18next = function () {
        return typeof f === 'function' ? f() : f;
      }();
    } else {
      var g;
      if (typeof window !== 'undefined') {
        g = window;
      } else if (typeof global !== 'undefined') {
        g = global;
      } else if (typeof self !== 'undefined') {
        g = self;
      } else {
        g = this;
      }
      g.i18next = f();
    }
  }(function () {
    var define, module, exports;
    return function e(t, n, r) {
      function s(o, u) {
        if (!n[o]) {
          if (!t[o]) {
            var a = typeof require == 'function' && require;
            if (!u && a)
              return a(o, !0);
            if (i)
              return i(o, !0);
            var f = new Error('Cannot find module \'' + o + '\'');
            throw f.code = 'MODULE_NOT_FOUND', f;
          }
          var l = n[o] = { exports: {} };
          t[o][0].call(l.exports, function (e) {
            var n = t[o][1][e];
            return s(n ? n : e);
          }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
      }
      var i = typeof require == 'function' && require;
      for (var o = 0; o < r.length; o++)
        s(r[o]);
      return s;
    }({
      1: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _slicedToArray = function () {
            function sliceIterator(arr, i) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = undefined;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i['return'])
                    _i['return']();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            return function (arr, i) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
              } else {
                throw new TypeError('Invalid attempt to destructure non-iterable instance');
              }
            };
          }();
          var _extends = Object.assign || function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get = function get(_x2, _x3, _x4) {
            var _again = true;
            while (_again) {
              var object = _x2, property = _x3, receiver = _x4;
              _again = false;
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === undefined) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return undefined;
                } else {
                  _x2 = parent;
                  _x3 = property;
                  _x4 = receiver;
                  _again = true;
                  desc = parent = undefined;
                }
              } else if ('value' in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === undefined) {
                  return undefined;
                }
                return getter.call(receiver);
              }
            }
          };
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj['default'] = obj;
              return newObj;
            }
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var _utils = require('./utils');
          var utils = _interopRequireWildcard(_utils);
          var _logger = require('./logger');
          var _logger2 = _interopRequireDefault(_logger);
          var _EventEmitter2 = require('./EventEmitter');
          var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);
          function remove(arr, what) {
            var found = arr.indexOf(what);
            while (found !== -1) {
              arr.splice(found, 1);
              found = arr.indexOf(what);
            }
          }
          var Connector = function (_EventEmitter) {
            _inherits(Connector, _EventEmitter);
            function Connector(backend, store, services) {
              var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
              _classCallCheck(this, Connector);
              _get(Object.getPrototypeOf(Connector.prototype), 'constructor', this).call(this);
              this.backend = backend;
              this.store = store;
              this.services = services;
              this.options = options;
              this.logger = _logger2['default'].create('backendConnector');
              this.state = {};
              this.queue = [];
              this.backend && this.backend.init(services, options.backend, options);
            }
            _createClass(Connector, [
              {
                key: 'queueLoad',
                value: function queueLoad(languages, namespaces, callback) {
                  var _this = this;
                  // find what needs to be loaded
                  var toLoad = [], pending = [], toLoadLanguages = [], toLoadNamespaces = [];
                  languages.forEach(function (lng) {
                    var hasAllNamespaces = true;
                    namespaces.forEach(function (ns) {
                      var name = lng + '|' + ns;
                      if (_this.store.hasResourceBundle(lng, ns)) {
                        _this.state[name] = 2;  // loaded
                      } else if (_this.state[name] === 1) {
                        if (pending.indexOf(name) < 0)
                          pending.push(name);
                      } else {
                        _this.state[name] = 1;
                        // pending
                        hasAllNamespaces = false;
                        if (pending.indexOf(name) < 0)
                          pending.push(name);
                        if (toLoad.indexOf(name) < 0)
                          toLoad.push(name);
                        if (toLoadNamespaces.indexOf(ns) < 0)
                          toLoadNamespaces.push(ns);
                      }
                    });
                    if (!hasAllNamespaces)
                      toLoadLanguages.push(lng);
                  });
                  if (toLoad.length || pending.length) {
                    this.queue.push({
                      pending: pending,
                      loaded: {},
                      errors: [],
                      callback: callback
                    });
                  }
                  return {
                    toLoad: toLoad,
                    pending: pending,
                    toLoadLanguages: toLoadLanguages,
                    toLoadNamespaces: toLoadNamespaces
                  };
                }
              },
              {
                key: 'loaded',
                value: function loaded(name, err, data) {
                  var _this2 = this;
                  var _name$split = name.split('|');
                  var _name$split2 = _slicedToArray(_name$split, 2);
                  var lng = _name$split2[0];
                  var ns = _name$split2[1];
                  if (data) {
                    this.store.addResourceBundle(lng, ns, data);
                  }
                  // set loaded
                  this.state[name] = err ? -1 : 2;
                  // callback if ready
                  this.queue.forEach(function (q) {
                    utils.pushPath(q.loaded, [lng], ns);
                    remove(q.pending, name);
                    if (err)
                      q.errors.push(err);
                    if (q.pending.length === 0 && !q.done) {
                      q.errors.length ? q.callback(q.errors) : q.callback();
                      _this2.emit('loaded', q.loaded);
                      q.done = true;
                    }
                  });
                }
              },
              {
                key: 'read',
                value: function read(lng, ns, fcName, tried, wait, callback) {
                  var _this3 = this;
                  if (!tried)
                    tried = 0;
                  if (!wait)
                    wait = 250;
                  if (!lng.length)
                    return callback(null, {});
                  // noting to load
                  this.backend[fcName](lng, ns, function (err, data) {
                    if (err && data  /* = retryFlag */ && tried < 5) {
                      setTimeout(function () {
                        _this3.read.call(_this3, lng, ns, fcName, ++tried, wait * 2, callback);
                      }, wait);
                      return;
                    }
                    callback(err, data);
                  });
                }
              },
              {
                key: 'load',
                value: function load(languages, namespaces, callback) {
                  var _this4 = this;
                  if (!this.backend)
                    return callback && callback('no backend was defined.');
                  var options = _extends({}, this.backend.options, this.options.backend);
                  if (typeof languages === 'string')
                    languages = this.services.languageUtils.toResolveHierarchy(languages);
                  if (typeof namespaces === 'string')
                    namespaces = [namespaces];
                  var toLoad = this.queueLoad(languages, namespaces, callback);
                  if (!toLoad.toLoad.length) {
                    if (!toLoad.pending.length)
                      callback();
                    // nothing to load and no pendings...callback now
                    return;  // pendings will trigger callback
                  }
                  // load with multi-load
                  if (options.allowMultiLoading && this.backend.readMulti) {
                    this.read(toLoad.toLoadLanguages, toLoad.toLoadNamespaces, 'readMulti', null, null, function (err, data) {
                      if (err)
                        _this4.logger.warn('loading namespaces ' + toLoad.toLoadNamespaces.join(', ') + ' for languages ' + toLoad.toLoadLanguages.join(', ') + ' via multiloading failed', err);
                      if (!err && data)
                        _this4.logger.log('loaded namespaces ' + toLoad.toLoadNamespaces.join(', ') + ' for languages ' + toLoad.toLoadLanguages.join(', ') + ' via multiloading', data);
                      toLoad.toLoad.forEach(function (name) {
                        var _name$split3 = name.split('|');
                        var _name$split32 = _slicedToArray(_name$split3, 2);
                        var l = _name$split32[0];
                        var n = _name$split32[1];
                        var bundle = utils.getPath(data, [
                          l,
                          n
                        ]);
                        if (bundle) {
                          _this4.loaded(name, err, bundle);
                        } else {
                          var _err = 'loading namespace ' + n + ' for language ' + l + ' via multiloading failed';
                          _this4.loaded(name, _err);
                          _this4.logger.error(_err);
                        }
                      });
                    });
                  }  // load one by one
                  else {
                    (function () {
                      var read = function read(name) {
                        var _this5 = this;
                        var _name$split4 = name.split('|');
                        var _name$split42 = _slicedToArray(_name$split4, 2);
                        var lng = _name$split42[0];
                        var ns = _name$split42[1];
                        this.read(lng, ns, 'read', null, null, function (err, data) {
                          if (err)
                            _this5.logger.warn('loading namespace ' + ns + ' for language ' + lng + ' failed', err);
                          if (!err && data)
                            _this5.logger.log('loaded namespace ' + ns + ' for language ' + lng, data);
                          _this5.loaded(name, err, data);
                        });
                      };
                      toLoad.toLoad.forEach(function (name) {
                        read.call(_this4, name);
                      });
                    }());
                  }
                }
              },
              {
                key: 'saveMissing',
                value: function saveMissing(languages, namespace, key, fallbackValue) {
                  if (this.backend && this.backend.create)
                    this.backend.create(languages, namespace, key, fallbackValue);
                  // write to store to avoid resending
                  this.store.addResource(languages[0], namespace, key, fallbackValue);
                }
              }
            ]);
            return Connector;
          }(_EventEmitter3['default']);
          exports['default'] = Connector;
          module.exports = exports['default'];
          return exports;
        },
        {
          './EventEmitter': 3,
          './logger': 12,
          './utils': 14
        }
      ],
      2: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _extends = Object.assign || function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get = function get(_x2, _x3, _x4) {
            var _again = true;
            while (_again) {
              var object = _x2, property = _x3, receiver = _x4;
              _again = false;
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === undefined) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return undefined;
                } else {
                  _x2 = parent;
                  _x3 = property;
                  _x4 = receiver;
                  _again = true;
                  desc = parent = undefined;
                }
              } else if ('value' in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === undefined) {
                  return undefined;
                }
                return getter.call(receiver);
              }
            }
          };
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj['default'] = obj;
              return newObj;
            }
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var _utils = require('./utils');
          var utils = _interopRequireWildcard(_utils);
          var _logger = require('./logger');
          var _logger2 = _interopRequireDefault(_logger);
          var _EventEmitter2 = require('./EventEmitter');
          var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);
          var Connector = function (_EventEmitter) {
            _inherits(Connector, _EventEmitter);
            function Connector(cache, store, services) {
              var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
              _classCallCheck(this, Connector);
              _get(Object.getPrototypeOf(Connector.prototype), 'constructor', this).call(this);
              this.cache = cache;
              this.store = store;
              this.services = services;
              this.options = options;
              this.logger = _logger2['default'].create('cacheConnector');
              this.cache && this.cache.init(services, options.cache, options);
            }
            _createClass(Connector, [
              {
                key: 'load',
                value: function load(languages, namespaces, callback) {
                  var _this = this;
                  if (!this.cache)
                    return callback && callback();
                  var options = _extends({}, this.cache.options, this.options.cache);
                  if (typeof languages === 'string')
                    languages = this.services.languageUtils.toResolveHierarchy(languages);
                  if (typeof namespaces === 'string')
                    namespaces = [namespaces];
                  if (options.enabled) {
                    this.cache.load(languages, function (err, data) {
                      if (err)
                        _this.logger.error('loading languages ' + languages.join(', ') + ' from cache failed', err);
                      if (data) {
                        for (var l in data) {
                          for (var n in data[l]) {
                            if (n === 'i18nStamp')
                              continue;
                            var bundle = data[l][n];
                            if (bundle)
                              _this.store.addResourceBundle(l, n, bundle);
                          }
                        }
                      }
                      if (callback)
                        callback();
                    });
                  } else {
                    if (callback)
                      callback();
                  }
                }
              },
              {
                key: 'save',
                value: function save() {
                  if (this.cache && this.options.cache && this.options.cache.enabled)
                    this.cache.save(this.store.data);
                }
              }
            ]);
            return Connector;
          }(_EventEmitter3['default']);
          exports['default'] = Connector;
          module.exports = exports['default'];
          return exports;
        },
        {
          './EventEmitter': 3,
          './logger': 12,
          './utils': 14
        }
      ],
      3: [
        function (require, module, exports) {
          'use strict';
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var EventEmitter = function () {
            function EventEmitter() {
              _classCallCheck(this, EventEmitter);
              this.observers = {};
            }
            _createClass(EventEmitter, [
              {
                key: 'on',
                value: function on(events, listener) {
                  var _this = this;
                  events.split(' ').forEach(function (event) {
                    _this.observers[event] = _this.observers[event] || [];
                    _this.observers[event].push(listener);
                  });
                }
              },
              {
                key: 'off',
                value: function off(event, listener) {
                  var _this2 = this;
                  if (!this.observers[event]) {
                    return;
                  }
                  this.observers[event].forEach(function () {
                    if (!listener) {
                      delete _this2.observers[event];
                    } else {
                      var index = _this2.observers[event].indexOf(listener);
                      if (index > -1) {
                        _this2.observers[event].splice(index, 1);
                      }
                    }
                  });
                }
              },
              {
                key: 'emit',
                value: function emit(event) {
                  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                  }
                  if (this.observers[event]) {
                    this.observers[event].forEach(function (observer) {
                      observer.apply(undefined, args);
                    });
                  }
                  if (this.observers['*']) {
                    this.observers['*'].forEach(function (observer) {
                      var _ref;
                      observer.apply(observer, (_ref = [event]).concat.apply(_ref, args));
                    });
                  }
                }
              }
            ]);
            return EventEmitter;
          }();
          module.exports = EventEmitter;
          return exports;
        },
        {}
      ],
      4: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj['default'] = obj;
              return newObj;
            }
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var _utils = require('./utils');
          var utils = _interopRequireWildcard(_utils);
          var _logger = require('./logger');
          var _logger2 = _interopRequireDefault(_logger);
          var Interpolator = function () {
            function Interpolator() {
              var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
              _classCallCheck(this, Interpolator);
              this.logger = _logger2['default'].create('interpolator');
              this.init(options, true);
            }
            _createClass(Interpolator, [
              {
                key: 'init',
                value: function init(options, reset) {
                  if (options === undefined)
                    options = {};
                  if (reset)
                    this.options = options;
                  if (!options.interpolation)
                    options.interpolation = { escapeValue: true };
                  var iOpts = options.interpolation;
                  this.escapeValue = iOpts.escapeValue;
                  this.prefix = iOpts.prefix ? utils.regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';
                  this.suffix = iOpts.suffix ? utils.regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';
                  this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
                  this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';
                  this.nestingPrefix = iOpts.nestingPrefix ? utils.regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || utils.regexEscape('$t(');
                  this.nestingSuffix = iOpts.nestingSuffix ? utils.regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || utils.regexEscape(')');
                  // the regexp
                  var regexpStr = this.prefix + '(.+?)' + this.suffix;
                  this.regexp = new RegExp(regexpStr, 'g');
                  var regexpUnescapeStr = this.prefix + this.unescapePrefix + '(.+?)' + this.unescapeSuffix + this.suffix;
                  this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');
                  var nestingRegexpStr = this.nestingPrefix + '(.+?)' + this.nestingSuffix;
                  this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');
                }
              },
              {
                key: 'reset',
                value: function reset() {
                  if (this.options)
                    this.init(this.options);
                }
              },
              {
                key: 'interpolate',
                value: function interpolate(str, data) {
                  var match = undefined, value = undefined;
                  function regexSafe(val) {
                    return val.replace(/\$/g, '$$$$');
                  }
                  // unescape if has unescapePrefix/Suffix
                  while (match = this.regexpUnescape.exec(str)) {
                    var _value = utils.getPath(data, match[1].trim());
                    str = str.replace(match[0], _value);
                  }
                  // regular escape on demand
                  while (match = this.regexp.exec(str)) {
                    value = utils.getPath(data, match[1].trim());
                    if (typeof value !== 'string')
                      value = utils.makeString(value);
                    if (!value) {
                      this.logger.warn('missed to pass in variable ' + match[1] + ' for interpolating ' + str);
                      value = '';
                    }
                    value = this.escapeValue ? regexSafe(utils.escape(value)) : regexSafe(value);
                    str = str.replace(match[0], value);
                    this.regexp.lastIndex = 0;
                  }
                  return str;
                }
              },
              {
                key: 'nest',
                value: function nest(str, fc) {
                  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
                  var match = undefined, value = undefined;
                  var clonedOptions = JSON.parse(JSON.stringify(options));
                  clonedOptions.applyPostProcessor = false;
                  // avoid post processing on nested lookup
                  function regexSafe(val) {
                    return val.replace(/\$/g, '$$$$');
                  }
                  // if value is something like "myKey": "lorem $(anotherKey, { "count": {{aValueInOptions}} })"
                  function handleHasOptions(key) {
                    if (key.indexOf(',') < 0)
                      return key;
                    var p = key.split(',');
                    key = p.shift();
                    var optionsString = p.join(',');
                    optionsString = this.interpolate(optionsString, clonedOptions);
                    try {
                      clonedOptions = JSON.parse(optionsString);
                    } catch (e) {
                      this.logger.error('failed parsing options string in nesting for key ' + key, e);
                    }
                    return key;
                  }
                  // regular escape on demand
                  while (match = this.nestingRegexp.exec(str)) {
                    value = fc(handleHasOptions.call(this, match[1].trim()), clonedOptions);
                    if (typeof value !== 'string')
                      value = utils.makeString(value);
                    if (!value) {
                      this.logger.warn('missed to pass in variable ' + match[1] + ' for interpolating ' + str);
                      value = '';
                    }
                    value = this.escapeValue ? regexSafe(utils.escape(value)) : regexSafe(value);
                    str = str.replace(match[0], value);
                    this.regexp.lastIndex = 0;
                  }
                  return str;
                }
              }
            ]);
            return Interpolator;
          }();
          exports['default'] = Interpolator;
          module.exports = exports['default'];
          return exports;
        },
        {
          './logger': 12,
          './utils': 14
        }
      ],
      5: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _slicedToArray = function () {
            function sliceIterator(arr, i) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = undefined;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i['return'])
                    _i['return']();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            return function (arr, i) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
              } else {
                throw new TypeError('Invalid attempt to destructure non-iterable instance');
              }
            };
          }();
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var _logger = require('./logger');
          var _logger2 = _interopRequireDefault(_logger);
          var LanguageUtil = function () {
            function LanguageUtil(options) {
              _classCallCheck(this, LanguageUtil);
              this.options = options;
              this.whitelist = this.options.whitelist || false;
              this.logger = _logger2['default'].create('languageUtils');
            }
            _createClass(LanguageUtil, [
              {
                key: 'getLanguagePartFromCode',
                value: function getLanguagePartFromCode(code) {
                  if (code.indexOf('-') < 0)
                    return code;
                  var specialCases = [
                    'nb-NO',
                    'nn-NO',
                    'nb-no',
                    'nn-no'
                  ];
                  var p = code.split('-');
                  return this.formatLanguageCode(specialCases.indexOf(code) > -1 ? p[1].toLowerCase() : p[0]);
                }
              },
              {
                key: 'formatLanguageCode',
                value: function formatLanguageCode(code) {
                  if (typeof code === 'string' && code.indexOf('-') > -1) {
                    var _code$split = code.split('-');
                    var _code$split2 = _slicedToArray(_code$split, 2);
                    var head = _code$split2[0];
                    var tail = _code$split2[1];
                    return this.options.lowerCaseLng ? head.toLowerCase() + '-' + tail.toLowerCase() : head.toLowerCase() + '-' + tail.toUpperCase();
                  } else {
                    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
                  }
                }
              },
              {
                key: 'isWhitelisted',
                value: function isWhitelisted(code, exactMatch) {
                  if (this.options.load === 'languageOnly' || this.options.nonExplicitWhitelist && !exactMatch) {
                    code = this.getLanguagePartFromCode(code);
                  }
                  return !this.whitelist || !this.whitelist.length || this.whitelist.indexOf(code) > -1 ? true : false;
                }
              },
              {
                key: 'toResolveHierarchy',
                value: function toResolveHierarchy(code, fallbackCode) {
                  var _this = this;
                  fallbackCode = fallbackCode || this.options.fallbackLng || [];
                  if (typeof fallbackCode === 'string')
                    fallbackCode = [fallbackCode];
                  var codes = [];
                  var addCode = function addCode(code, exactMatch) {
                    if (_this.isWhitelisted(code, exactMatch)) {
                      codes.push(code);
                    } else {
                      _this.logger.warn('rejecting non-whitelisted language code: ' + code);
                    }
                  };
                  if (typeof code === 'string' && code.indexOf('-') > -1) {
                    if (this.options.load !== 'languageOnly')
                      addCode(this.formatLanguageCode(code), true);
                    if (this.options.load !== 'currentOnly')
                      addCode(this.getLanguagePartFromCode(code));
                  } else if (typeof code === 'string') {
                    addCode(this.formatLanguageCode(code));
                  }
                  fallbackCode.forEach(function (fc) {
                    if (codes.indexOf(fc) < 0)
                      addCode(_this.formatLanguageCode(fc));
                  });
                  return codes;
                }
              }
            ]);
            return LanguageUtil;
          }();
          exports['default'] = LanguageUtil;
          module.exports = exports['default'];
          return exports;
        },
        { './logger': 12 }
      ],
      6: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var _logger = require('./logger');
          var _logger2 = _interopRequireDefault(_logger);
          // definition http://translate.sourceforge.net/wiki/l10n/pluralforms
          /* eslint-disable */
          var sets = [
            {
              lngs: [
                'ach',
                'ak',
                'am',
                'arn',
                'br',
                'fil',
                'gun',
                'ln',
                'mfe',
                'mg',
                'mi',
                'oc',
                'tg',
                'ti',
                'tr',
                'uz',
                'wa'
              ],
              nr: [
                1,
                2
              ],
              fc: 1
            },
            {
              lngs: [
                'af',
                'an',
                'ast',
                'az',
                'bg',
                'bn',
                'ca',
                'da',
                'de',
                'dev',
                'el',
                'en',
                'eo',
                'es',
                'es_ar',
                'et',
                'eu',
                'fi',
                'fo',
                'fur',
                'fy',
                'gl',
                'gu',
                'ha',
                'he',
                'hi',
                'hu',
                'hy',
                'ia',
                'it',
                'kn',
                'ku',
                'lb',
                'mai',
                'ml',
                'mn',
                'mr',
                'nah',
                'nap',
                'nb',
                'ne',
                'nl',
                'nn',
                'no',
                'nso',
                'pa',
                'pap',
                'pms',
                'ps',
                'pt',
                'pt_br',
                'rm',
                'sco',
                'se',
                'si',
                'so',
                'son',
                'sq',
                'sv',
                'sw',
                'ta',
                'te',
                'tk',
                'ur',
                'yo'
              ],
              nr: [
                1,
                2
              ],
              fc: 2
            },
            {
              lngs: [
                'ay',
                'bo',
                'cgg',
                'fa',
                'id',
                'ja',
                'jbo',
                'ka',
                'kk',
                'km',
                'ko',
                'ky',
                'lo',
                'ms',
                'sah',
                'su',
                'th',
                'tt',
                'ug',
                'vi',
                'wo',
                'zh'
              ],
              nr: [1],
              fc: 3
            },
            {
              lngs: [
                'be',
                'bs',
                'dz',
                'hr',
                'ru',
                'sr',
                'uk'
              ],
              nr: [
                1,
                2,
                5
              ],
              fc: 4
            },
            {
              lngs: ['ar'],
              nr: [
                0,
                1,
                2,
                3,
                11,
                100
              ],
              fc: 5
            },
            {
              lngs: [
                'cs',
                'sk'
              ],
              nr: [
                1,
                2,
                5
              ],
              fc: 6
            },
            {
              lngs: [
                'csb',
                'pl'
              ],
              nr: [
                1,
                2,
                5
              ],
              fc: 7
            },
            {
              lngs: ['cy'],
              nr: [
                1,
                2,
                3,
                8
              ],
              fc: 8
            },
            {
              lngs: ['fr'],
              nr: [
                1,
                2
              ],
              fc: 9
            },
            {
              lngs: ['ga'],
              nr: [
                1,
                2,
                3,
                7,
                11
              ],
              fc: 10
            },
            {
              lngs: ['gd'],
              nr: [
                1,
                2,
                3,
                20
              ],
              fc: 11
            },
            {
              lngs: ['is'],
              nr: [
                1,
                2
              ],
              fc: 12
            },
            {
              lngs: ['jv'],
              nr: [
                0,
                1
              ],
              fc: 13
            },
            {
              lngs: ['kw'],
              nr: [
                1,
                2,
                3,
                4
              ],
              fc: 14
            },
            {
              lngs: ['lt'],
              nr: [
                1,
                2,
                10
              ],
              fc: 15
            },
            {
              lngs: ['lv'],
              nr: [
                1,
                2,
                0
              ],
              fc: 16
            },
            {
              lngs: ['mk'],
              nr: [
                1,
                2
              ],
              fc: 17
            },
            {
              lngs: ['mnk'],
              nr: [
                0,
                1,
                2
              ],
              fc: 18
            },
            {
              lngs: ['mt'],
              nr: [
                1,
                2,
                11,
                20
              ],
              fc: 19
            },
            {
              lngs: ['or'],
              nr: [
                2,
                1
              ],
              fc: 2
            },
            {
              lngs: ['ro'],
              nr: [
                1,
                2,
                20
              ],
              fc: 20
            },
            {
              lngs: ['sl'],
              nr: [
                5,
                1,
                2,
                3
              ],
              fc: 21
            }
          ];
          var _rulesPluralsTypes = {
            1: function _(n) {
              return Number(n > 1);
            },
            2: function _(n) {
              return Number(n != 1);
            },
            3: function _(n) {
              return 0;
            },
            4: function _(n) {
              return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
            },
            5: function _(n) {
              return Number(n === 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
            },
            6: function _(n) {
              return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
            },
            7: function _(n) {
              return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
            },
            8: function _(n) {
              return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
            },
            9: function _(n) {
              return Number(n >= 2);
            },
            10: function _(n) {
              return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
            },
            11: function _(n) {
              return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
            },
            12: function _(n) {
              return Number(n % 10 != 1 || n % 100 == 11);
            },
            13: function _(n) {
              return Number(n !== 0);
            },
            14: function _(n) {
              return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
            },
            15: function _(n) {
              return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
            },
            16: function _(n) {
              return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
            },
            17: function _(n) {
              return Number(n == 1 || n % 10 == 1 ? 0 : 1);
            },
            18: function _(n) {
              return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
            },
            19: function _(n) {
              return Number(n == 1 ? 0 : n === 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
            },
            20: function _(n) {
              return Number(n == 1 ? 0 : n === 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
            },
            21: function _(n) {
              return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
            }
          };
          /* eslint-enable */
          var PluralResolver = function () {
            function PluralResolver(languageUtils) {
              var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
              _classCallCheck(this, PluralResolver);
              this.rules = function () {
                var l, rules = {};
                sets.forEach(function (set) {
                  set.lngs.forEach(function (l) {
                    return rules[l] = {
                      numbers: set.nr,
                      plurals: _rulesPluralsTypes[set.fc]
                    };
                  });
                });
                return rules;
              }();
              this.languageUtils = languageUtils;
              this.options = options;
              this.logger = _logger2['default'].create('pluralResolver');
            }
            _createClass(PluralResolver, [
              {
                key: 'addRule',
                value: function addRule(lng, obj) {
                  this.rules[lng] = obj;
                }
              },
              {
                key: 'getRule',
                value: function getRule(code) {
                  return this.rules[this.languageUtils.getLanguagePartFromCode(code)];
                }
              },
              {
                key: 'needsPlural',
                value: function needsPlural(code) {
                  var rule = this.getRule(code);
                  return rule && rule.numbers.length <= 1 ? false : true;
                }
              },
              {
                key: 'getSuffix',
                value: function getSuffix(code, count) {
                  var rule = this.getRule(code);
                  if (rule) {
                    if (rule.numbers.length === 1)
                      return '';
                    // only singular
                    var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
                    var suffix = rule.numbers[idx];
                    // special treatment for lngs only having singular and plural
                    if (rule.numbers.length === 2 && rule.numbers[0] === 1) {
                      if (suffix === 2) {
                        suffix = 'plural';
                      } else if (suffix === 1) {
                        suffix = '';
                      }
                    }
                    // COMPATIBILITY JSON
                    if (this.options.compatibilityJSON === 'v1') {
                      if (suffix === 1)
                        return '';
                      if (typeof suffix === 'number')
                        return '_plural_' + suffix.toString();
                    }
                    return this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
                  } else {
                    this.logger.warn('no plural rule found for: ' + code);
                    return '';
                  }
                }
              }
            ]);
            return PluralResolver;
          }();
          exports['default'] = PluralResolver;
          module.exports = exports['default'];
          return exports;
        },
        { './logger': 12 }
      ],
      7: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _extends = Object.assign || function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get = function get(_x5, _x6, _x7) {
            var _again = true;
            while (_again) {
              var object = _x5, property = _x6, receiver = _x7;
              _again = false;
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === undefined) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return undefined;
                } else {
                  _x5 = parent;
                  _x6 = property;
                  _x7 = receiver;
                  _again = true;
                  desc = parent = undefined;
                }
              } else if ('value' in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === undefined) {
                  return undefined;
                }
                return getter.call(receiver);
              }
            }
          };
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj['default'] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var _EventEmitter2 = require('./EventEmitter');
          var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);
          var _utils = require('./utils');
          var utils = _interopRequireWildcard(_utils);
          var ResourceStore = function (_EventEmitter) {
            _inherits(ResourceStore, _EventEmitter);
            function ResourceStore() {
              var data = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
              var options = arguments.length <= 1 || arguments[1] === undefined ? {
                ns: ['translation'],
                defaultNS: 'translation'
              } : arguments[1];
              _classCallCheck(this, ResourceStore);
              _get(Object.getPrototypeOf(ResourceStore.prototype), 'constructor', this).call(this);
              this.data = data;
              this.options = options;
            }
            _createClass(ResourceStore, [
              {
                key: 'addNamespaces',
                value: function addNamespaces(ns) {
                  if (this.options.ns.indexOf(ns) < 0) {
                    this.options.ns.push(ns);
                  }
                }
              },
              {
                key: 'removeNamespaces',
                value: function removeNamespaces(ns) {
                  var index = this.options.ns.indexOf(ns);
                  if (index > -1) {
                    this.options.ns.splice(index, 1);
                  }
                }
              },
              {
                key: 'getResource',
                value: function getResource(lng, ns, key) {
                  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
                  var keySeparator = options.keySeparator || this.options.keySeparator || '.';
                  var path = [
                    lng,
                    ns
                  ];
                  if (key && typeof key !== 'string')
                    path = path.concat(key);
                  if (key && typeof key === 'string')
                    path = path.concat(key.split(keySeparator));
                  if (lng.indexOf('.') > -1) {
                    path = lng.split('.');
                  }
                  return utils.getPath(this.data, path);
                }
              },
              {
                key: 'addResource',
                value: function addResource(lng, ns, key, value) {
                  var options = arguments.length <= 4 || arguments[4] === undefined ? { silent: false } : arguments[4];
                  var path = [
                    lng,
                    ns
                  ];
                  if (key)
                    path = path.concat(key.split(this.options.keySeparator || '.'));
                  if (lng.indexOf('.') > -1) {
                    path = lng.split('.');
                    value = ns;
                    ns = path[1];
                  }
                  this.addNamespaces(ns);
                  utils.setPath(this.data, path, value);
                  if (!options.silent)
                    this.emit('added', lng, ns);
                }
              },
              {
                key: 'addResources',
                value: function addResources(lng, ns, resources) {
                  for (var m in resources) {
                    if (typeof resources[m] === 'string')
                      this.addResource(lng, ns, m, resources[m], { silent: true });
                  }
                  this.emit('added', lng, ns);
                }
              },
              {
                key: 'addResourceBundle',
                value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
                  var path = [
                    lng,
                    ns
                  ];
                  if (lng.indexOf('.') > -1) {
                    path = lng.split('.');
                    deep = resources;
                    resources = ns;
                    ns = path[1];
                  }
                  this.addNamespaces(ns);
                  var pack = utils.getPath(this.data, path) || {};
                  if (deep) {
                    utils.deepExtend(pack, resources, overwrite);
                  } else {
                    pack = _extends({}, pack, resources);
                  }
                  utils.setPath(this.data, path, pack);
                  this.emit('added', lng, ns);
                }
              },
              {
                key: 'removeResourceBundle',
                value: function removeResourceBundle(lng, ns) {
                  if (this.hasResourceBundle(lng, ns)) {
                    delete this.data[lng][ns];
                  }
                  this.removeNamespaces(ns);
                  this.emit('removed', lng, ns);
                }
              },
              {
                key: 'hasResourceBundle',
                value: function hasResourceBundle(lng, ns) {
                  return this.getResource(lng, ns) !== undefined;
                }
              },
              {
                key: 'getResourceBundle',
                value: function getResourceBundle(lng, ns) {
                  if (!ns)
                    ns = this.options.defaultNS;
                  // TODO: COMPATIBILITY remove extend in v2.1.0
                  if (this.options.compatibilityAPI === 'v1')
                    return _extends({}, this.getResource(lng, ns));
                  return this.getResource(lng, ns);
                }
              },
              {
                key: 'toJSON',
                value: function toJSON() {
                  return this.data;
                }
              }
            ]);
            return ResourceStore;
          }(_EventEmitter3['default']);
          exports['default'] = ResourceStore;
          module.exports = exports['default'];
          return exports;
        },
        {
          './EventEmitter': 3,
          './utils': 14
        }
      ],
      8: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _extends = Object.assign || function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get = function get(_x6, _x7, _x8) {
            var _again = true;
            while (_again) {
              var object = _x6, property = _x7, receiver = _x8;
              _again = false;
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === undefined) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return undefined;
                } else {
                  _x6 = parent;
                  _x7 = property;
                  _x8 = receiver;
                  _again = true;
                  desc = parent = undefined;
                }
              } else if ('value' in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === undefined) {
                  return undefined;
                }
                return getter.call(receiver);
              }
            }
          };
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj['default'] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var _logger = require('./logger');
          var _logger2 = _interopRequireDefault(_logger);
          var _EventEmitter2 = require('./EventEmitter');
          var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);
          var _postProcessor = require('./postProcessor');
          var _postProcessor2 = _interopRequireDefault(_postProcessor);
          var _compatibilityV1 = require('./compatibility/v1');
          var compat = _interopRequireWildcard(_compatibilityV1);
          var _utils = require('./utils');
          var utils = _interopRequireWildcard(_utils);
          var Translator = function (_EventEmitter) {
            _inherits(Translator, _EventEmitter);
            function Translator(services) {
              var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
              _classCallCheck(this, Translator);
              _get(Object.getPrototypeOf(Translator.prototype), 'constructor', this).call(this);
              utils.copy([
                'resourceStore',
                'languageUtils',
                'pluralResolver',
                'interpolator',
                'backendConnector'
              ], services, this);
              this.options = options;
              this.logger = _logger2['default'].create('translator');
            }
            _createClass(Translator, [
              {
                key: 'changeLanguage',
                value: function changeLanguage(lng) {
                  if (lng)
                    this.language = lng;
                }
              },
              {
                key: 'exists',
                value: function exists(key) {
                  var options = arguments.length <= 1 || arguments[1] === undefined ? { interpolation: {} } : arguments[1];
                  if (this.options.compatibilityAPI === 'v1') {
                    options = compat.convertTOptions(options);
                  }
                  return this.resolve(key, options) !== undefined;
                }
              },
              {
                key: 'extractFromKey',
                value: function extractFromKey(key, options) {
                  var nsSeparator = options.nsSeparator || this.options.nsSeparator || ':';
                  var namespaces = options.ns || this.options.defaultNS;
                  if (key.indexOf(nsSeparator) > -1) {
                    var parts = key.split(nsSeparator);
                    namespaces = parts[0];
                    key = parts[1];
                  }
                  if (typeof namespaces === 'string')
                    namespaces = [namespaces];
                  return {
                    key: key,
                    namespaces: namespaces
                  };
                }
              },
              {
                key: 'translate',
                value: function translate(keys) {
                  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                  if (typeof options !== 'object') {
                    options = this.options.overloadTranslationOptionHandler(arguments);
                  } else if (this.options.compatibilityAPI === 'v1') {
                    options = compat.convertTOptions(options);
                  }
                  // non valid keys handling
                  if (keys === undefined || keys === null || keys === '')
                    return '';
                  if (typeof keys === 'number')
                    keys = String(keys);
                  if (typeof keys === 'string')
                    keys = [keys];
                  // return key on CIMode
                  var lng = options.lng || this.language;
                  if (lng && lng.toLowerCase() === 'cimode')
                    return keys[keys.length - 1];
                  // separators
                  var keySeparator = options.keySeparator || this.options.keySeparator || '.';
                  // get namespace(s)
                  var _extractFromKey = this.extractFromKey(keys[keys.length - 1], options);
                  var key = _extractFromKey.key;
                  var namespaces = _extractFromKey.namespaces;
                  var namespace = namespaces[namespaces.length - 1];
                  // resolve from store
                  var res = this.resolve(keys, options);
                  var resType = Object.prototype.toString.apply(res);
                  var noObject = [
                    '[object Number]',
                    '[object Function]',
                    '[object RegExp]'
                  ];
                  var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;
                  // object
                  if (res && typeof res !== 'string' && noObject.indexOf(resType) < 0 && !(joinArrays && resType === '[object Array]')) {
                    if (!options.returnObjects && !this.options.returnObjects) {
                      this.logger.warn('accessing an object - but returnObjects options is not enabled!');
                      return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(key, res, options) : 'key \'' + key + ' (' + this.language + ')\' returned an object instead of string.';
                    }
                    var copy = resType === '[object Array]' ? [] : {};
                    // apply child translation on a copy
                    for (var m in res) {
                      copy[m] = this.translate('' + key + keySeparator + m, _extends({ joinArrays: false }, options));
                    }
                    res = copy;
                  }  // array special treatment
                  else if (joinArrays && resType === '[object Array]') {
                    res = res.join(joinArrays);
                    if (res)
                      res = this.extendTranslation(res, key, options);
                  }  // string, empty or null
                  else {
                    var usedDefault = false, usedKey = false;
                    // fallback value
                    if (!this.isValidLookup(res) && options.defaultValue) {
                      usedDefault = true;
                      res = options.defaultValue;
                    }
                    if (!this.isValidLookup(res)) {
                      usedKey = true;
                      res = key;
                    }
                    // save missing
                    if (usedKey || usedDefault) {
                      this.logger.log('missingKey', lng, namespace, key, res);
                      if (this.options.saveMissing) {
                        var lngs = [];
                        if (this.options.saveMissingTo === 'fallback' && this.options.fallbackLng[0]) {
                          for (var i = 0; i < this.options.fallbackLng.length; i++) {
                            lngs.push(this.options.fallbackLng[i]);
                          }
                        } else if (this.options.saveMissingTo === 'all') {
                          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
                        } else {
                          //(this.options.saveMissingTo === 'current' || (this.options.saveMissingTo === 'fallback' && this.options.fallbackLng[0] === false) ) {
                          lngs.push(options.lng || this.language);
                        }
                        if (this.options.missingKeyHandler) {
                          this.options.missingKeyHandler(lngs, namespace, key, res);
                        } else if (this.backendConnector && this.backendConnector.saveMissing) {
                          this.backendConnector.saveMissing(lngs, namespace, key, res);
                        }
                        this.emit('missingKey', lngs, namespace, key, res);
                      }
                    }
                    // extend
                    res = this.extendTranslation(res, key, options);
                    // append namespace if still key
                    if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
                      res = namespace + ':' + key;
                    // parseMissingKeyHandler
                    if (usedKey && this.options.parseMissingKeyHandler)
                      res = this.options.parseMissingKeyHandler(res);
                  }
                  // return
                  return res;
                }
              },
              {
                key: 'extendTranslation',
                value: function extendTranslation(res, key, options) {
                  var _this = this;
                  if (options.interpolation)
                    this.interpolator.init(options);
                  // interpolate
                  var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
                  if (this.options.interpolation.defaultVariables)
                    data = _extends({}, this.options.interpolation.defaultVariables, data);
                  res = this.interpolator.interpolate(res, data);
                  // nesting
                  res = this.interpolator.nest(res, function () {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                      args[_key] = arguments[_key];
                    }
                    return _this.translate.apply(_this, args);
                  }, options);
                  if (options.interpolation)
                    this.interpolator.reset();
                  // post process
                  var postProcess = options.postProcess || this.options.postProcess;
                  var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;
                  if (res !== undefined && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false)
                    res = _postProcessor2['default'].handle(postProcessorNames, res, key, options, this);
                  return res;
                }
              },
              {
                key: 'resolve',
                value: function resolve(keys) {
                  var _this2 = this;
                  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                  var found = undefined;
                  if (typeof keys === 'string')
                    keys = [keys];
                  // forEach possible key
                  keys.forEach(function (k) {
                    if (_this2.isValidLookup(found))
                      return;
                    var _extractFromKey2 = _this2.extractFromKey(k, options);
                    var key = _extractFromKey2.key;
                    var namespaces = _extractFromKey2.namespaces;
                    if (_this2.options.fallbackNS)
                      namespaces = namespaces.concat(_this2.options.fallbackNS);
                    var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
                    var needsContextHandling = options.context !== undefined && typeof options.context === 'string' && options.context !== '';
                    var codes = options.lngs ? options.lngs : _this2.languageUtils.toResolveHierarchy(options.lng || _this2.language);
                    namespaces.forEach(function (ns) {
                      if (_this2.isValidLookup(found))
                        return;
                      codes.forEach(function (code) {
                        if (_this2.isValidLookup(found))
                          return;
                        var finalKey = key;
                        var finalKeys = [finalKey];
                        // get key for context if needed
                        if (needsContextHandling)
                          finalKeys.push(finalKey += '_' + options.context);
                        // get key for plural if needed
                        if (needsPluralHandling)
                          finalKeys.push(finalKey += _this2.pluralResolver.getSuffix(code, options.count));
                        // iterate over finalKeys starting with most specific pluralkey (-> contextkey only) -> singularkey only
                        var possibleKey = undefined;
                        while (possibleKey = finalKeys.pop()) {
                          if (_this2.isValidLookup(found))
                            continue;
                          found = _this2.getResource(code, ns, possibleKey, options);
                        }
                      });
                    });
                  });
                  return found;
                }
              },
              {
                key: 'isValidLookup',
                value: function isValidLookup(res) {
                  return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
                }
              },
              {
                key: 'getResource',
                value: function getResource(code, ns, key) {
                  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
                  return this.resourceStore.getResource(code, ns, key, options);
                }
              }
            ]);
            return Translator;
          }(_EventEmitter3['default']);
          exports['default'] = Translator;
          module.exports = exports['default'];
          return exports;
        },
        {
          './EventEmitter': 3,
          './compatibility/v1': 9,
          './logger': 12,
          './postProcessor': 13,
          './utils': 14
        }
      ],
      9: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.convertAPIOptions = convertAPIOptions;
          exports.convertJSONOptions = convertJSONOptions;
          exports.convertTOptions = convertTOptions;
          exports.appendBackwardsAPI = appendBackwardsAPI;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          var _logger = require('../logger');
          var _logger2 = _interopRequireDefault(_logger);
          function convertInterpolation(options) {
            options.interpolation = { unescapeSuffix: 'HTML' };
            options.interpolation.prefix = options.interpolationPrefix || '__';
            options.interpolation.suffix = options.interpolationSuffix || '__';
            options.interpolation.escapeValue = options.escapeInterpolation || false;
            options.interpolation.nestingPrefix = options.reusePrefix || '$t(';
            options.interpolation.nestingSuffix = options.reuseSuffix || ')';
            return options;
          }
          function convertAPIOptions(options) {
            if (options.resStore)
              options.resources = options.resStore;
            if (options.ns && options.ns.defaultNs) {
              options.defaultNS = options.ns.defaultNs;
              options.ns = options.ns.namespaces;
            } else {
              options.defaultNS = options.ns || 'translation';
            }
            if (options.fallbackToDefaultNS && options.defaultNS)
              options.fallbackNS = options.defaultNS;
            options.saveMissing = options.sendMissing;
            options.saveMissingTo = options.sendMissingTo || 'current';
            options.returnNull = options.fallbackOnNull ? false : true;
            options.returnEmptyString = options.fallbackOnEmpty ? false : true;
            options.returnObjects = options.returnObjectTrees;
            options.joinArrays = '\n';
            options.returnedObjectHandler = options.objectTreeKeyHandler;
            options.parseMissingKeyHandler = options.parseMissingKey;
            options.appendNamespaceToMissingKey = true;
            options.nsSeparator = options.nsseparator;
            options.keySeparator = options.keyseparator;
            if (options.shortcutFunction === 'sprintf') {
              options.overloadTranslationOptionHandler = function (args) {
                var values = [];
                for (var i = 1; i < args.length; i++) {
                  values.push(args[i]);
                }
                return {
                  postProcess: 'sprintf',
                  sprintf: values
                };
              };
            }
            options.whitelist = options.lngWhitelist;
            options.preload = options.preload;
            if (options.load === 'current')
              options.load = 'currentOnly';
            if (options.load === 'unspecific')
              options.load = 'languageOnly';
            // backend
            options.backend = options.backend || {};
            options.backend.loadPath = options.resGetPath || 'locales/__lng__/__ns__.json';
            options.backend.addPath = options.resPostPath || 'locales/add/__lng__/__ns__';
            options.backend.allowMultiLoading = options.dynamicLoad;
            // cache
            options.cache = options.cache || {};
            options.cache.prefix = 'res_';
            options.cache.expirationTime = 7 * 24 * 60 * 60 * 1000;
            options.cache.enabled = options.useLocalStorage ? true : false;
            options = convertInterpolation(options);
            if (options.defaultVariables)
              options.interpolation.defaultVariables = options.defaultVariables;
            // TODO: deprecation
            // if (options.getAsync === false) throw deprecation error
            return options;
          }
          function convertJSONOptions(options) {
            options = convertInterpolation(options);
            options.joinArrays = '\n';
            return options;
          }
          function convertTOptions(options) {
            if (options.interpolationPrefix || options.interpolationSuffix || options.escapeInterpolation) {
              options = convertInterpolation(options);
            }
            options.nsSeparator = options.nsseparator;
            options.keySeparator = options.keyseparator;
            options.returnObjects = options.returnObjectTrees;
            return options;
          }
          function appendBackwardsAPI(i18n) {
            i18n.lng = function () {
              _logger2['default'].deprecate('i18next.lng() can be replaced by i18next.language for detected language or i18next.languages for languages ordered by translation lookup.');
              return i18n.services.languageUtils.toResolveHierarchy(i18n.language)[0];
            };
            i18n.preload = function (lngs, cb) {
              _logger2['default'].deprecate('i18next.preload() can be replaced with i18next.loadLanguages()');
              i18n.loadLanguages(lngs, cb);
            };
            i18n.setLng = function (lng, options, callback) {
              _logger2['default'].deprecate('i18next.setLng() can be replaced with i18next.changeLanguage() or i18next.getFixedT() to get a translation function with fixed language or namespace.');
              if (typeof options === 'function') {
                callback = options;
                options = {};
              }
              if (!options)
                options = {};
              if (options.fixLng === true) {
                if (callback)
                  return callback(null, i18n.getFixedT(lng));
              }
              i18n.changeLanguage(lng, callback);
            };
            i18n.addPostProcessor = function (name, fc) {
              _logger2['default'].deprecate('i18next.addPostProcessor() can be replaced by i18next.use({ type: \'postProcessor\', name: \'name\', process: fc })');
              i18n.use({
                type: 'postProcessor',
                name: name,
                process: fc
              });
            };
          }
          return exports;
        },
        { '../logger': 12 }
      ],
      10: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.get = get;
          exports.transformOptions = transformOptions;
          function get() {
            return {
              debug: false,
              ns: ['translation'],
              defaultNS: ['translation'],
              fallbackLng: ['dev'],
              fallbackNS: false,
              // string or array of namespaces
              whitelist: false,
              // array with whitelisted languages
              nonExplicitWhitelist: false,
              load: 'all',
              // | currentOnly | languageOnly
              preload: false,
              // array with preload languages
              keySeparator: '.',
              nsSeparator: ':',
              saveMissing: false,
              // enable to send missing values
              saveMissingTo: 'fallback',
              // 'current' || 'all'
              missingKeyHandler: false,
              // function(lng, ns, key, fallbackValue) -> override if prefer on handling
              postProcess: false,
              // string or array of postProcessor names
              returnNull: true,
              // allows null value as valid translation
              returnEmptyString: true,
              // allows empty string value as valid translation
              returnObjects: false,
              joinArrays: false,
              // or string to join array
              returnedObjectHandler: function returnedObjectHandler() {
              },
              // function(key, value, options) triggered if key returns object but returnObjects is set to false
              parseMissingKeyHandler: false,
              // function(key) parsed a key that was not found in t() before returning
              appendNamespaceToMissingKey: false,
              overloadTranslationOptionHandler: function overloadTranslationOptionHandler(args) {
                return { defaultValue: args[1] };
              },
              interpolation: {
                escapeValue: true,
                prefix: '{{',
                suffix: '}}',
                // prefixEscaped: '{{',
                // suffixEscaped: '}}',
                // unescapeSuffix: '',
                unescapePrefix: '-',
                nestingPrefix: '$t(',
                nestingSuffix: ')',
                // nestingPrefixEscaped: '$t(',
                // nestingSuffixEscaped: ')',
                defaultVariables: undefined  // object that can have values to interpolate on - extends passed in interpolation data
              }
            };
          }
          function transformOptions(options) {
            // create namespace object if namespace is passed in as string
            if (typeof options.ns === 'string')
              options.ns = [options.ns];
            if (typeof options.fallbackLng === 'string')
              options.fallbackLng = [options.fallbackLng];
            if (typeof options.fallbackNS === 'string')
              options.fallbackNS = [options.fallbackNS];
            return options;
          }
          return exports;
        },
        {}
      ],
      11: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _extends = Object.assign || function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get = function get(_x, _x2, _x3) {
            var _again = true;
            while (_again) {
              var object = _x, property = _x2, receiver = _x3;
              _again = false;
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === undefined) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return undefined;
                } else {
                  _x = parent;
                  _x2 = property;
                  _x3 = receiver;
                  _again = true;
                  desc = parent = undefined;
                }
              } else if ('value' in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === undefined) {
                  return undefined;
                }
                return getter.call(receiver);
              }
            }
          };
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj['default'] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var _logger = require('./logger');
          var _logger2 = _interopRequireDefault(_logger);
          var _EventEmitter2 = require('./EventEmitter');
          var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);
          var _ResourceStore = require('./ResourceStore');
          var _ResourceStore2 = _interopRequireDefault(_ResourceStore);
          var _Translator = require('./Translator');
          var _Translator2 = _interopRequireDefault(_Translator);
          var _LanguageUtils = require('./LanguageUtils');
          var _LanguageUtils2 = _interopRequireDefault(_LanguageUtils);
          var _PluralResolver = require('./PluralResolver');
          var _PluralResolver2 = _interopRequireDefault(_PluralResolver);
          var _Interpolator = require('./Interpolator');
          var _Interpolator2 = _interopRequireDefault(_Interpolator);
          var _BackendConnector = require('./BackendConnector');
          var _BackendConnector2 = _interopRequireDefault(_BackendConnector);
          var _CacheConnector = require('./CacheConnector');
          var _CacheConnector2 = _interopRequireDefault(_CacheConnector);
          var _defaults = require('./defaults');
          var _postProcessor = require('./postProcessor');
          var _postProcessor2 = _interopRequireDefault(_postProcessor);
          var _compatibilityV1 = require('./compatibility/v1');
          var compat = _interopRequireWildcard(_compatibilityV1);
          var I18n = function (_EventEmitter) {
            _inherits(I18n, _EventEmitter);
            function I18n(options, callback) {
              if (options === undefined)
                options = {};
              _classCallCheck(this, I18n);
              _get(Object.getPrototypeOf(I18n.prototype), 'constructor', this).call(this);
              this.options = options;
              this.services = {};
              this.logger = _logger2['default'];
              this.modules = {};
              if (callback && !this.isInitialized)
                this.init(options, callback);
            }
            _createClass(I18n, [
              {
                key: 'init',
                value: function init(options, callback) {
                  var _this = this;
                  if (typeof options === 'function') {
                    callback = options;
                    options = {};
                  }
                  if (options.compatibilityAPI === 'v1') {
                    this.options = _extends({}, (0, _defaults.get)(), (0, _defaults.transformOptions)(compat.convertAPIOptions(options)), {});
                  } else if (options.compatibilityJSON === 'v1') {
                    this.options = _extends({}, (0, _defaults.get)(), (0, _defaults.transformOptions)(compat.convertJSONOptions(options)), {});
                  } else {
                    this.options = _extends({}, (0, _defaults.get)(), this.options, (0, _defaults.transformOptions)(options));
                  }
                  if (!callback)
                    callback = function () {
                    };
                  function createClassOnDemand(ClassOrObject) {
                    if (!ClassOrObject)
                      return;
                    if (typeof ClassOrObject === 'function')
                      return new ClassOrObject();
                    return ClassOrObject;
                  }
                  // init services
                  if (!this.options.isClone) {
                    if (this.modules.logger) {
                      _logger2['default'].init(createClassOnDemand(this.modules.logger), this.options);
                    } else {
                      _logger2['default'].init(null, this.options);
                    }
                    var lu = new _LanguageUtils2['default'](this.options);
                    this.store = new _ResourceStore2['default'](this.options.resources, this.options);
                    var s = this.services;
                    s.logger = _logger2['default'];
                    s.resourceStore = this.store;
                    s.resourceStore.on('added removed', function (lng, ns) {
                      s.cacheConnector.save();
                    });
                    s.languageUtils = lu;
                    s.pluralResolver = new _PluralResolver2['default'](lu, {
                      prepend: '_',
                      compatibilityJSON: this.options.compatibilityJSON
                    });
                    s.interpolator = new _Interpolator2['default'](this.options);
                    s.backendConnector = new _BackendConnector2['default'](createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
                    // pipe events from backendConnector
                    s.backendConnector.on('*', function (event) {
                      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        args[_key - 1] = arguments[_key];
                      }
                      _this.emit.apply(_this, [event].concat(args));
                    });
                    s.backendConnector.on('loaded', function (loaded) {
                      s.cacheConnector.save();
                    });
                    s.cacheConnector = new _CacheConnector2['default'](createClassOnDemand(this.modules.cache), s.resourceStore, s, this.options);
                    // pipe events from backendConnector
                    s.cacheConnector.on('*', function (event) {
                      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                        args[_key2 - 1] = arguments[_key2];
                      }
                      _this.emit.apply(_this, [event].concat(args));
                    });
                    if (this.modules.languageDetector) {
                      s.languageDetector = createClassOnDemand(this.modules.languageDetector);
                      s.languageDetector.init(s, this.options.detection, this.options);
                    }
                    this.translator = new _Translator2['default'](this.services, this.options);
                    // pipe events from translator
                    this.translator.on('*', function (event) {
                      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
                        args[_key3 - 1] = arguments[_key3];
                      }
                      _this.emit.apply(_this, [event].concat(args));
                    });
                  }
                  // append api
                  var storeApi = [
                    'addResource',
                    'addResources',
                    'addResourceBundle',
                    'removeResourceBundle',
                    'hasResourceBundle',
                    'getResourceBundle'
                  ];
                  storeApi.forEach(function (fcName) {
                    _this[fcName] = function () {
                      return this.store[fcName].apply(this.store, arguments);
                    };
                  });
                  // TODO: COMPATIBILITY remove this
                  if (this.options.compatibilityAPI === 'v1')
                    compat.appendBackwardsAPI(this);
                  this.changeLanguage(this.options.lng, function (err, t) {
                    _this.emit('initialized', _this.options);
                    _this.logger.log('initialized', _this.options);
                    callback(err, t);
                  });
                }
              },
              {
                key: 'loadResources',
                value: function loadResources(callback) {
                  var _this2 = this;
                  if (!callback)
                    callback = function () {
                    };
                  if (!this.options.resources) {
                    (function () {
                      var toLoad = [];
                      var append = function append(lng) {
                        var lngs = _this2.services.languageUtils.toResolveHierarchy(lng);
                        lngs.forEach(function (l) {
                          if (toLoad.indexOf(l) < 0)
                            toLoad.push(l);
                        });
                      };
                      append(_this2.language);
                      if (_this2.options.preload) {
                        _this2.options.preload.forEach(function (l) {
                          append(l);
                        });
                      }
                      _this2.services.cacheConnector.load(toLoad, _this2.options.ns, function () {
                        _this2.services.backendConnector.load(toLoad, _this2.options.ns, callback);
                      });
                    }());
                  } else {
                    callback(null);
                  }
                }
              },
              {
                key: 'use',
                value: function use(module) {
                  if (module.type === 'backend') {
                    this.modules.backend = module;
                  }
                  if (module.type === 'cache') {
                    this.modules.cache = module;
                  }
                  if (module.type === 'logger' || module.log && module.warn && module.warn) {
                    this.modules.logger = module;
                  }
                  if (module.type === 'languageDetector') {
                    this.modules.languageDetector = module;
                  }
                  if (module.type === 'postProcessor') {
                    _postProcessor2['default'].addPostProcessor(module);
                  }
                  return this;
                }
              },
              {
                key: 'changeLanguage',
                value: function changeLanguage(lng, callback) {
                  var _this3 = this;
                  var done = function done(err) {
                    if (lng) {
                      _this3.emit('languageChanged', lng);
                      _this3.logger.log('languageChanged', lng);
                    }
                    if (callback)
                      callback(err, function () {
                        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                          args[_key4] = arguments[_key4];
                        }
                        return _this3.t.apply(_this3, args);
                      });
                  };
                  if (!lng && this.services.languageDetector)
                    lng = this.services.languageDetector.detect();
                  if (lng) {
                    this.language = lng;
                    this.languages = this.services.languageUtils.toResolveHierarchy(lng);
                    this.translator.changeLanguage(lng);
                    if (this.services.languageDetector)
                      this.services.languageDetector.cacheUserLanguage(lng);
                  }
                  this.loadResources(function (err) {
                    done(err);
                  });
                }
              },
              {
                key: 'getFixedT',
                value: function getFixedT(lng, ns) {
                  var _this4 = this;
                  var fixedT = function fixedT(key, options) {
                    options = options || {};
                    options.lng = options.lng || fixedT.lng;
                    options.ns = options.ns || fixedT.ns;
                    return _this4.t(key, options);
                  };
                  fixedT.lng = lng;
                  fixedT.ns = ns;
                  return fixedT;
                }
              },
              {
                key: 't',
                value: function t() {
                  return this.translator && this.translator.translate.apply(this.translator, arguments);
                }
              },
              {
                key: 'exists',
                value: function exists() {
                  return this.translator && this.translator.exists.apply(this.translator, arguments);
                }
              },
              {
                key: 'setDefaultNamespace',
                value: function setDefaultNamespace(ns) {
                  this.options.defaultNS = ns;
                }
              },
              {
                key: 'loadNamespaces',
                value: function loadNamespaces(ns, callback) {
                  var _this5 = this;
                  if (!this.options.ns)
                    return callback && callback();
                  if (typeof ns === 'string')
                    ns = [ns];
                  ns.forEach(function (n) {
                    if (_this5.options.ns.indexOf(n) < 0)
                      _this5.options.ns.push(n);
                  });
                  this.loadResources(callback);
                }
              },
              {
                key: 'loadLanguages',
                value: function loadLanguages(lngs, callback) {
                  if (typeof lngs === 'string')
                    lngs = [lngs];
                  this.options.preload = this.options.preload ? this.options.preload.concat(lngs) : lngs;
                  this.loadResources(callback);
                }
              },
              {
                key: 'dir',
                value: function dir(lng) {
                  if (!lng)
                    lng = this.language;
                  var ltrLngs = [
                    'ar',
                    'shu',
                    'sqr',
                    'ssh',
                    'xaa',
                    'yhd',
                    'yud',
                    'aao',
                    'abh',
                    'abv',
                    'acm',
                    'acq',
                    'acw',
                    'acx',
                    'acy',
                    'adf',
                    'ads',
                    'aeb',
                    'aec',
                    'afb',
                    'ajp',
                    'apc',
                    'apd',
                    'arb',
                    'arq',
                    'ars',
                    'ary',
                    'arz',
                    'auz',
                    'avl',
                    'ayh',
                    'ayl',
                    'ayn',
                    'ayp',
                    'bbz',
                    'pga',
                    'he',
                    'iw',
                    'ps',
                    'pbt',
                    'pbu',
                    'pst',
                    'prp',
                    'prd',
                    'ur',
                    'ydd',
                    'yds',
                    'yih',
                    'ji',
                    'yi',
                    'hbo',
                    'men',
                    'xmn',
                    'fa',
                    'jpr',
                    'peo',
                    'pes',
                    'prs',
                    'dv',
                    'sam'
                  ];
                  return ltrLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) ? 'ltr' : 'rtl';
                }
              },
              {
                key: 'createInstance',
                value: function createInstance(options, callback) {
                  if (options === undefined)
                    options = {};
                  return new I18n(options, callback);
                }
              },
              {
                key: 'cloneInstance',
                value: function cloneInstance(options, callback) {
                  var _this6 = this;
                  if (options === undefined)
                    options = {};
                  var clone = new I18n(_extends({}, options, this.options, { isClone: true }), callback);
                  var membersToCopy = [
                    'store',
                    'translator',
                    'services',
                    'language'
                  ];
                  membersToCopy.forEach(function (m) {
                    clone[m] = _this6[m];
                  });
                  return clone;
                }
              }
            ]);
            return I18n;
          }(_EventEmitter3['default']);
          exports['default'] = new I18n();
          module.exports = exports['default'];
          return exports;
        },
        {
          './BackendConnector': 1,
          './CacheConnector': 2,
          './EventEmitter': 3,
          './Interpolator': 4,
          './LanguageUtils': 5,
          './PluralResolver': 6,
          './ResourceStore': 7,
          './Translator': 8,
          './compatibility/v1': 9,
          './defaults': 10,
          './logger': 12,
          './postProcessor': 13
        }
      ],
      12: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _extends = Object.assign || function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var consoleLogger = {
            type: 'logger',
            log: function log(args) {
              this._output('log', args);
            },
            warn: function warn(args) {
              this._output('warn', args);
            },
            error: function error(args) {
              this._output('error', args);
            },
            _output: function _output(type, args) {
              if (console && console[type])
                console[type].apply(console, Array.prototype.slice.call(args));
            }
          };
          var Logger = function () {
            function Logger(concreteLogger) {
              var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
              _classCallCheck(this, Logger);
              this.subs = [];
              this.init(concreteLogger, options);
            }
            _createClass(Logger, [
              {
                key: 'init',
                value: function init(concreteLogger) {
                  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                  this.prefix = options.prefix || 'i18next:';
                  this.logger = concreteLogger || consoleLogger;
                  this.options = options;
                  this.debug = options.debug === false ? false : true;
                }
              },
              {
                key: 'setDebug',
                value: function setDebug(bool) {
                  this.debug = bool;
                  this.subs.forEach(function (sub) {
                    sub.setDebug(bool);
                  });
                }
              },
              {
                key: 'log',
                value: function log() {
                  this.forward(arguments, 'log', '', true);
                }
              },
              {
                key: 'warn',
                value: function warn() {
                  this.forward(arguments, 'warn', '', true);
                }
              },
              {
                key: 'error',
                value: function error() {
                  this.forward(arguments, 'error', '');
                }
              },
              {
                key: 'deprecate',
                value: function deprecate() {
                  this.forward(arguments, 'warn', 'WARNING DEPRECATED: ', true);
                }
              },
              {
                key: 'forward',
                value: function forward(args, lvl, prefix, debugOnly) {
                  if (debugOnly && !this.debug)
                    return;
                  if (typeof args[0] === 'string')
                    args[0] = prefix + this.prefix + ' ' + args[0];
                  this.logger[lvl](args);
                }
              },
              {
                key: 'create',
                value: function create(moduleName) {
                  var sub = new Logger(this.logger, _extends({ prefix: this.prefix + ':' + moduleName + ':' }, this.options));
                  this.subs.push(sub);
                  return sub;
                }  // createInstance(options = {}) {
                   //   return new Logger(options, callback);
                   // }
              }
            ]);
            return Logger;
          }();
          exports['default'] = new Logger();
          module.exports = exports['default'];
          return exports;
        },
        {}
      ],
      13: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports['default'] = {
            processors: {},
            addPostProcessor: function addPostProcessor(module) {
              this.processors[module.name] = module;
            },
            handle: function handle(processors, value, key, options, translator) {
              var _this = this;
              processors.forEach(function (processor) {
                if (_this.processors[processor])
                  value = _this.processors[processor].process(value, key, options, translator);
              });
              return value;
            }
          };
          module.exports = exports['default'];
          return exports;
        },
        {}
      ],
      14: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.makeString = makeString;
          exports.copy = copy;
          exports.setPath = setPath;
          exports.pushPath = pushPath;
          exports.getPath = getPath;
          exports.deepExtend = deepExtend;
          exports.regexEscape = regexEscape;
          exports.escape = escape;
          function makeString(object) {
            if (object == null)
              return '';
            return '' + object;
          }
          function copy(a, s, t) {
            a.forEach(function (m) {
              if (s[m])
                t[m] = s[m];
            });
          }
          function getLastOfPath(object, path, Empty) {
            function cleanKey(key) {
              return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
            }
            var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');
            while (stack.length > 1) {
              if (!object)
                return {};
              var key = cleanKey(stack.shift());
              if (!object[key] && Empty)
                object[key] = new Empty();
              object = object[key];
            }
            if (!object)
              return {};
            return {
              obj: object,
              k: cleanKey(stack.shift())
            };
          }
          function setPath(object, path, newValue) {
            var _getLastOfPath = getLastOfPath(object, path, Object);
            var obj = _getLastOfPath.obj;
            var k = _getLastOfPath.k;
            obj[k] = newValue;
          }
          function pushPath(object, path, newValue, concat) {
            var _getLastOfPath2 = getLastOfPath(object, path, Object);
            var obj = _getLastOfPath2.obj;
            var k = _getLastOfPath2.k;
            obj[k] = obj[k] || [];
            if (concat)
              obj[k] = obj[k].concat(newValue);
            if (!concat)
              obj[k].push(newValue);
          }
          function getPath(object, path) {
            var _getLastOfPath3 = getLastOfPath(object, path);
            var obj = _getLastOfPath3.obj;
            var k = _getLastOfPath3.k;
            if (!obj)
              return undefined;
            return obj[k];
          }
          function deepExtend(target, source, overwrite) {
            for (var prop in source) {
              if (prop in target) {
                // If we reached a leaf string in target or source then replace with source or skip depending on the 'overwrite' switch
                if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
                  if (overwrite)
                    target[prop] = source[prop];
                } else {
                  deepExtend(target[prop], source[prop], overwrite);
                }
              } else {
                target[prop] = source[prop];
              }
            }
            return target;
          }
          function regexEscape(str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
          }
          /* eslint-disable */
          var _entityMap = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            '\'': '&#39;',
            '/': '&#x2F;'
          };
          /* eslint-enable */
          function escape(data) {
            if (typeof data === 'string') {
              return data.replace(/[&<>"'\/]/g, function (s) {
                return _entityMap[s];
              });
            } else {
              return data;
            }
          }
          return exports;
        },
        {}
      ]
    }, {}, [11])(11);
  }));
  (function (f) {
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = f();
    } else if (true) {
      libs_i18next_xhr_backend = function () {
        return typeof f === 'function' ? f() : f;
      }();
    } else {
      var g;
      if (typeof window !== 'undefined') {
        g = window;
      } else if (typeof global !== 'undefined') {
        g = global;
      } else if (typeof self !== 'undefined') {
        g = self;
      } else {
        g = this;
      }
      g.i18nextXHRBackend = f();
    }
  }(function () {
    var define, module, exports;
    return function e(t, n, r) {
      function s(o, u) {
        if (!n[o]) {
          if (!t[o]) {
            var a = typeof require == 'function' && require;
            if (!u && a)
              return a(o, !0);
            if (i)
              return i(o, !0);
            var f = new Error('Cannot find module \'' + o + '\'');
            throw f.code = 'MODULE_NOT_FOUND', f;
          }
          var l = n[o] = { exports: {} };
          t[o][0].call(l.exports, function (e) {
            var n = t[o][1][e];
            return s(n ? n : e);
          }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
      }
      var i = typeof require == 'function' && require;
      for (var o = 0; o < r.length; o++)
        s(r[o]);
      return s;
    }({
      1: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj['default'] = obj;
              return newObj;
            }
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var _utils = require('./utils');
          var utils = _interopRequireWildcard(_utils);
          // https://gist.github.com/Xeoncross/7663273
          function ajax(url, options, callback, data, cache) {
            // Must encode data
            if (data && typeof data === 'object') {
              var y = '', e = encodeURIComponent;
              for (var m in data) {
                y += '&' + e(m) + '=' + e(data[m]);
              }
              data = y.slice(1) + (!cache ? '&_t=' + new Date() : '');
            }
            try {
              var x = new (XMLHttpRequest || ActiveXObject)('MSXML2.XMLHTTP.3.0');
              x.open(data ? 'POST' : 'GET', url, 1);
              if (!options.crossDomain) {
                x.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
              }
              x.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
              x.onreadystatechange = function () {
                x.readyState > 3 && callback && callback(x.responseText, x);
              };
              x.send(data);
            } catch (e) {
              window.console && console.log(e);
            }
          }
          // ajax.uriEncode = function(o) {
          //     var x, y = '', e = encodeURIComponent;
          //     for (x in o) y += '&' + e(x) + '=' + e(o[x]);
          //     return y.slice(1);
          // };
          //
          // ajax.collect = (a, f) {
          //     var n = [];
          //     for (var i = 0; i < a.length; i++) {
          //         var v = f(a[i]);
          //         if (v != null) n.push(v);
          //     }
          //     return n;
          // };
          //
          // ajax.serialize = function (f) {
          //     function g(n) {
          //         return f.getElementsByTagName(n);
          //     };
          //     var nv = function (e) {
          //         if (e.name) return encodeURIComponent(e.name) + '=' + encodeURIComponent(e.value);
          //     };
          //     var i = collect(g('input'), function (i) {
          //         if ((i.type != 'radio' && i.type != 'checkbox') || i.checked) return nv(i);
          //     });
          //     var s = collect(g('select'), nv);
          //     var t = collect(g('textarea'), nv);
          //     return i.concat(s).concat(t).join('&');
          // };
          //
          function getDefaults() {
            return {
              loadPath: '/locales/{{lng}}/{{ns}}.json',
              addPath: 'locales/add/{{lng}}/{{ns}}',
              allowMultiLoading: false,
              parse: JSON.parse,
              crossDomain: false,
              ajax: ajax
            };
          }
          var Backend = function () {
            function Backend(services) {
              var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
              _classCallCheck(this, Backend);
              this.init(services, options);
              this.type = 'backend';
            }
            _createClass(Backend, [
              {
                key: 'init',
                value: function init(services) {
                  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                  this.services = services;
                  this.options = utils.defaults(options, this.options || {}, getDefaults());
                }
              },
              {
                key: 'readMulti',
                value: function readMulti(languages, namespaces, callback) {
                  var url = this.services.interpolator.interpolate(this.options.loadPath, {
                    lng: languages.join('+'),
                    ns: namespaces.join('+')
                  });
                  this.loadUrl(url, callback);
                }
              },
              {
                key: 'read',
                value: function read(language, namespace, callback) {
                  var url = this.services.interpolator.interpolate(this.options.loadPath, {
                    lng: language,
                    ns: namespace
                  });
                  this.loadUrl(url, callback);
                }
              },
              {
                key: 'loadUrl',
                value: function loadUrl(url, callback) {
                  var _this = this;
                  this.options.ajax(url, this.options, function (data, xhr) {
                    var statusCode = xhr.status.toString();
                    if (statusCode.indexOf('5') === 0)
                      return callback('failed loading ' + url, true  /* retry */);
                    if (statusCode.indexOf('4') === 0)
                      return callback('failed loading ' + url, false  /* no retry */);
                    var ret = undefined, err = undefined;
                    try {
                      ret = _this.options.parse(data);
                    } catch (e) {
                      err = 'failed parsing ' + url + ' to json';
                    }
                    if (err)
                      return callback(err, false);
                    callback(null, ret);
                  });
                }
              },
              {
                key: 'create',
                value: function create(languages, namespace, key, fallbackValue) {
                  var _this2 = this;
                  if (typeof languages === 'string')
                    languages = [languages];
                  var payload = {};
                  payload[key] = fallbackValue || '';
                  languages.forEach(function (lng) {
                    var url = _this2.services.interpolator.interpolate(_this2.options.addPath, {
                      lng: lng,
                      ns: namespace
                    });
                    this.options.ajax(url, _this2.options, function (data, xhr) {
                    }, payload);
                  });
                }
              }
            ]);
            return Backend;
          }();
          Backend.type = 'backend';
          exports['default'] = Backend;
          module.exports = exports['default'];
          return exports;
        },
        { './utils': 2 }
      ],
      2: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.defaults = defaults;
          exports.extend = extend;
          var arr = [];
          var each = arr.forEach;
          var slice = arr.slice;
          function defaults(obj) {
            each.call(slice.call(arguments, 1), function (source) {
              if (source) {
                for (var prop in source) {
                  if (obj[prop] === undefined)
                    obj[prop] = source[prop];
                }
              }
            });
            return obj;
          }
          function extend(obj) {
            each.call(slice.call(arguments, 1), function (source) {
              if (source) {
                for (var prop in source) {
                  obj[prop] = source[prop];
                }
              }
            });
            return obj;
          }
          return exports;
        },
        {}
      ]
    }, {}, [1])(1);
  }));
  (function (f) {
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = f();
    } else if (true) {
      libs_i18next_browser_languageDetector = function () {
        return typeof f === 'function' ? f() : f;
      }();
    } else {
      var g;
      if (typeof window !== 'undefined') {
        g = window;
      } else if (typeof global !== 'undefined') {
        g = global;
      } else if (typeof self !== 'undefined') {
        g = self;
      } else {
        g = this;
      }
      g.i18nextBrowserLanguageDetector = f();
    }
  }(function () {
    var define, module, exports;
    return function e(t, n, r) {
      function s(o, u) {
        if (!n[o]) {
          if (!t[o]) {
            var a = typeof require == 'function' && require;
            if (!u && a)
              return a(o, !0);
            if (i)
              return i(o, !0);
            var f = new Error('Cannot find module \'' + o + '\'');
            throw f.code = 'MODULE_NOT_FOUND', f;
          }
          var l = n[o] = { exports: {} };
          t[o][0].call(l.exports, function (e) {
            var n = t[o][1][e];
            return s(n ? n : e);
          }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
      }
      var i = typeof require == 'function' && require;
      for (var o = 0; o < r.length; o++)
        s(r[o]);
      return s;
    }({
      1: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var cookie = {
            create: function create(name, value, minutes, domain) {
              var expires = undefined;
              if (minutes) {
                var date = new Date();
                date.setTime(date.getTime() + minutes * 60 * 1000);
                expires = '; expires=' + date.toGMTString();
              } else
                expires = '';
              domain = domain ? 'domain=' + domain + ';' : '';
              document.cookie = name + '=' + value + expires + ';' + domain + 'path=/';
            },
            read: function read(name) {
              var nameEQ = name + '=';
              var ca = document.cookie.split(';');
              for (var i = 0; i < ca.length; i++) {
                var c = ca[i];
                while (c.charAt(0) === ' ')
                  c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0)
                  return c.substring(nameEQ.length, c.length);
              }
              return null;
            },
            remove: function remove(name) {
              this.create(name, '', -1);
            }
          };
          exports['default'] = {
            name: 'cookie',
            lookup: function lookup(options) {
              var found = undefined;
              if (options.lookupCookie && typeof document !== 'undefined') {
                var c = cookie.read(options.lookupCookie);
                if (c)
                  found = c;
              }
              return found;
            },
            cacheUserLanguage: function cacheUserLanguage(lng, options) {
              if (options.lookupCookie && typeof document !== 'undefined') {
                cookie.create(options.lookupCookie, lng, options.cookieMinutes, options.cookieDomain);
              }
            }
          };
          module.exports = exports['default'];
          return exports;
        },
        {}
      ],
      2: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var storage = {
            setItem: function setItem(key, value) {
              if (window.localStorage) {
                try {
                  window.localStorage.setItem(key, value);
                } catch (e) {
                }
              }
            },
            getItem: function getItem(key, value) {
              if (window.localStorage) {
                try {
                  return window.localStorage.getItem(key, value);
                } catch (e) {
                  return undefined;
                }
              }
            }
          };
          var hasLocalStorageSupport = void 0;
          try {
            hasLocalStorageSupport = window !== 'undefined' && window.localStorage !== null;
            var testKey = 'i18next.translate.boo';
            window.localStorage.setItem(testKey, 'foo');
            window.localStorage.removeItem(testKey);
          } catch (e) {
            hasLocalStorageSupport = false;
          }
          exports['default'] = {
            name: 'localStorage',
            lookup: function lookup(options) {
              var found = undefined;
              if (options.lookupLocalStorage && typeof window !== 'undefined' && hasLocalStorageSupport) {
                var lng = storage.getItem(options.lookupLocalStorage);
                if (lng)
                  found = lng;
              }
              return found;
            },
            cacheUserLanguage: function cacheUserLanguage(lng, options) {
              if (options.lookupLocalStorage && typeof window !== 'undefined' && hasLocalStorageSupport) {
                storage.setItem(options.lookupLocalStorage, lng);
              }
            }
          };
          module.exports = exports['default'];
          return exports;
        },
        {}
      ],
      3: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports['default'] = {
            name: 'navigator',
            lookup: function lookup(options) {
              var found = [];
              if (typeof navigator !== 'undefined') {
                if (navigator.languages) {
                  // chrome only; not an array, so can't use .push.apply instead of iterating
                  for (var i = 0; i < navigator.languages.length; i++) {
                    found.push(navigator.languages[i]);
                  }
                }
                if (navigator.userLanguage) {
                  found.push(navigator.userLanguage);
                }
                if (navigator.language) {
                  found.push(navigator.language);
                }
              }
              return found.length > 0 ? found : undefined;
            }
          };
          module.exports = exports['default'];
          return exports;
        },
        {}
      ],
      4: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports['default'] = {
            name: 'querystring',
            lookup: function lookup(options) {
              var found = undefined;
              if (typeof window !== 'undefined') {
                var query = window.location.search.substring(1);
                var params = query.split('&');
                for (var i = 0; i < params.length; i++) {
                  var pos = params[i].indexOf('=');
                  if (pos > 0) {
                    var key = params[i].substring(0, pos);
                    if (key === options.lookupQuerystring) {
                      found = params[i].substring(pos + 1);
                    }
                  }
                }
              }
              return found;
            }
          };
          module.exports = exports['default'];
          return exports;
        },
        {}
      ],
      5: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj['default'] = obj;
              return newObj;
            }
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var _utils = require('./utils');
          var utils = _interopRequireWildcard(_utils);
          var _browserLookupsCookie = require('./browserLookups/cookie');
          var _browserLookupsCookie2 = _interopRequireDefault(_browserLookupsCookie);
          var _browserLookupsQuerystring = require('./browserLookups/querystring');
          var _browserLookupsQuerystring2 = _interopRequireDefault(_browserLookupsQuerystring);
          var _browserLookupsLocalStorage = require('./browserLookups/localStorage');
          var _browserLookupsLocalStorage2 = _interopRequireDefault(_browserLookupsLocalStorage);
          var _browserLookupsNavigator = require('./browserLookups/navigator');
          var _browserLookupsNavigator2 = _interopRequireDefault(_browserLookupsNavigator);
          function getDefaults() {
            return {
              order: [
                'querystring',
                'cookie',
                'localStorage',
                'navigator'
              ],
              lookupQuerystring: 'lng',
              lookupCookie: 'i18next',
              lookupLocalStorage: 'i18nextLng',
              // cache user language
              caches: ['localStorage']  //cookieMinutes: 10,
                                //cookieDomain: 'myDomain'
            };
          }
          var Browser = function () {
            function Browser(services) {
              var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
              _classCallCheck(this, Browser);
              this.type = 'languageDetector';
              this.detectors = {};
              this.init(services, options);
            }
            _createClass(Browser, [
              {
                key: 'init',
                value: function init(services) {
                  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                  var i18nOptions = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
                  this.services = services;
                  this.options = utils.defaults(options, this.options || {}, getDefaults());
                  this.i18nOptions = i18nOptions;
                  this.addDetector(_browserLookupsCookie2['default']);
                  this.addDetector(_browserLookupsQuerystring2['default']);
                  this.addDetector(_browserLookupsLocalStorage2['default']);
                  this.addDetector(_browserLookupsNavigator2['default']);
                }
              },
              {
                key: 'addDetector',
                value: function addDetector(detector) {
                  this.detectors[detector.name] = detector;
                }
              },
              {
                key: 'detect',
                value: function detect(detectionOrder) {
                  var _this = this;
                  if (!detectionOrder)
                    detectionOrder = this.options.order;
                  var detected = [];
                  detectionOrder.forEach(function (detectorName) {
                    if (_this.detectors[detectorName]) {
                      var lookup = _this.detectors[detectorName].lookup(_this.options);
                      if (lookup && typeof lookup === 'string')
                        lookup = [lookup];
                      if (lookup)
                        detected = detected.concat(lookup);
                    }
                  });
                  var found = undefined;
                  detected.forEach(function (lng) {
                    if (found)
                      return;
                    var cleanedLng = _this.services.languageUtils.formatLanguageCode(lng);
                    if (_this.services.languageUtils.isWhitelisted(cleanedLng))
                      found = cleanedLng;
                  });
                  return found || this.i18nOptions.fallbackLng[0];
                }
              },
              {
                key: 'cacheUserLanguage',
                value: function cacheUserLanguage(lng, caches) {
                  var _this2 = this;
                  if (!caches)
                    caches = this.options.caches;
                  caches.forEach(function (cacheName) {
                    if (_this2.detectors[cacheName])
                      _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
                  });
                }
              }
            ]);
            return Browser;
          }();
          Browser.type = 'languageDetector';
          exports['default'] = Browser;
          module.exports = exports['default'];
          return exports;
        },
        {
          './browserLookups/cookie': 1,
          './browserLookups/localStorage': 2,
          './browserLookups/navigator': 3,
          './browserLookups/querystring': 4,
          './utils': 6
        }
      ],
      6: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.defaults = defaults;
          exports.extend = extend;
          var arr = [];
          var each = arr.forEach;
          var slice = arr.slice;
          function defaults(obj) {
            each.call(slice.call(arguments, 1), function (source) {
              if (source) {
                for (var prop in source) {
                  if (obj[prop] === undefined)
                    obj[prop] = source[prop];
                }
              }
            });
            return obj;
          }
          function extend(obj) {
            each.call(slice.call(arguments, 1), function (source) {
              if (source) {
                for (var prop in source) {
                  obj[prop] = source[prop];
                }
              }
            });
            return obj;
          }
          return exports;
        },
        {}
      ]
    }, {}, [5])(5);
  }));
  i18next_loader = function (options, i18next, xhrBackend, browserLanguageDetector) {
    console.log('Loading i18next loader');
    i18next.use(xhrBackend).use(browserLanguageDetector).init(options, function () {
      console.log('Initialized i18n');
    });
    i18next.replace = function (template, fallbackProps, namespaces) {
      return template.replace(i18next.services.interpolator.regexp, function (match, key, format) {
        var options = {};
        if (namespaces) {
          options.ns = namespaces;
        }
        var translatedKey = fallbackProps && fallbackProps[key];
        if (!translatedKey && i18next.exists(key, options)) {
          translatedKey = i18next.t(key, options);
        }
        if (!translatedKey) {
          console.warn('MISSING TRANSLATION FOR KEY: ' + key);
          return key;
        }
        return translatedKey || key;
      });
    };
    return i18next;
  }(i18next_options, libs_i18next, libs_i18next_xhr_backend, libs_i18next_browser_languageDetector);
  i18next_inlineLocales = {
    load: function (id) {
      throw new Error('Dynamic load not allowed: ' + id);
    }
  };
  (function (i18next) {
    i18next.addResourceBundle('en-US', 'integration', {
      'agent.supportProfileLabel': 'Support Profile',
      'agent.startCobrowsing': 'Start Co-Browsing',
      'agent.sharedMode': 'Shared',
      'agent.viewOnly': 'View Only',
      'agent.follow': 'Follow',
      'agent.serviceNumber': 'Service Number',
      'agent.start': 'Start',
      'agent.starting': 'Starting...',
      'agent.close': 'Close',
      'agent.logout': 'Logout',
      'agent.generate': 'Generate',
      'agent.noPermissionCobrowseMessage': 'You do not have required Permissions to view this page please contact your manager.',
      'agent.serviceNumberGenerateInfo': 'Generating Service Number Please wait',
      'agent.serviceNumberInvalid': 'Invalid Service Number',
      'agent.serviceNumberExpire': 'This Service Number expires in {{timerVal}} seconds',
      'agent.serviceNumberExpired': 'This Service Number expired, please generate new one',
      'agent.dialogStartingText': 'Setting up Connection',
      'agent.dialogConnectionEstablished': 'Connection Established Successfully',
      'agent.dialogWaitingForUserAccept': 'Waiting for Visitor to accept cobrowse offer...',
      'agent.dialogRequestingCoBrowse': 'Visitor requesting cobrowse session...',
      'agent.dialogMissingVisitorId': 'Missing visitor Id...',
      'agent.dialogUnableToGenerateServiceId': 'Unable to generate a new service number...',
      'agent.dialogInitiatingConnection': 'Initiating connection',
      'agent.dialogValuesMissing': 'Values missing...',
      'agent.visitorDeclinedOfferMessage': 'Visitor has declined the Cobrowse Request',
      'agent.openedInNewBrowser': 'Session opened in new browser window',
      'common.OK': 'OK',
      'common.JOIN': 'Join',
      'common.START': 'Start',
      'common.CLOSE': 'Close',
      'common.CANCEL': 'Cancel',
      'common.SUBMIT': 'Submit',
      'common.NAME': 'Name',
      'common.EMAIL': 'Email',
      'common.EMAIL_PLACEHOLDER': 'name@example.com',
      'common.CHANGE_NAME': 'Change Name',
      'common.CHANGE_NAME_TEXT': 'Please enter your name.',
      'common.MAKE_CHOICE': 'Make a choice',
      'common.AGO_PREFIX': '',
      'common.AGO_SUFFIX': 'ago',
      'common.FROM': '',
      'common.NOW': 'just now',
      'common.MINUTE': 'minute',
      'common.MINUTES': 'minutes',
      'common.HOUR': 'hour',
      'common.HOURS': 'hours',
      'common.DAY': 'day',
      'common.DAYS': 'days',
      'common.WEEK': 'week',
      'common.WEEKS': 'weeks',
      'common.MONTH': 'month',
      'common.MONTHS': 'months',
      'common.YEAR': 'year',
      'common.YEARS': 'years',
      'common.CONNECTION_DENIED_TITLE': 'Session expired...',
      'common.CONNECTION_DENIED_TEXT': 'We will try to automatically reconnect your session. You may have to login again.',
      'common.CONNECTION_RESTORING_TEXT': 'Attempting to restore connection. Changes made now may not be saved.',
      'common.CONNECTION_BROKEN_TEXT': 'Connection interrupted.',
      'integration.SUPPORT_NUMBER_IS': 'Reach our support hotline at:',
      'integration.ENTER_USERNAME': 'Please enter your name:',
      'integration.MISSING_VALUE': 'This value is required.',
      'integration.STEP': 'Step',
      'integration.START': 'Start',
      'integration.CANCEL': 'Cancel',
      'integration.CLOSE': 'Close',
      'integration.SHOW_SERVICE_TITLE': 'Online Support',
      'integration.SHOW_SERVICE_NUMBER_HEADER': 'Service Number',
      'integration.SHOW_SERVICE_NUMBER_INFO': 'Please give the service number to an agent in order to share your browser window.',
      'integration.ENTER_SERVICE_NUMBER_INFO': 'Please enter the service number.',
      'integration.SECURITY_HEADER': 'Info',
      'integration.SECURITY_INFORMATION': '<b>We will have no access to your computer. </b> We only share the same view as you in your current browser window.',
      'integration.STANDBY': '...is being created.',
      'integration.NO_SUPPORT_DIALOG_HEADER': 'No agent is available at the moment.',
      'integration.NO_SUPPORT_DIALOG_CENTER': 'Close this dialog to return to the website.',
      'integration.SERVICE_HOURS_INTRO': 'Our operators are available during these hours:',
      'integration.NO_SUPPORT_DIALOG_TITLE': 'Live-Support is unavailable',
      'integration.SUPPORT_DIALOG_HEADER': 'Do you have a question?',
      'integration.SUPPORT_DIALOG_TITLE': 'Welcome to Live Support',
      'integration.SUPPORT_DIALOG_INTRO': 'If you like we will guide you interactively through the website. Sharing the same view in the browser helps us to assist you better.',
      'integration.SUPPORT_DIALOG_AGENT_IS': 'Your support agent is:',
      'integration.SUPPORT_DIALOG_BTN_REQUEST': 'Request support',
      'integration.SUPPORT_STEP1_LABEL': 'Enter your name and request support.',
      'integration.SUPPORT_STEP2_LABEL': 'Wait for availability of support agents.',
      'integration.SUPPORT_STEP3_LABEL': 'Confirm live support and clarify any open questions.',
      'integration.ACCEPT_TERMS': 'I accept the terms of service.',
      'integration.SHOW_TERMS': 'Show terms of service',
      'integration.CHAT_WELCOME_MESSAGE': 'Leave a question or comment and our agents will try to attend to you shortly.',
      'session.cobrowseSession': 'CoBrowse Session',
      'session.videoCall': 'Video Call',
      'session.voiceCall': 'Voice Call',
      'session.visitorLeftError': 'Visitor left the session. Please start a new session to continue.',
      'session.agentLeftError': 'Agent left the session',
      'session.noDataError': 'No data has been received from Visitor.<br>Please try to restart the session.',
      'session.blockedContent': 'This element cannot be shown in your browser during the cobrowsing session. It will only be visible in the visitor\'s browser',
      'session.restrictedPage': 'The visitor is browsing on a restricted page.<br>The session will continue once the visitor navigates to a non-restricted area.',
      'session.restrictedPageVisitor': 'Due to its content, this page cannot be viewed by your Agent. Your CoBrowse session will continue once you navigate to a non-restricted page.',
      'session.accessblocked': 'Direct data entry is blocked.',
      'session.connectionReestablished': 'Connection re-established',
      'session.connectionUnavailable': 'Connection unavailable. Trying to reconnect...',
      'session.sessionStarted': 'CoBrowse Session started',
      'session.sessionEnded': 'CoBrowse Session ended',
      'session.sessionActive': 'CoBrowse session is active',
      'session.standbytext': 'Please wait until the contents of this website have been activated.',
      'session.sessionPaused': 'The session was paused.',
      'session.sessionUnpaused': 'The session was restarted.',
      'session.loading': 'Loading',
      'session.wait': 'Please wait',
      'session.unlock': 'Unlock',
      'session.lock': 'Lock',
      'session.invite': 'Send Invitation',
      'session.copyLink': 'Simply copy & paste the link below to invite participants via your preferred instant messaging client.',
      'session.invitationDialogHeader': 'Invite Participants',
      'session.end': 'End Session',
      'session.loginFailed': 'Invalid username or wrong password',
      'session.incorrectCaptcha': 'Incorrect captcha!',
      'session.incorrectLogin': 'Login failed!',
      'session.captchaHelp': 'To verify that you are a human, please enter the words you see in the box below, in order and separataed by a space. Further <a href=\'javascript:Recaptcha.showhelp()\'>help</a>.',
      'session.accountLocked': 'The account is locked!',
      'session.missingUsername': 'Please enter a username!',
      'session.emailSent': 'The e-mail was sent to the specified user.',
      'session.nonEqualPasswords': 'The passwords must be equal!',
      'session.passwordChangeRequired': 'A password change is required!',
      'session.passwordNotDifferent': 'The new password must differ from the previous password!',
      'session.invalidToken': 'Invalid Token! Possible reasons are: The token was already used, is too old or was modified.',
      'session.insecurePassword': 'The password is not long enough!',
      'session.resetPasswordSuccess': 'Password successfully changed.',
      'session.resetPasswordFail': 'Failed to reset password! Possible reasons: Username does not exist or the new password is insufficiently long.',
      'session.confirmSynchExitMessage': 'Do you really want to exit the current session?',
      'session.confirm': 'Confirm',
      'session.invitationEmailMessage': 'Invite participants via Email.',
      'session.emailMessage': 'Message (optional)',
      'session.emailYourName': 'Your Name',
      'session.emailReceiptName': 'Recipient Name',
      'session.emailReceiptMail': 'Recipient Email',
      'session.sendEmailButton': 'Send Email',
      'session.socialNetworkMessage': 'Invite participants via Twitter, Facebook or Google+.',
      'session.socialNetworkInfo': 'If you are currenty not logged into the correspondent service, the login window for the service will pop-up and you are prompted to enter your username and password.',
      'session.logoContextMessage': 'Customer Service 2.0',
      'session.refreshButtonContextMessage': 'Re-synchronize current page',
      'session.urlPlaceHolder': 'Enter the Address here',
      'session.backButtonContextMessage': 'Go Back',
      'session.forwardButtonContextMessage': 'Go Forward',
      'session.exitSynchContextMessage': 'Exit CoBrowsing session',
      'session.pauseSessionContextMessage': 'Pause or restart the CoBrowsing session',
      'session.agentMenuContextMessage': 'Change personal settings',
      'session.invitationItemContextMessage': 'Share this CoBrowsing session with other people',
      'session.usersInfoContextMessage': 'Number of participants in this session',
      'session.lockButtonContextMessage': 'Lock the session (Nobody can join)',
      'session.lockButtonText': 'Session Unlocked',
      'session.toggleSessionStateContextMessage': 'Changing session state...',
      'session.toggleSessionStateText': 'Working...',
      'session.unlockButtonContextMessage': 'Unlock the session (Anyone can join)',
      'session.unlockButtonText': 'Session Locked',
      'session.linkLabel': 'Session Link',
      'session.emailLabel': 'Email',
      'session.socialnetworksLabel': 'Social Networks',
      'session.SEND_MAIL_ERROR': 'We\'re sorry. Something went wrong while sending your email.',
      'session.ERROR': 'Error',
      'session.SEND_MAIL_SUCCESS': 'Email sent.',
      'session.SUCCESS': 'Success',
      'session.USERS_ONLINE': 'Users Online',
      'session.CHANGE_POINTER': 'Change Pointer',
      'session.SESSION_IS_PAUSED': 'Please wait. The session is currently paused.',
      'session.FEEDBACK_SUCCESS': 'Your feedback has been sent successfully.',
      'session.FEEDBACK_FAIL': 'Failed to sent your feedback.',
      'session.SEND_FEEDBACK_LINK': 'Send Feedback',
      'session.SEND_FEEDBACK_LINK_TITLE': 'Send feedback, report problems or issues.',
      'session.UPLOAD_FILE_LINK': 'Upload File',
      'session.UPLOAD_FILE_LINK_TITLE': 'Upload a image or PDF which should be shared with other participants.',
      'session.SEND_FEEDBACK_TITLE': 'Report a Problem',
      'session.SEND_FEEDBACK_DESCRIPTION_TITLE': 'Problem Description',
      'session.SEND_FEEDBACK_DESCRIPTION_PLACEHOLDER': 'Please enter your problem description here. The description should describe the steps to reproduce the problem.',
      'session.SEND_FEEDBACK_DESCRIPTION_HINT': 'If you\'re reporting a problem, a good description should provide answers to the following questions:<p><ol><li>What were you doing when the problem occurred?</li><li>What did you expect to happen?</li><li>What did happen instead?</li></ol></p>',
      'session.FEEDBACK_INCLUDE_SCREENSHOT': 'Include Screenshot',
      'session.FEEDBACK_SCREENSHOT_PREVIEW': 'Screenshot Preview',
      'session.FEEDBACK_NO_IMAGE': 'No Image',
      'session.GENERATE_SCREENSHOT': 'Generating Screenshot...',
      'session.NO_SCREENSHOT_SUPPORT': 'Screenshot generation is not supported by your browser!',
      'session.IS_TYPING': 'is typing...',
      'session.csatMessage': 'Please rate this CoBrowse session',
      'session.csatAnswerFeedback': 'Thank you for communicating with us',
      'session.csatDisclaimer': 'Your feedback helps us serve you better. It will not be shared with any customer service representative.',
      'session.browserNotSupported': 'Your browser is not supported.',
      'session.remoteConsumerBrowserNotSupported': 'The consumer\'s browser is not supported.',
      'session.agentDisconnected': 'The agent was disconnected.',
      'session.visitorDeniedAccess': 'The visitor did not allow access to the camera/microphone or has no camera/microphone connected',
      'session.remoteAgentProblemJoining': 'Your agent was unable to join the call.',
      'session.clickHereToStart': 'Click here to start',
      'session.unableToGetCameraAccess': 'Unable to access your camera/microphone.',
      'session.unableToGetCameraAccessWithTip': 'Unable to access your camera/microphone. If you wish to participate in this call, please allow access to the camera and microphone in your browser and reload the page.',
      'session.unableToConnect': 'Unable to connect to Agent.',
      'session.callDropped': 'Call ended. Could not reconnect.',
      'session.callHasEnded': 'The call you are trying to join has ended.',
      'session.generalCallInitializationError': 'Could not join call.',
      'session.joinedCallFromAnotherBrowser': 'You joined the call from another browser. Refresh to rejoin.',
      'session.disconnected': 'Disconnected'
    });
    i18next.addResourceBundle('en-US', 'common', {
      'agent.supportProfileLabel': 'Support Profile',
      'agent.startCobrowsing': 'Start Co-Browsing',
      'agent.sharedMode': 'Shared',
      'agent.viewOnly': 'View Only',
      'agent.follow': 'Follow',
      'agent.serviceNumber': 'Service Number',
      'agent.start': 'Start',
      'agent.starting': 'Starting...',
      'agent.close': 'Close',
      'agent.logout': 'Logout',
      'agent.generate': 'Generate',
      'agent.noPermissionCobrowseMessage': 'You do not have required Permissions to view this page please contact your manager.',
      'agent.serviceNumberGenerateInfo': 'Generating Service Number Please wait',
      'agent.serviceNumberInvalid': 'Invalid Service Number',
      'agent.serviceNumberExpire': 'This Service Number expires in {{timerVal}} seconds',
      'agent.serviceNumberExpired': 'This Service Number expired, please generate new one',
      'agent.dialogStartingText': 'Setting up Connection',
      'agent.dialogConnectionEstablished': 'Connection Established Successfully',
      'agent.dialogWaitingForUserAccept': 'Waiting for Visitor to accept cobrowse offer...',
      'agent.dialogRequestingCoBrowse': 'Visitor requesting cobrowse session...',
      'agent.dialogMissingVisitorId': 'Missing visitor Id...',
      'agent.dialogUnableToGenerateServiceId': 'Unable to generate a new service number...',
      'agent.dialogInitiatingConnection': 'Initiating connection',
      'agent.dialogValuesMissing': 'Values missing...',
      'agent.visitorDeclinedOfferMessage': 'Visitor has declined the Cobrowse Request',
      'agent.openedInNewBrowser': 'Session opened in new browser window',
      'common.OK': 'OK',
      'common.JOIN': 'Join',
      'common.START': 'Start',
      'common.CLOSE': 'Close',
      'common.CANCEL': 'Cancel',
      'common.SUBMIT': 'Submit',
      'common.NAME': 'Name',
      'common.EMAIL': 'Email',
      'common.EMAIL_PLACEHOLDER': 'name@example.com',
      'common.CHANGE_NAME': 'Change Name',
      'common.CHANGE_NAME_TEXT': 'Please enter your name.',
      'common.MAKE_CHOICE': 'Make a choice',
      'common.AGO_PREFIX': '',
      'common.AGO_SUFFIX': 'ago',
      'common.FROM': '',
      'common.NOW': 'just now',
      'common.MINUTE': 'minute',
      'common.MINUTES': 'minutes',
      'common.HOUR': 'hour',
      'common.HOURS': 'hours',
      'common.DAY': 'day',
      'common.DAYS': 'days',
      'common.WEEK': 'week',
      'common.WEEKS': 'weeks',
      'common.MONTH': 'month',
      'common.MONTHS': 'months',
      'common.YEAR': 'year',
      'common.YEARS': 'years',
      'common.CONNECTION_DENIED_TITLE': 'Session expired...',
      'common.CONNECTION_DENIED_TEXT': 'We will try to automatically reconnect your session. You may have to login again.',
      'common.CONNECTION_RESTORING_TEXT': 'Attempting to restore connection. Changes made now may not be saved.',
      'common.CONNECTION_BROKEN_TEXT': 'Connection interrupted.',
      'integration.SUPPORT_NUMBER_IS': 'Reach our support hotline at:',
      'integration.ENTER_USERNAME': 'Please enter your name:',
      'integration.MISSING_VALUE': 'This value is required.',
      'integration.STEP': 'Step',
      'integration.START': 'Start',
      'integration.CANCEL': 'Cancel',
      'integration.CLOSE': 'Close',
      'integration.SHOW_SERVICE_TITLE': 'Online Support',
      'integration.SHOW_SERVICE_NUMBER_HEADER': 'Service Number',
      'integration.SHOW_SERVICE_NUMBER_INFO': 'Please give the service number to an agent in order to share your browser window.',
      'integration.ENTER_SERVICE_NUMBER_INFO': 'Please enter the service number.',
      'integration.SECURITY_HEADER': 'Info',
      'integration.SECURITY_INFORMATION': '<b>We will have no access to your computer. </b> We only share the same view as you in your current browser window.',
      'integration.STANDBY': '...is being created.',
      'integration.NO_SUPPORT_DIALOG_HEADER': 'No agent is available at the moment.',
      'integration.NO_SUPPORT_DIALOG_CENTER': 'Close this dialog to return to the website.',
      'integration.SERVICE_HOURS_INTRO': 'Our operators are available during these hours:',
      'integration.NO_SUPPORT_DIALOG_TITLE': 'Live-Support is unavailable',
      'integration.SUPPORT_DIALOG_HEADER': 'Do you have a question?',
      'integration.SUPPORT_DIALOG_TITLE': 'Welcome to Live Support',
      'integration.SUPPORT_DIALOG_INTRO': 'If you like we will guide you interactively through the website. Sharing the same view in the browser helps us to assist you better.',
      'integration.SUPPORT_DIALOG_AGENT_IS': 'Your support agent is:',
      'integration.SUPPORT_DIALOG_BTN_REQUEST': 'Request support',
      'integration.SUPPORT_STEP1_LABEL': 'Enter your name and request support.',
      'integration.SUPPORT_STEP2_LABEL': 'Wait for availability of support agents.',
      'integration.SUPPORT_STEP3_LABEL': 'Confirm live support and clarify any open questions.',
      'integration.ACCEPT_TERMS': 'I accept the terms of service.',
      'integration.SHOW_TERMS': 'Show terms of service',
      'integration.CHAT_WELCOME_MESSAGE': 'Leave a question or comment and our agents will try to attend to you shortly.',
      'session.cobrowseSession': 'CoBrowse Session',
      'session.videoCall': 'Video Call',
      'session.voiceCall': 'Voice Call',
      'session.visitorLeftError': 'Visitor left the session. Please start a new session to continue.',
      'session.agentLeftError': 'Agent left the session',
      'session.noDataError': 'No data has been received from Visitor.<br>Please try to restart the session.',
      'session.blockedContent': 'This element cannot be shown in your browser during the cobrowsing session. It will only be visible in the visitor\'s browser',
      'session.restrictedPage': 'The visitor is browsing on a restricted page.<br>The session will continue once the visitor navigates to a non-restricted area.',
      'session.restrictedPageVisitor': 'Due to its content, this page cannot be viewed by your Agent. Your CoBrowse session will continue once you navigate to a non-restricted page.',
      'session.accessblocked': 'Direct data entry is blocked.',
      'session.connectionReestablished': 'Connection re-established',
      'session.connectionUnavailable': 'Connection unavailable. Trying to reconnect...',
      'session.sessionStarted': 'CoBrowse Session started',
      'session.sessionEnded': 'CoBrowse Session ended',
      'session.sessionActive': 'CoBrowse session is active',
      'session.standbytext': 'Please wait until the contents of this website have been activated.',
      'session.sessionPaused': 'The session was paused.',
      'session.sessionUnpaused': 'The session was restarted.',
      'session.loading': 'Loading',
      'session.wait': 'Please wait',
      'session.unlock': 'Unlock',
      'session.lock': 'Lock',
      'session.invite': 'Send Invitation',
      'session.copyLink': 'Simply copy & paste the link below to invite participants via your preferred instant messaging client.',
      'session.invitationDialogHeader': 'Invite Participants',
      'session.end': 'End Session',
      'session.loginFailed': 'Invalid username or wrong password',
      'session.incorrectCaptcha': 'Incorrect captcha!',
      'session.incorrectLogin': 'Login failed!',
      'session.captchaHelp': 'To verify that you are a human, please enter the words you see in the box below, in order and separataed by a space. Further <a href=\'javascript:Recaptcha.showhelp()\'>help</a>.',
      'session.accountLocked': 'The account is locked!',
      'session.missingUsername': 'Please enter a username!',
      'session.emailSent': 'The e-mail was sent to the specified user.',
      'session.nonEqualPasswords': 'The passwords must be equal!',
      'session.passwordChangeRequired': 'A password change is required!',
      'session.passwordNotDifferent': 'The new password must differ from the previous password!',
      'session.invalidToken': 'Invalid Token! Possible reasons are: The token was already used, is too old or was modified.',
      'session.insecurePassword': 'The password is not long enough!',
      'session.resetPasswordSuccess': 'Password successfully changed.',
      'session.resetPasswordFail': 'Failed to reset password! Possible reasons: Username does not exist or the new password is insufficiently long.',
      'session.confirmSynchExitMessage': 'Do you really want to exit the current session?',
      'session.confirm': 'Confirm',
      'session.invitationEmailMessage': 'Invite participants via Email.',
      'session.emailMessage': 'Message (optional)',
      'session.emailYourName': 'Your Name',
      'session.emailReceiptName': 'Recipient Name',
      'session.emailReceiptMail': 'Recipient Email',
      'session.sendEmailButton': 'Send Email',
      'session.socialNetworkMessage': 'Invite participants via Twitter, Facebook or Google+.',
      'session.socialNetworkInfo': 'If you are currenty not logged into the correspondent service, the login window for the service will pop-up and you are prompted to enter your username and password.',
      'session.logoContextMessage': 'Customer Service 2.0',
      'session.refreshButtonContextMessage': 'Re-synchronize current page',
      'session.urlPlaceHolder': 'Enter the Address here',
      'session.backButtonContextMessage': 'Go Back',
      'session.forwardButtonContextMessage': 'Go Forward',
      'session.exitSynchContextMessage': 'Exit CoBrowsing session',
      'session.pauseSessionContextMessage': 'Pause or restart the CoBrowsing session',
      'session.agentMenuContextMessage': 'Change personal settings',
      'session.invitationItemContextMessage': 'Share this CoBrowsing session with other people',
      'session.usersInfoContextMessage': 'Number of participants in this session',
      'session.lockButtonContextMessage': 'Lock the session (Nobody can join)',
      'session.lockButtonText': 'Session Unlocked',
      'session.toggleSessionStateContextMessage': 'Changing session state...',
      'session.toggleSessionStateText': 'Working...',
      'session.unlockButtonContextMessage': 'Unlock the session (Anyone can join)',
      'session.unlockButtonText': 'Session Locked',
      'session.linkLabel': 'Session Link',
      'session.emailLabel': 'Email',
      'session.socialnetworksLabel': 'Social Networks',
      'session.SEND_MAIL_ERROR': 'We\'re sorry. Something went wrong while sending your email.',
      'session.ERROR': 'Error',
      'session.SEND_MAIL_SUCCESS': 'Email sent.',
      'session.SUCCESS': 'Success',
      'session.USERS_ONLINE': 'Users Online',
      'session.CHANGE_POINTER': 'Change Pointer',
      'session.SESSION_IS_PAUSED': 'Please wait. The session is currently paused.',
      'session.FEEDBACK_SUCCESS': 'Your feedback has been sent successfully.',
      'session.FEEDBACK_FAIL': 'Failed to sent your feedback.',
      'session.SEND_FEEDBACK_LINK': 'Send Feedback',
      'session.SEND_FEEDBACK_LINK_TITLE': 'Send feedback, report problems or issues.',
      'session.UPLOAD_FILE_LINK': 'Upload File',
      'session.UPLOAD_FILE_LINK_TITLE': 'Upload a image or PDF which should be shared with other participants.',
      'session.SEND_FEEDBACK_TITLE': 'Report a Problem',
      'session.SEND_FEEDBACK_DESCRIPTION_TITLE': 'Problem Description',
      'session.SEND_FEEDBACK_DESCRIPTION_PLACEHOLDER': 'Please enter your problem description here. The description should describe the steps to reproduce the problem.',
      'session.SEND_FEEDBACK_DESCRIPTION_HINT': 'If you\'re reporting a problem, a good description should provide answers to the following questions:<p><ol><li>What were you doing when the problem occurred?</li><li>What did you expect to happen?</li><li>What did happen instead?</li></ol></p>',
      'session.FEEDBACK_INCLUDE_SCREENSHOT': 'Include Screenshot',
      'session.FEEDBACK_SCREENSHOT_PREVIEW': 'Screenshot Preview',
      'session.FEEDBACK_NO_IMAGE': 'No Image',
      'session.GENERATE_SCREENSHOT': 'Generating Screenshot...',
      'session.NO_SCREENSHOT_SUPPORT': 'Screenshot generation is not supported by your browser!',
      'session.IS_TYPING': 'is typing...',
      'session.csatMessage': 'Please rate this CoBrowse session',
      'session.csatAnswerFeedback': 'Thank you for communicating with us',
      'session.csatDisclaimer': 'Your feedback helps us serve you better. It will not be shared with any customer service representative.',
      'session.browserNotSupported': 'Your browser is not supported.',
      'session.remoteConsumerBrowserNotSupported': 'The consumer\'s browser is not supported.',
      'session.agentDisconnected': 'The agent was disconnected.',
      'session.visitorDeniedAccess': 'The visitor did not allow access to the camera/microphone or has no camera/microphone connected',
      'session.remoteAgentProblemJoining': 'Your agent was unable to join the call.',
      'session.clickHereToStart': 'Click here to start',
      'session.unableToGetCameraAccess': 'Unable to access your camera/microphone.',
      'session.unableToGetCameraAccessWithTip': 'Unable to access your camera/microphone. If you wish to participate in this call, please allow access to the camera and microphone in your browser and reload the page.',
      'session.unableToConnect': 'Unable to connect to Agent.',
      'session.callDropped': 'Call ended. Could not reconnect.',
      'session.callHasEnded': 'The call you are trying to join has ended.',
      'session.generalCallInitializationError': 'Could not join call.',
      'session.joinedCallFromAnotherBrowser': 'You joined the call from another browser. Refresh to rejoin.',
      'session.disconnected': 'Disconnected'
    });
  }(i18next_loader));
  dojo_has = function (require, module) {
    // module:
    //		dojo/has
    // summary:
    //		Defines the has.js API and several feature tests used by dojo.
    // description:
    //		This module defines the has API as described by the project has.js with the following additional features:
    //
    //		- the has test cache is exposed at has.cache.
    //		- the method has.add includes a forth parameter that controls whether or not existing tests are replaced
    //		- the loader's has cache may be optionally copied into this module's has cahce.
    //
    //		This module adopted from https://github.com/phiggins42/has.js; thanks has.js team!
    // try to pull the has implementation from the loader; both the dojo loader and bdLoad provide one
    // if using a foreign loader, then the has cache may be initialized via the config object for this module
    // WARNING: if a foreign loader defines require.has to be something other than the has.js API, then this implementation fail
    var has = require.has || function () {
    };
    if (!false) {
      var isBrowser = // the most fundamental decision: are we in the browser?
        typeof window != 'undefined' && typeof location != 'undefined' && typeof document != 'undefined' && window.location == location && window.document == document,
        // has API variables
        global = function () {
          return this;
        }(), doc = isBrowser && document, element = doc && doc.createElement('DiV'), cache = module.config && module.config() || {};
      has = function (name) {
        // summary:
        //		Return the current value of the named feature.
        //
        // name: String|Integer
        //		The name (if a string) or identifier (if an integer) of the feature to test.
        //
        // description:
        //		Returns the value of the feature named by name. The feature must have been
        //		previously added to the cache by has.add.
        return typeof cache[name] == 'function' ? cache[name] = cache[name](global, doc, element) : cache[name];  // Boolean
      };
      has.cache = cache;
      has.add = function (name, test, now, force) {
        // summary:
        //	 	Register a new feature test for some named feature.
        // name: String|Integer
        //	 	The name (if a string) or identifier (if an integer) of the feature to test.
        // test: Function
        //		 A test function to register. If a function, queued for testing until actually
        //		 needed. The test function should return a boolean indicating
        //	 	the presence of a feature or bug.
        // now: Boolean?
        //		 Optional. Omit if `test` is not a function. Provides a way to immediately
        //		 run the test and cache the result.
        // force: Boolean?
        //	 	Optional. If the test already exists and force is truthy, then the existing
        //	 	test will be replaced; otherwise, add does not replace an existing test (that
        //	 	is, by default, the first test advice wins).
        // example:
        //		A redundant test, testFn with immediate execution:
        //	|	has.add("javascript", function(){ return true; }, true);
        //
        // example:
        //		Again with the redundantness. You can do this in your tests, but we should
        //		not be doing this in any internal has.js tests
        //	|	has.add("javascript", true);
        //
        // example:
        //		Three things are passed to the testFunction. `global`, `document`, and a generic element
        //		from which to work your test should the need arise.
        //	|	has.add("bug-byid", function(g, d, el){
        //	|		// g	== global, typically window, yadda yadda
        //	|		// d	== document object
        //	|		// el == the generic element. a `has` element.
        //	|		return false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer
        //	|	});
        (typeof cache[name] == 'undefined' || force) && (cache[name] = test);
        return now && has(name);
      };
      // since we're operating under a loader that doesn't provide a has API, we must explicitly initialize
      // has as it would have otherwise been initialized by the dojo loader; use has.add to the builder
      // can optimize these away iff desired
      has.add('host-browser', isBrowser);
      has.add('host-node', typeof process == 'object' && process.versions && process.versions.node && process.versions.v8);
      has.add('host-rhino', typeof load == 'function' && (typeof Packages == 'function' || typeof Packages == 'object'));
      has.add('dom', isBrowser);
      has.add('dojo-dom-ready-api', 1);
      has.add('dojo-sniff', 1);
    }
    if (has('host-browser')) {
      // Common application level tests
      has.add('dom-addeventlistener', !!document.addEventListener);
      // Do the device and browser have touch capability?
      has.add('touch', 'ontouchstart' in document || 'onpointerdown' in document && navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints);
      // Touch events support
      has.add('touch-events', 'ontouchstart' in document);
      // Pointer Events support
      has.add('pointer-events', 'onpointerdown' in document && navigator.userAgent.toLowerCase().indexOf('firefox') === -1);
      // PATCHED Firefox does not fully support pointer events, e.g. CTRL + touch (click) does not work
      has.add('MSPointer', 'msMaxTouchPoints' in navigator);
      //IE10 (+IE11 preview)
      // I don't know if any of these tests are really correct, just a rough guess
      has.add('device-width', screen.availWidth || innerWidth);
      // Tests for DOMNode.attributes[] behavior:
      //	 - dom-attributes-explicit - attributes[] only lists explicitly user specified attributes
      //	 - dom-attributes-specified-flag (IE8) - need to check attr.specified flag to skip attributes user didn't specify
      //	 - Otherwise, in IE6-7. attributes[] will list hundreds of values, so need to do outerHTML to get attrs instead.
      var form = document.createElement('form');
      has.add('dom-attributes-explicit', form.attributes.length == 0);
      // W3C
      has.add('dom-attributes-specified-flag', form.attributes.length > 0 && form.attributes.length < 40);  // IE8
    }
    has.clearElement = function (element) {
      // summary:
      //	 Deletes the contents of the element passed to test functions.
      element.innerHTML = '';
      return element;
    };
    has.normalize = function (id, toAbsMid) {
      // summary:
      //	 Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).
      //
      // toAbsMid: Function
      //	 Resolves a relative module id into an absolute module id
      var tokens = id.match(/[\?:]|[^:\?]*/g), i = 0, get = function (skip) {
          var term = tokens[i++];
          if (term == ':') {
            // empty string module name, resolves to 0
            return 0;
          } else {
            // postfixed with a ? means it is a feature to branch on, the term is the name of the feature
            if (tokens[i++] == '?') {
              if (!skip && has(term)) {
                // matched the feature, get the first value from the options
                return get();
              } else {
                // did not match, get the second value, passing over the first
                get(true);
                return get(skip);
              }
            }
            // a module
            return term || 0;
          }
        };
      id = get();
      return id && toAbsMid(id);
    };
    has.load = function (id, parentRequire, loaded) {
      // summary:
      //		Conditional loading of AMD modules based on a has feature test value.
      // id: String
      //		Gives the resolved module id to load.
      // parentRequire: Function
      //		The loader require function with respect to the module that contained the plugin resource in it's
      //		dependency list.
      // loaded: Function
      //	 Callback to loader that consumes result of plugin demand.
      if (id) {
        parentRequire([id], loaded);
      } else {
        loaded();
      }
    };
    return has;
  }({}, {});
  dojo_sniff = function (has) {
    // module:
    //		dojo/sniff
    /*=====
    	return function(){
    		// summary:
    		//		This module sets has() flags based on the current browser.
    		//		It returns the has() function.
    	};
    	=====*/
    if (has('host-browser')) {
      var n = navigator, dua = n.userAgent, dav = n.appVersion, tv = parseFloat(dav);
      has.add('air', dua.indexOf('AdobeAIR') >= 0);
      has.add('msapp', parseFloat(dua.split('MSAppHost/')[1]) || undefined);
      has.add('khtml', dav.indexOf('Konqueror') >= 0 ? tv : undefined);
      has.add('webkit', parseFloat(dua.split('WebKit/')[1]) || undefined);
      has.add('chrome', parseFloat(dua.split('Chrome/')[1]) || undefined);
      has.add('safari', dav.indexOf('Safari') >= 0 && !has('chrome') ? parseFloat(dav.split('Version/')[1]) : undefined);
      has.add('mac', dav.indexOf('Macintosh') >= 0);
      has.add('quirks', document.compatMode == 'BackCompat');
      if (dua.match(/(iPhone|iPod|iPad)/)) {
        var p = RegExp.$1.replace(/P/, 'p');
        var v = dua.match(/OS ([\d_]+)/) ? RegExp.$1 : '1';
        var os = parseFloat(v.replace(/_/, '.').replace(/_/g, ''));
        has.add(p, os);
        // "iphone", "ipad" or "ipod"
        has.add('ios', os);
      }
      has.add('android', parseFloat(dua.split('Android ')[1]) || undefined);
      has.add('bb', (dua.indexOf('BlackBerry') >= 0 || dua.indexOf('BB10') >= 0) && parseFloat(dua.split('Version/')[1]) || undefined);
      has.add('trident', parseFloat(dav.split('Trident/')[1]) || undefined);
      has.add('svg', typeof SVGAngle !== 'undefined');
      if (!has('webkit')) {
        // Opera
        if (dua.indexOf('Opera') >= 0) {
          // see http://dev.opera.com/articles/view/opera-ua-string-changes and http://www.useragentstring.com/pages/Opera/
          // 9.8 has both styles; <9.8, 9.9 only old style
          has.add('opera', tv >= 9.8 ? parseFloat(dua.split('Version/')[1]) || tv : tv);
        }
        // Mozilla and firefox
        if (dua.indexOf('Gecko') >= 0 && !has('khtml') && !has('webkit') && !has('trident')) {
          has.add('mozilla', tv);
        }
        if (has('mozilla')) {
          //We really need to get away from this. Consider a sane isGecko approach for the future.
          has.add('ff', parseFloat(dua.split('Firefox/')[1] || dua.split('Minefield/')[1]) || undefined);
        }
        // IE
        if (document.all && !has('opera')) {
          var isIE = parseFloat(dav.split('MSIE ')[1]) || undefined;
          //In cases where the page has an HTTP header or META tag with
          //X-UA-Compatible, then it is in emulation mode.
          //Make sure isIE reflects the desired version.
          //document.documentMode of 5 means quirks mode.
          //Only switch the value if documentMode's major version
          //is different from isIE's major version.
          var mode = document.documentMode;
          if (mode && mode != 5 && Math.floor(isIE) != mode) {
            isIE = mode;
          }
          has.add('ie', isIE);
        }
        // Wii
        has.add('wii', typeof opera != 'undefined' && opera.wiiremote);
      }
    }
    return has;
  }(dojo_has);
  dojo__base_config = function (has, require) {
    // module:
    //		dojo/_base/config
    /*=====
    return {
    	// summary:
    	//		This module defines the user configuration during bootstrap.
    	// description:
    	//		By defining user configuration as a module value, an entire configuration can be specified in a build,
    	//		thereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.
    	//		Also, when multiple instances of dojo exist in a single application, each will necessarily be located
    	//		at an unique absolute module identifier as given by the package configuration. Implementing configuration
    	//		as a module allows for specifying unique, per-instance configurations.
    	// example:
    	//		Create a second instance of dojo with a different, instance-unique configuration (assume the loader and
    	//		dojo.js are already loaded).
    	//		|	// specify a configuration that creates a new instance of dojo at the absolute module identifier "myDojo"
    	//		|;
    	//		|
    	//		|	// specify a configuration for the myDojo instance
    	//		|	define("myDojo/config", {
    	//		|		// normal configuration variables go here, e.g.,
    	//		|		locale:"fr-ca"
    	//		|	});
    	//		|
    	//		|	// load and use the new instance of dojo
    	//		|	require(["myDojo"], function(dojo){
    	//		|		// dojo is the new instance of dojo
    	//		|		// use as required
    	//		|	});
    
    	// isDebug: Boolean
    	//		Defaults to `false`. If set to `true`, ensures that Dojo provides
    	//		extended debugging feedback via Firebug. If Firebug is not available
    	//		on your platform, setting `isDebug` to `true` will force Dojo to
    	//		pull in (and display) the version of Firebug Lite which is
    	//		integrated into the Dojo distribution, thereby always providing a
    	//		debugging/logging console when `isDebug` is enabled. Note that
    	//		Firebug's `console.*` methods are ALWAYS defined by Dojo. If
    	//		`isDebug` is false and you are on a platform without Firebug, these
    	//		methods will be defined as no-ops.
    	isDebug: false,
    
    	// locale: String
    	//		The locale to assume for loading localized resources in this page,
    	//		specified according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
    	//		Must be specified entirely in lowercase, e.g. `en-us` and `zh-cn`.
    	//		See the documentation for `dojo.i18n` and `dojo.requireLocalization`
    	//		for details on loading localized resources. If no locale is specified,
    	//		Dojo assumes the locale of the user agent, according to `navigator.userLanguage`
    	//		or `navigator.language` properties.
    	locale: undefined,
    
    	// extraLocale: Array
    	//		No default value. Specifies additional locales whose
    	//		resources should also be loaded alongside the default locale when
    	//		calls to `dojo.requireLocalization()` are processed.
    	extraLocale: undefined,
    
    	// baseUrl: String
    	//		The directory in which `dojo.js` is located. Under normal
    	//		conditions, Dojo auto-detects the correct location from which it
    	//		was loaded. You may need to manually configure `baseUrl` in cases
    	//		where you have renamed `dojo.js` or in which `<base>` tags confuse
    	//		some browsers (e.g. IE 6). The variable `dojo.baseUrl` is assigned
    	//		either the value of `djConfig.baseUrl` if one is provided or the
    	//		auto-detected root if not. Other modules are located relative to
    	//		this path. The path should end in a slash.
    	baseUrl: undefined,
    
    	// modulePaths: [deprecated] Object
    	//		A map of module names to paths relative to `dojo.baseUrl`. The
    	//		key/value pairs correspond directly to the arguments which
    	//		`dojo.registerModulePath` accepts. Specifying
    	//		`djConfig.modulePaths = { "foo": "../../bar" }` is the equivalent
    	//		of calling `dojo.registerModulePath("foo", "../../bar");`. Multiple
    	//		modules may be configured via `djConfig.modulePaths`.
    	modulePaths: {},
    
    	// addOnLoad: Function|Array
    	//		Adds a callback via dojo/ready. Useful when Dojo is added after
    	//		the page loads and djConfig.afterOnLoad is true. Supports the same
    	//		arguments as dojo/ready. When using a function reference, use
    	//		`djConfig.addOnLoad = function(){};`. For object with function name use
    	//		`djConfig.addOnLoad = [myObject, "functionName"];` and for object with
    	//		function reference use
    	//		`djConfig.addOnLoad = [myObject, function(){}];`
    	addOnLoad: null,
    
    	// parseOnLoad: Boolean
    	//		Run the parser after the page is loaded
    	parseOnLoad: false,
    
    	// require: String[]
    	//		An array of module names to be loaded immediately after dojo.js has been included
    	//		in a page.
    	require: [],
    
    	// defaultDuration: Number
    	//		Default duration, in milliseconds, for wipe and fade animations within dijits.
    	//		Assigned to dijit.defaultDuration.
    	defaultDuration: 200,
    
    	// dojoBlankHtmlUrl: String
    	//		Used by some modules to configure an empty iframe. Used by dojo/io/iframe and
    	//		dojo/back, and dijit/popup support in IE where an iframe is needed to make sure native
    	//		controls do not bleed through the popups. Normally this configuration variable
    	//		does not need to be set, except when using cross-domain/CDN Dojo builds.
    	//		Save dojo/resources/blank.html to your domain and set `djConfig.dojoBlankHtmlUrl`
    	//		to the path on your domain your copy of blank.html.
    	dojoBlankHtmlUrl: undefined,
    
    	// ioPublish: Boolean?
    	//		Set this to true to enable publishing of topics for the different phases of
    	//		IO operations. Publishing is done via dojo/topic.publish(). See dojo/main.__IoPublish for a list
    	//		of topics that are published.
    	ioPublish: false,
    
    	// useCustomLogger: Anything?
    	//		If set to a value that evaluates to true such as a string or array and
    	//		isDebug is true and Firebug is not available or running, then it bypasses
    	//		the creation of Firebug Lite allowing you to define your own console object.
    	useCustomLogger: undefined,
    
    	// transparentColor: Array
    	//		Array containing the r, g, b components used as transparent color in dojo.Color;
    	//		if undefined, [255,255,255] (white) will be used.
    	transparentColor: undefined,
    
    	// deps: Function|Array
    	//		Defines dependencies to be used before the loader has been loaded.
    	//		When provided, they cause the loader to execute require(deps, callback)
    	//		once it has finished loading. Should be used with callback.
    	deps: undefined,
    
    	// callback: Function|Array
    	//		Defines a callback to be used when dependencies are defined before
    	//		the loader has been loaded. When provided, they cause the loader to
    	//		execute require(deps, callback) once it has finished loading.
    	//		Should be used with deps.
    	callback: undefined,
    
    	// deferredInstrumentation: Boolean
    	//		Whether deferred instrumentation should be loaded or included
    	//		in builds.
    	deferredInstrumentation: true,
    
    	// useDeferredInstrumentation: Boolean|String
    	//		Whether the deferred instrumentation should be used.
    	//
    	//		* `"report-rejections"`: report each rejection as it occurs.
    	//		* `true` or `1` or `"report-unhandled-rejections"`: wait 1 second
    	//			in an attempt to detect unhandled rejections.
    	useDeferredInstrumentation: "report-unhandled-rejections"
    };
    =====*/
    var result = {};
    if (has('dojo-config-api')) {
      // must be the dojo loader; take a shallow copy of require.rawConfig
      var src = require.rawConfig, p;
      for (p in src) {
        result[p] = src[p];
      }
    } else {
      var adviseHas = function (featureSet, prefix, booting) {
        for (p in featureSet) {
          p != 'has' && has.add(prefix + p, featureSet[p], 0, booting);
        }
      };
      var global = function () {
        return this;
      }();
      result = has('dojo-loader') ? // must be a built version of the dojo loader; all config stuffed in require.rawConfig
      require.rawConfig : // a foreign loader
      global.synchroniteConfig || global.dojoConfig || global.djConfig || {};
      // PATCHED until we can discard dojo config entirely
      adviseHas(result, 'config', 1);
      adviseHas(result.has, '', 1);
    }
    if (!result.locale && typeof navigator != 'undefined') {
      // Default locale for browsers.
      var language = navigator.language || navigator.userLanguage;
      if (language) {
        result.locale = language.toLowerCase();
      }
    }
    return result;
  }(dojo_has, {});
  dojo__base_kernel = function (has, config, require, module) {
    // module:
    //		dojo/_base/kernel
    // This module is the foundational module of the dojo boot sequence; it defines the dojo object.
    var
      // loop variables for this module
      i, p,
      // create dojo, dijit, and dojox
      // FIXME: in 2.0 remove dijit, dojox being created by dojo
      global = function () {
        return this;
      }(), dijit = {}, dojox = {}, dojo = {
        // summary:
        //		This module is the foundational module of the dojo boot sequence; it defines the dojo object.
        // notice dojo takes ownership of the value of the config module
        config: config,
        global: global,
        dijit: dijit,
        dojox: dojox
      };
    // Configure the scope map. For a 100% AMD application, the scope map is not needed other than to provide
    // a _scopeName property for the dojo, dijit, and dojox root object so those packages can create
    // unique names in the global space.
    //
    // Built, legacy modules use the scope map to allow those modules to be expressed as if dojo, dijit, and dojox,
    // where global when in fact they are either global under different names or not global at all. In v1.6-, the
    // config variable "scopeMap" was used to map names as used within a module to global names. This has been
    // subsumed by the AMD map configuration variable which can relocate packages to different names. For backcompat,
    // only the "*" mapping is supported. See http://livedocs.dojotoolkit.org/developer/design/loader#legacy-cross-domain-mode for details.
    //
    // The following computations contort the packageMap for this dojo instance into a scopeMap.
    var scopeMap = // a map from a name used in a legacy module to the (global variable name, object addressed by that name)
      // always map dojo, dijit, and dojox
      {
        dojo: [
          'dojo',
          dojo
        ],
        dijit: [
          'dijit',
          dijit
        ],
        dojox: [
          'dojox',
          dojox
        ]
      }, packageMap = require.map && require.map[module.id.match(/[^\/]+/)[0]], item;
    // process all mapped top-level names for this instance of dojo
    for (p in packageMap) {
      if (scopeMap[p]) {
        // mapped dojo, dijit, or dojox
        scopeMap[p][0] = packageMap[p];
      } else {
        // some other top-level name
        scopeMap[p] = [
          packageMap[p],
          {}
        ];
      }
    }
    // publish those names to _scopeName and, optionally, the global namespace
    for (p in scopeMap) {
      item = scopeMap[p];
      item[1]._scopeName = item[0];
      if (!config.noGlobals) {
        global[item[0]] = item[1];
      }
    }
    dojo.scopeMap = scopeMap;
    /*===== dojo.__docParserConfigureScopeMap(scopeMap); =====*/
    // FIXME: dojo.baseUrl and dojo.config.baseUrl should be deprecated
    dojo.baseUrl = dojo.config.baseUrl = require.baseUrl;
    dojo.isAsync = !has('dojo-loader') || require.async;
    dojo.locale = config.locale;
    var rev = '$Rev: ae6be82 $'.match(/[0-9a-f]{7,}/);
    dojo.version = {
      // summary:
      //		Version number of the Dojo Toolkit
      // description:
      //		Hash about the version, including
      //
      //		- major: Integer: Major version. If total version is "1.2.0beta1", will be 1
      //		- minor: Integer: Minor version. If total version is "1.2.0beta1", will be 2
      //		- patch: Integer: Patch version. If total version is "1.2.0beta1", will be 0
      //		- flag: String: Descriptor flag. If total version is "1.2.0beta1", will be "beta1"
      //		- revision: Number: The Git rev from which dojo was pulled
      major: 1,
      minor: 10,
      patch: 3,
      flag: '',
      revision: rev ? rev[0] : NaN,
      toString: function () {
        var v = dojo.version;
        return v.major + '.' + v.minor + '.' + v.patch + v.flag + ' (' + v.revision + ')';  // String
      }
    };
    // If has("extend-dojo") is truthy, then as a dojo module is defined it should push it's definitions
    // into the dojo object, and conversely. In 2.0, it will likely be unusual to augment another object
    // as a result of defining a module. This has feature gives a way to force 2.0 behavior as the code
    // is migrated. Absent specific advice otherwise, set extend-dojo to truthy.
    has.add('extend-dojo', 1);
    // PATCHED (Function("d", "d.eval = function(){return d.global.eval ? d.global.eval(arguments[0]) : eval(arguments[0]);}"))(dojo);
    /*=====
    	dojo.eval = function(scriptText){
    		// summary:
    		//		A legacy method created for use exclusively by internal Dojo methods. Do not use this method
    		//		directly unless you understand its possibly-different implications on the platforms your are targeting.
    		// description:
    		//		Makes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers
    		//		that support indirect eval.
    		//
    		//		As usual, IE does not. On IE, the only way to implement global eval is to
    		//		use execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.
    		//		This implementation uses the technique of executing eval in the scope of a function that is a single scope
    		//		frame below the global scope; thereby coming close to the global scope. Note carefully that
    		//
    		//		dojo.eval("var pi = 3.14;");
    		//
    		//		will define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want
    		//		to define a global variable using dojo.eval, write something like
    		//
    		//		dojo.eval("window.pi = 3.14;")
    		// scriptText:
    		//		The text to evaluation.
    		// returns:
    		//		The result of the evaluation. Often `undefined`
    	};
    	=====*/
    if (false) {
      dojo.exit = function (exitcode) {
        quit(exitcode);
      };
    } else {
      dojo.exit = function () {
      };
    }
    has.add('dojo-guarantee-console', // ensure that console.log, console.warn, etc. are defined
    1);
    if (has('dojo-guarantee-console')) {
      typeof console != 'undefined' || (console = {});
      //	Be careful to leave 'log' always at the end
      var cn = [
        'assert',
        'count',
        'debug',
        'dir',
        'dirxml',
        'error',
        'group',
        'groupEnd',
        'info',
        'profile',
        'profileEnd',
        'time',
        'timeEnd',
        'trace',
        'warn',
        'log'
      ];
      var tn;
      i = 0;
      while (tn = cn[i++]) {
        if (!console[tn]) {
          (function () {
            var tcn = tn + '';
            console[tcn] = 'log' in console ? function () {
              var a = Array.prototype.slice.call(arguments);
              a.unshift(tcn + ':');
              console['log'](a.join(' '));
            } : function () {
            };
            console[tcn]._fake = true;
          }());
        }
      }
    }
    has.add('dojo-debug-messages', // include dojo.deprecated/dojo.experimental implementations
    !!config.isDebug);
    dojo.deprecated = dojo.experimental = function () {
    };
    if (false) {
      dojo.deprecated = function (behaviour, extra, removal) {
        // summary:
        //		Log a debug message to indicate that a behavior has been
        //		deprecated.
        // behaviour: String
        //		The API or behavior being deprecated. Usually in the form
        //		of "myApp.someFunction()".
        // extra: String?
        //		Text to append to the message. Often provides advice on a
        //		new function or facility to achieve the same goal during
        //		the deprecation period.
        // removal: String?
        //		Text to indicate when in the future the behavior will be
        //		removed. Usually a version number.
        // example:
        //	| dojo.deprecated("myApp.getTemp()", "use myApp.getLocaleTemp() instead", "1.0");
        var message = 'DEPRECATED: ' + behaviour;
        if (extra) {
          message += ' ' + extra;
        }
        if (removal) {
          message += ' -- will be removed in version: ' + removal;
        }
        console.warn(message);
      };
      dojo.experimental = function (moduleName, extra) {
        // summary:
        //		Marks code as experimental.
        // description:
        //		This can be used to mark a function, file, or module as
        //		experimental.	 Experimental code is not ready to be used, and the
        //		APIs are subject to change without notice.	Experimental code may be
        //		completed deleted without going through the normal deprecation
        //		process.
        // moduleName: String
        //		The name of a module, or the name of a module file or a specific
        //		function
        // extra: String?
        //		some additional message for the user
        // example:
        //	| dojo.experimental("dojo.data.Result");
        // example:
        //	| dojo.experimental("dojo.weather.toKelvin()", "PENDING approval from NOAA");
        var message = 'EXPERIMENTAL: ' + moduleName + ' -- APIs subject to change without notice.';
        if (extra) {
          message += ' ' + extra;
        }
        console.warn(message);
      };
    }
    has.add('dojo-modulePaths', // consume dojo.modulePaths processing
    1);
    if (false) {
      // notice that modulePaths won't be applied to any require's before the dojo/_base/kernel factory is run;
      // this is the v1.6- behavior.
      if (config.modulePaths) {
        dojo.deprecated('dojo.modulePaths', 'use paths configuration');
        var paths = {};
        for (p in config.modulePaths) {
          paths[p.replace(/\./g, '/')] = config.modulePaths[p];
        }
      }
    }
    has.add('dojo-moduleUrl', // include dojo.moduleUrl
    1);
    if (false) {
      dojo.moduleUrl = function (module, url) {
        // summary:
        //		Returns a URL relative to a module.
        // example:
        //	|	var pngPath = dojo.moduleUrl("acme","images/small.png");
        //	|	console.dir(pngPath); // list the object properties
        //	|	// create an image and set it's source to pngPath's value:
        //	|	var img = document.createElement("img");
        //	|	img.src = pngPath;
        //	|	// add our image to the document
        //	|	dojo.body().appendChild(img);
        // example:
        //		you may de-reference as far as you like down the package
        //		hierarchy.  This is sometimes handy to avoid lengthy relative
        //		urls or for building portable sub-packages. In this example,
        //		the `acme.widget` and `acme.util` directories may be located
        //		under different roots (see `dojo.registerModulePath`) but the
        //		the modules which reference them can be unaware of their
        //		relative locations on the filesystem:
        //	|	// somewhere in a configuration block
        //	|	dojo.registerModulePath("acme.widget", "../../acme/widget");
        //	|	dojo.registerModulePath("acme.util", "../../util");
        //	|
        //	|	// ...
        //	|
        //	|	// code in a module using acme resources
        //	|	var tmpltPath = dojo.moduleUrl("acme.widget","templates/template.html");
        //	|	var dataPath = dojo.moduleUrl("acme.util","resources/data.json");
        dojo.deprecated('dojo.moduleUrl()', 'use require.toUrl', '2.0');
        // require.toUrl requires a filetype; therefore, just append the suffix "/*.*" to guarantee a filetype, then
        // remove the suffix from the result. This way clients can request a url w/out a filetype. This should be
        // rare, but it maintains backcompat for the v1.x line (note: dojo.moduleUrl will be removed in v2.0).
        // Notice * is an illegal filename so it won't conflict with any real path map that may exist the paths config.
        var result = null;
        if (module) {
          result = require.toUrl(module.replace(/\./g, '/') + (url ? '/' + url : '') + '/*.*').replace(/\/\*\.\*/, '') + (url ? '' : '/');
        }
        return result;
      };
    }
    dojo._hasResource = {};
    // for backward compatibility with layers built with 1.6 tooling
    return dojo;
  }(dojo_has, dojo__base_config, {}, {});
  dojo__base_lang = function (dojo, has) {
    // module:
    //		dojo/_base/lang
    has.add('bug-for-in-skips-shadowed', function () {
      // if true, the for-in iterator skips object properties that exist in Object's prototype (IE 6 - ?)
      for (var i in { toString: 1 }) {
        return 0;
      }
      return 1;
    });
    // Helper methods
    var _extraNames = has('bug-for-in-skips-shadowed') ? 'hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor'.split('.') : [], _extraLen = _extraNames.length, getProp = function (parts, create, context) {
        if (!context) {
          if (parts[0] && dojo.scopeMap[parts[0]]) {
            // Voodoo code from the old days where "dojo" or "dijit" maps to some special object
            // rather than just window.dojo
            context = dojo.scopeMap[parts.shift()][1];
          } else {
            context = dojo.global;
          }
        }
        try {
          for (var i = 0; i < parts.length; i++) {
            var p = parts[i];
            if (!(p in context)) {
              if (create) {
                context[p] = {};
              } else {
                return;  // return undefined
              }
            }
            context = context[p];
          }
          return context;  // mixed
        } catch (e) {
        }
      }, opts = Object.prototype.toString, efficient = function (obj, offset, startWith) {
        return (startWith || []).concat(Array.prototype.slice.call(obj, offset || 0));
      }, _pattern = /\{([^\}]+)\}/g;
    // Module export
    var lang = {
      // summary:
      //		This module defines Javascript language extensions.
      // _extraNames: String[]
      //		Lists property names that must be explicitly processed during for-in iteration
      //		in environments that have has("bug-for-in-skips-shadowed") true.
      _extraNames: _extraNames,
      _mixin: function (dest, source, copyFunc) {
        // summary:
        //		Copies/adds all properties of source to dest; returns dest.
        // dest: Object
        //		The object to which to copy/add all properties contained in source.
        // source: Object
        //		The object from which to draw all properties to copy into dest.
        // copyFunc: Function?
        //		The process used to copy/add a property in source; defaults to the Javascript assignment operator.
        // returns:
        //		dest, as modified
        // description:
        //		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
        //		found in Object.prototype, are copied/added to dest. Copying/adding each particular property is
        //		delegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.
        //		Notice that by default, _mixin executes a so-called "shallow copy" and aggregate types are copied/added by reference.
        var name, s, i, empty = {};
        for (name in source) {
          // the (!(name in empty) || empty[name] !== s) condition avoids copying properties in "source"
          // inherited from Object.prototype.	 For example, if dest has a custom toString() method,
          // don't overwrite it with the toString() method that source inherited from Object.prototype
          s = source[name];
          if (!(name in dest) || dest[name] !== s && (!(name in empty) || empty[name] !== s)) {
            dest[name] = copyFunc ? copyFunc(s) : s;
          }
        }
        if (has('bug-for-in-skips-shadowed')) {
          if (source) {
            for (i = 0; i < _extraLen; ++i) {
              name = _extraNames[i];
              s = source[name];
              if (!(name in dest) || dest[name] !== s && (!(name in empty) || empty[name] !== s)) {
                dest[name] = copyFunc ? copyFunc(s) : s;
              }
            }
          }
        }
        return dest;  // Object
      },
      mixin: function (dest, sources) {
        // summary:
        //		Copies/adds all properties of one or more sources to dest; returns dest.
        // dest: Object
        //		The object to which to copy/add all properties contained in source. If dest is falsy, then
        //		a new object is manufactured before copying/adding properties begins.
        // sources: Object...
        //		One of more objects from which to draw all properties to copy into dest. sources are processed
        //		left-to-right and if more than one of these objects contain the same property name, the right-most
        //		value "wins".
        // returns: Object
        //		dest, as modified
        // description:
        //		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
        //		found in Object.prototype, are copied/added from sources to dest. sources are processed left to right.
        //		The Javascript assignment operator is used to copy/add each property; therefore, by default, mixin
        //		executes a so-called "shallow copy" and aggregate types are copied/added by reference.
        // example:
        //		make a shallow copy of an object
        //	|	var copy = lang.mixin({}, source);
        // example:
        //		many class constructors often take an object which specifies
        //		values to be configured on the object. In this case, it is
        //		often simplest to call `lang.mixin` on the `this` object:
        //	|	declare("acme.Base", null, {
        //	|		constructor: function(properties){
        //	|			// property configuration:
        //	|			lang.mixin(this, properties);
        //	|
        //	|			console.log(this.quip);
        //	|			//	...
        //	|		},
        //	|		quip: "I wasn't born yesterday, you know - I've seen movies.",
        //	|		// ...
        //	|	});
        //	|
        //	|	// create an instance of the class and configure it
        //	|	var b = new acme.Base({quip: "That's what it does!" });
        // example:
        //		copy in properties from multiple objects
        //	|	var flattened = lang.mixin(
        //	|		{
        //	|			name: "Frylock",
        //	|			braces: true
        //	|		},
        //	|		{
        //	|			name: "Carl Brutanananadilewski"
        //	|		}
        //	|	);
        //	|
        //	|	// will print "Carl Brutanananadilewski"
        //	|	console.log(flattened.name);
        //	|	// will print "true"
        //	|	console.log(flattened.braces);
        if (!dest) {
          dest = {};
        }
        for (var i = 1, l = arguments.length; i < l; i++) {
          lang._mixin(dest, arguments[i]);
        }
        return dest;  // Object
      },
      setObject: function (name, value, context) {
        // summary:
        //		Set a property from a dot-separated string, such as "A.B.C"
        // description:
        //		Useful for longer api chains where you have to test each object in
        //		the chain, or when you have an object reference in string format.
        //		Objects are created as needed along `path`. Returns the passed
        //		value if setting is successful or `undefined` if not.
        // name: String
        //		Path to a property, in the form "A.B.C".
        // value: anything
        //		value or object to place at location given by name
        // context: Object?
        //		Optional. Object to use as root of path. Defaults to
        //		`dojo.global`.
        // example:
        //		set the value of `foo.bar.baz`, regardless of whether
        //		intermediate objects already exist:
        //	| lang.setObject("foo.bar.baz", value);
        // example:
        //		without `lang.setObject`, we often see code like this:
        //	| // ensure that intermediate objects are available
        //	| if(!obj["parent"]){ obj.parent = {}; }
        //	| if(!obj.parent["child"]){ obj.parent.child = {}; }
        //	| // now we can safely set the property
        //	| obj.parent.child.prop = "some value";
        //		whereas with `lang.setObject`, we can shorten that to:
        //	| lang.setObject("parent.child.prop", "some value", obj);
        var parts = name.split('.'), p = parts.pop(), obj = getProp(parts, true, context);
        return obj && p ? obj[p] = value : undefined;  // Object
      },
      getObject: function (name, create, context) {
        // summary:
        //		Get a property from a dot-separated string, such as "A.B.C"
        // description:
        //		Useful for longer api chains where you have to test each object in
        //		the chain, or when you have an object reference in string format.
        // name: String
        //		Path to an property, in the form "A.B.C".
        // create: Boolean?
        //		Optional. Defaults to `false`. If `true`, Objects will be
        //		created at any point along the 'path' that is undefined.
        // context: Object?
        //		Optional. Object to use as root of path. Defaults to
        //		'dojo.global'. Null may be passed.
        return getProp(name ? name.split('.') : [], create, context);  // Object
      },
      exists: function (name, obj) {
        // summary:
        //		determine if an object supports a given method
        // description:
        //		useful for longer api chains where you have to test each object in
        //		the chain. Useful for object and method detection.
        // name: String
        //		Path to an object, in the form "A.B.C".
        // obj: Object?
        //		Object to use as root of path. Defaults to
        //		'dojo.global'. Null may be passed.
        // example:
        //	| // define an object
        //	| var foo = {
        //	|		bar: { }
        //	| };
        //	|
        //	| // search the global scope
        //	| lang.exists("foo.bar"); // true
        //	| lang.exists("foo.bar.baz"); // false
        //	|
        //	| // search from a particular scope
        //	| lang.exists("bar", foo); // true
        //	| lang.exists("bar.baz", foo); // false
        return lang.getObject(name, false, obj) !== undefined;  // Boolean
      },
      // Crockford (ish) functions
      isString: function (it) {
        // summary:
        //		Return true if it is a String
        // it: anything
        //		Item to test.
        return typeof it == 'string' || it instanceof String;  // Boolean
      },
      isArray: function (it) {
        // summary:
        //		Return true if it is an Array.
        //		Does not work on Arrays created in other windows.
        // it: anything
        //		Item to test.
        return it && (it instanceof Array || typeof it == 'array');  // Boolean
      },
      isFunction: function (it) {
        // summary:
        //		Return true if it is a Function
        // it: anything
        //		Item to test.
        return opts.call(it) === '[object Function]';
      },
      isObject: function (it) {
        // summary:
        //		Returns true if it is a JavaScript object (or an Array, a Function
        //		or null)
        // it: anything
        //		Item to test.
        return it !== undefined && (it === null || typeof it == 'object' || lang.isArray(it) || lang.isFunction(it));  // Boolean
      },
      isArrayLike: function (it) {
        // summary:
        //		similar to isArray() but more permissive
        // it: anything
        //		Item to test.
        // returns:
        //		If it walks like a duck and quacks like a duck, return `true`
        // description:
        //		Doesn't strongly test for "arrayness".  Instead, settles for "isn't
        //		a string or number and has a length property". Arguments objects
        //		and DOM collections will return true when passed to
        //		isArrayLike(), but will return false when passed to
        //		isArray().
        return it && it !== undefined && // Boolean
        // keep out built-in constructors (Number, String, ...) which have length
        // properties
        !lang.isString(it) && !lang.isFunction(it) && !(it.tagName && it.tagName.toLowerCase() == 'form') && (lang.isArray(it) || isFinite(it.length));
      },
      isAlien: function (it) {
        // summary:
        //		Returns true if it is a built-in function or some other kind of
        //		oddball that *should* report as a function but doesn't
        return it && !lang.isFunction(it) && /\{\s*\[native code\]\s*\}/.test(String(it));  // Boolean
      },
      extend: function (ctor, props) {
        // summary:
        //		Adds all properties and methods of props to constructor's
        //		prototype, making them available to all instances created with
        //		constructor.
        // ctor: Object
        //		Target constructor to extend.
        // props: Object
        //		One or more objects to mix into ctor.prototype
        for (var i = 1, l = arguments.length; i < l; i++) {
          lang._mixin(ctor.prototype, arguments[i]);
        }
        return ctor;  // Object
      },
      _hitchArgs: function (scope, method) {
        var pre = lang._toArray(arguments, 2);
        var named = lang.isString(method);
        return function () {
          // arrayify arguments
          var args = lang._toArray(arguments);
          // locate our method
          var f = named ? (scope || dojo.global)[method] : method;
          // invoke with collected args
          return f && f.apply(scope || this, pre.concat(args));  // mixed
        };  // Function
      },
      hitch: function (scope, method) {
        // summary:
        //		Returns a function that will only ever execute in the given scope.
        //		This allows for easy use of object member functions
        //		in callbacks and other places in which the "this" keyword may
        //		otherwise not reference the expected scope.
        //		Any number of default positional arguments may be passed as parameters
        //		beyond "method".
        //		Each of these values will be used to "placehold" (similar to curry)
        //		for the hitched function.
        // scope: Object
        //		The scope to use when method executes. If method is a string,
        //		scope is also the object containing method.
        // method: Function|String...
        //		A function to be hitched to scope, or the name of the method in
        //		scope to be hitched.
        // example:
        //	|	lang.hitch(foo, "bar")();
        //		runs foo.bar() in the scope of foo
        // example:
        //	|	lang.hitch(foo, myFunction);
        //		returns a function that runs myFunction in the scope of foo
        // example:
        //		Expansion on the default positional arguments passed along from
        //		hitch. Passed args are mixed first, additional args after.
        //	|	var foo = { bar: function(a, b, c){ console.log(a, b, c); } };
        //	|	var fn = lang.hitch(foo, "bar", 1, 2);
        //	|	fn(3); // logs "1, 2, 3"
        // example:
        //	|	var foo = { bar: 2 };
        //	|	lang.hitch(foo, function(){ this.bar = 10; })();
        //		execute an anonymous function in scope of foo
        if (arguments.length > 2) {
          return lang._hitchArgs.apply(dojo, arguments);  // Function
        }
        if (!method) {
          method = scope;
          scope = null;
        }
        if (lang.isString(method)) {
          scope = scope || dojo.global;
          if (!scope[method]) {
            throw [
              'lang.hitch: scope["',
              method,
              '"] is null (scope="',
              scope,
              '")'
            ].join('');
          }
          return function () {
            return scope[method].apply(scope, arguments || []);
          };  // Function
        }
        return !scope ? method : function () {
          return method.apply(scope, arguments || []);
        };  // Function
      },
      delegate: function () {
        // boodman/crockford delegation w/ cornford optimization
        function TMP() {
        }
        return function (obj, props) {
          TMP.prototype = obj;
          var tmp = new TMP();
          TMP.prototype = null;
          if (props) {
            lang._mixin(tmp, props);
          }
          return tmp;  // Object
        };
      }(),
      /*=====
      delegate: function(obj, props){
      	// summary:
      	//		Returns a new object which "looks" to obj for properties which it
      	//		does not have a value for. Optionally takes a bag of properties to
      	//		seed the returned object with initially.
      	// description:
      	//		This is a small implementation of the Boodman/Crockford delegation
      	//		pattern in JavaScript. An intermediate object constructor mediates
      	//		the prototype chain for the returned object, using it to delegate
      	//		down to obj for property lookup when object-local lookup fails.
      	//		This can be thought of similarly to ES4's "wrap", save that it does
      	//		not act on types but rather on pure objects.
      	// obj: Object
      	//		The object to delegate to for properties not found directly on the
      	//		return object or in props.
      	// props: Object...
      	//		an object containing properties to assign to the returned object
      	// returns:
      	//		an Object of anonymous type
      	// example:
      	//	|	var foo = { bar: "baz" };
      	//	|	var thinger = lang.delegate(foo, { thud: "xyzzy"});
      	//	|	thinger.bar == "baz"; // delegated to foo
      	//	|	foo.thud == undefined; // by definition
      	//	|	thinger.thud == "xyzzy"; // mixed in from props
      	//	|	foo.bar = "thonk";
      	//	|	thinger.bar == "thonk"; // still delegated to foo's bar
      },
      =====*/
      _toArray: has('ie') ? function () {
        function slow(obj, offset, startWith) {
          var arr = startWith || [];
          for (var x = offset || 0; x < obj.length; x++) {
            arr.push(obj[x]);
          }
          return arr;
        }
        return function (obj) {
          return (obj.item ? slow : efficient).apply(this, arguments);
        };
      }() : efficient,
      /*=====
       _toArray: function(obj, offset, startWith){
      	 // summary:
      	 //		Converts an array-like object (i.e. arguments, DOMCollection) to an
      	 //		array. Returns a new Array with the elements of obj.
      	 // obj: Object
      	 //		the object to "arrayify". We expect the object to have, at a
      	 //		minimum, a length property which corresponds to integer-indexed
      	 //		properties.
      	 // offset: Number?
      	 //		the location in obj to start iterating from. Defaults to 0.
      	 //		Optional.
      	 // startWith: Array?
      	 //		An array to pack with the properties of obj. If provided,
      	 //		properties in obj are appended at the end of startWith and
      	 //		startWith is the returned array.
       },
       =====*/
      partial: function (method) {
        // summary:
        //		similar to hitch() except that the scope object is left to be
        //		whatever the execution context eventually becomes.
        // description:
        //		Calling lang.partial is the functional equivalent of calling:
        //		|	lang.hitch(null, funcName, ...);
        // method:
        //		The function to "wrap"
        var arr = [null];
        return lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments)));  // Function
      },
      clone: function (src) {
        // summary:
        //		Clones objects (including DOM nodes) and all children.
        //		Warning: do not clone cyclic structures.
        // src:
        //		The object to clone
        if (!src || typeof src != 'object' || lang.isFunction(src)) {
          // null, undefined, any non-object, or function
          return src;  // anything
        }
        if (src.nodeType && 'cloneNode' in src) {
          // DOM Node
          return src.cloneNode(true);  // Node
        }
        if (src instanceof Date) {
          // Date
          return new Date(src.getTime());  // Date
        }
        if (src instanceof RegExp) {
          // RegExp
          return new RegExp(src);  // RegExp
        }
        var r, i, l;
        if (lang.isArray(src)) {
          // array
          r = [];
          for (i = 0, l = src.length; i < l; ++i) {
            if (i in src) {
              r.push(lang.clone(src[i]));
            }
          }  // we don't clone functions for performance reasons
             //		}else if(d.isFunction(src)){
             //			// function
             //			r = function(){ return src.apply(this, arguments); };
        } else {
          // generic objects
          r = src.constructor ? new src.constructor() : {};
        }
        return lang._mixin(r, src, lang.clone);
      },
      trim: String.prototype.trim ? function (str) {
        return str.trim();
      } : function (str) {
        return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
      },
      /*=====
       trim: function(str){
      	 // summary:
      	 //		Trims whitespace from both sides of the string
      	 // str: String
      	 //		String to be trimmed
      	 // returns: String
      	 //		Returns the trimmed string
      	 // description:
      	 //		This version of trim() was selected for inclusion into the base due
      	 //		to its compact size and relatively good performance
      	 //		(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)
      	 //		Uses String.prototype.trim instead, if available.
      	 //		The fastest but longest version of this function is located at
      	 //		lang.string.trim()
       },
       =====*/
      replace: function (tmpl, map, pattern) {
        // summary:
        //		Performs parameterized substitutions on a string. Throws an
        //		exception if any parameter is unmatched.
        // tmpl: String
        //		String to be used as a template.
        // map: Object|Function
        //		If an object, it is used as a dictionary to look up substitutions.
        //		If a function, it is called for every substitution with following parameters:
        //		a whole match, a name, an offset, and the whole template
        //		string (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace
        //		for more details).
        // pattern: RegEx?
        //		Optional regular expression objects that overrides the default pattern.
        //		Must be global and match one item. The default is: /\{([^\}]+)\}/g,
        //		which matches patterns like that: "{xxx}", where "xxx" is any sequence
        //		of characters, which doesn't include "}".
        // returns: String
        //		Returns the substituted string.
        // example:
        //	|	// uses a dictionary for substitutions:
        //	|	lang.replace("Hello, {name.first} {name.last} AKA {nick}!",
        //	|		{
        //	|			nick: "Bob",
        //	|			name: {
        //	|				first:	"Robert",
        //	|				middle: "X",
        //	|				last:		"Cringely"
        //	|			}
        //	|		});
        //	|	// returns: Hello, Robert Cringely AKA Bob!
        // example:
        //	|	// uses an array for substitutions:
        //	|	lang.replace("Hello, {0} {2}!",
        //	|		["Robert", "X", "Cringely"]);
        //	|	// returns: Hello, Robert Cringely!
        // example:
        //	|	// uses a function for substitutions:
        //	|	function sum(a){
        //	|		var t = 0;
        //	|		arrayforEach(a, function(x){ t += x; });
        //	|		return t;
        //	|	}
        //	|	lang.replace(
        //	|		"{count} payments averaging {avg} USD per payment.",
        //	|		lang.hitch(
        //	|			{ payments: [11, 16, 12] },
        //	|			function(_, key){
        //	|				switch(key){
        //	|					case "count": return this.payments.length;
        //	|					case "min":		return Math.min.apply(Math, this.payments);
        //	|					case "max":		return Math.max.apply(Math, this.payments);
        //	|					case "sum":		return sum(this.payments);
        //	|					case "avg":		return sum(this.payments) / this.payments.length;
        //	|				}
        //	|			}
        //	|		)
        //	|	);
        //	|	// prints: 3 payments averaging 13 USD per payment.
        // example:
        //	|	// uses an alternative PHP-like pattern for substitutions:
        //	|	lang.replace("Hello, ${0} ${2}!",
        //	|		["Robert", "X", "Cringely"], /\$\{([^\}]+)\}/g);
        //	|	// returns: Hello, Robert Cringely!
        return tmpl.replace(pattern || _pattern, lang.isFunction(map) ? map : function (_, k) {
          return lang.getObject(k, false, map);
        });
      }
    };
    has('extend-dojo') && lang.mixin(dojo, lang);
    return lang;
  }(dojo__base_kernel, dojo_has);
  dojo__base_window = function (dojo, lang, has) {
    // module:
    //		dojo/_base/window
    var ret = {
      // summary:
      //		API to save/set/restore the global/document scope.
      global: dojo.global,
      /*=====
      global: {
       // summary:
       //		Alias for the current window. 'global' can be modified
       //		for temporary context shifting. See also withGlobal().
       // description:
       //		Use this rather than referring to 'window' to ensure your code runs
       //		correctly in managed contexts.
      },
      =====*/
      doc: dojo.global['document'] || null,
      /*=====
      	doc: {
      		// summary:
      		//		Alias for the current document. 'doc' can be modified
      		//		for temporary context shifting. See also withDoc().
      		// description:
      		//		Use this rather than referring to 'window.document' to ensure your code runs
      		//		correctly in managed contexts.
      		// example:
      		//	|	n.appendChild(dojo.doc.createElement('div'));
      	},
      	=====*/
      body: function (doc) {
        // summary:
        //		Return the body element of the specified document or of dojo/_base/window::doc.
        // example:
        //	|	win.body().appendChild(dojo.doc.createElement('div'));
        // Note: document.body is not defined for a strict xhtml document
        // Would like to memoize this, but dojo.doc can change vi dojo.withDoc().
        doc = doc || dojo.doc;
        return doc.body || doc.getElementsByTagName('body')[0];  // Node
      },
      setContext: function (globalObject, globalDocument) {
        // summary:
        //		changes the behavior of many core Dojo functions that deal with
        //		namespace and DOM lookup, changing them to work in a new global
        //		context (e.g., an iframe). The varibles dojo.global and dojo.doc
        //		are modified as a result of calling this function and the result of
        //		`dojo.body()` likewise differs.
        dojo.global = ret.global = globalObject;
        dojo.doc = ret.doc = globalDocument;
      },
      withGlobal: function (globalObject, callback, thisObject, cbArguments) {
        // summary:
        //		Invoke callback with globalObject as dojo.global and
        //		globalObject.document as dojo.doc.
        // description:
        //		Invoke callback with globalObject as dojo.global and
        //		globalObject.document as dojo.doc. If provided, globalObject
        //		will be executed in the context of object thisObject
        //		When callback() returns or throws an error, the dojo.global
        //		and dojo.doc will be restored to its previous state.
        var oldGlob = dojo.global;
        try {
          dojo.global = ret.global = globalObject;
          return ret.withDoc.call(null, globalObject.document, callback, thisObject, cbArguments);
        } finally {
          dojo.global = ret.global = oldGlob;
        }
      },
      withDoc: function (documentObject, callback, thisObject, cbArguments) {
        // summary:
        //		Invoke callback with documentObject as dojo/_base/window::doc.
        // description:
        //		Invoke callback with documentObject as dojo/_base/window::doc. If provided,
        //		callback will be executed in the context of object thisObject
        //		When callback() returns or throws an error, the dojo/_base/window::doc will
        //		be restored to its previous state.
        var oldDoc = ret.doc, oldQ = has('quirks'), oldIE = has('ie'), isIE, mode, pwin;
        try {
          dojo.doc = ret.doc = documentObject;
          // update dojo.isQuirks and the value of the has feature "quirks".
          // remove setting dojo.isQuirks and dojo.isIE for 2.0
          dojo.isQuirks = has.add('quirks', dojo.doc.compatMode == 'BackCompat', true, true);
          // no need to check for QuirksMode which was Opera 7 only
          if (has('ie')) {
            if ((pwin = documentObject.parentWindow) && pwin.navigator) {
              // re-run IE detection logic and update dojo.isIE / has("ie")
              // (the only time parentWindow/navigator wouldn't exist is if we were not
              // passed an actual legitimate document object)
              isIE = parseFloat(pwin.navigator.appVersion.split('MSIE ')[1]) || undefined;
              mode = documentObject.documentMode;
              if (mode && mode != 5 && Math.floor(isIE) != mode) {
                isIE = mode;
              }
              dojo.isIE = has.add('ie', isIE, true, true);
            }
          }
          if (thisObject && typeof callback == 'string') {
            callback = thisObject[callback];
          }
          return callback.apply(thisObject, cbArguments || []);
        } finally {
          dojo.doc = ret.doc = oldDoc;
          dojo.isQuirks = has.add('quirks', oldQ, true, true);
          dojo.isIE = has.add('ie', oldIE, true, true);
        }
      }
    };
    has('extend-dojo') && lang.mixin(dojo, ret);
    return ret;
  }(dojo__base_kernel, dojo__base_lang, dojo_sniff);
  dojo_dom = function (has, win) {
    // module:
    //		dojo/dom
    // FIXME: need to add unit tests for all the semi-public methods
    if (has('ie') <= 7) {
      try {
        document.execCommand('BackgroundImageCache', false, true);
      } catch (e) {
      }
    }
    // =============================
    // DOM Functions
    // =============================
    // the result object
    var dom = {};
    if (has('ie')) {
      dom.byId = function (id, doc) {
        if (typeof id != 'string') {
          return id;
        }
        var _d = doc || win.doc, te = id && _d.getElementById(id);
        // attributes.id.value is better than just id in case the
        // user has a name=id inside a form
        if (te && (te.attributes.id.value == id || te.id == id)) {
          return te;
        } else {
          var eles = _d.all[id];
          if (!eles || eles.nodeName) {
            eles = [eles];
          }
          // if more than 1, choose first with the correct id
          var i = 0;
          while (te = eles[i++]) {
            if (te.attributes && te.attributes.id && te.attributes.id.value == id || te.id == id) {
              return te;
            }
          }
        }
      };
    } else {
      dom.byId = function (id, doc) {
        // inline'd type check.
        // be sure to return null per documentation, to match IE branch.
        return (typeof id == 'string' ? (doc || win.doc).getElementById(id) : id) || null;  // DOMNode
      };
    }
    /*=====
    dom.byId = function(id, doc){
    // summary:
    //		Returns DOM node with matching `id` attribute or falsy value (ex: null or undefined)
    //		if not found.  If `id` is a DomNode, this function is a no-op.
    //
    // id: String|DOMNode
    //		A string to match an HTML id attribute or a reference to a DOM Node
    //
    // doc: Document?
    //		Document to work in. Defaults to the current value of
    //		dojo/_base/window.doc.  Can be used to retrieve
    //		node references from other documents.
    //
    // example:
    //		Look up a node by ID:
    //	|	require(["dojo/dom"], function(dom){
    //	|		var n = dom.byId("foo");
    //	|	});
    //
    // example:
    //		Check if a node exists, and use it.
    //	|	require(["dojo/dom"], function(dom){
    //	|		var n = dom.byId("bar");
    //	|		if(n){ doStuff() ... }
    //	|	});
    //
    // example:
    //		Allow string or DomNode references to be passed to a custom function:
    //	|	require(["dojo/dom"], function(dom){
    //	|		var foo = function(nodeOrId){
    //	|			nodeOrId = dom.byId(nodeOrId);
    //	|			// ... more stuff
    //	|		}
    //	|	});
    };
    =====*/
    dom.isDescendant = function (node, ancestor) {
      // summary:
      //		Returns true if node is a descendant of ancestor
      // node: DOMNode|String
      //		string id or node reference to test
      // ancestor: DOMNode|String
      //		string id or node reference of potential parent to test against
      //
      // example:
      //		Test is node id="bar" is a descendant of node id="foo"
      //	|	require(["dojo/dom"], function(dom){
      //	|		if(dom.isDescendant("bar", "foo")){ ... }
      //	|	});
      try {
        node = dom.byId(node);
        ancestor = dom.byId(ancestor);
        while (node) {
          if (node == ancestor) {
            return true;  // Boolean
          }
          node = node.parentNode;
        }
      } catch (e) {
      }
      return false;  // Boolean
    };
    // TODO: do we need setSelectable in the base?
    // Add feature test for user-select CSS property
    // (currently known to work in all but IE < 10 and Opera)
    // TODO: The user-select CSS property as of May 2014 is no longer part of
    // any CSS specification. In IE, -ms-user-select does not do the same thing
    // as the unselectable attribute on elements; namely, dijit Editor buttons
    // do not properly prevent the content of the editable content frame from
    // unblurring. As a result, the -ms- prefixed version is omitted here.
    has.add('css-user-select', function (global, doc, element) {
      // Avoid exception when dom.js is loaded in non-browser environments
      if (!element) {
        return false;
      }
      var style = element.style;
      var prefixes = [
          'Khtml',
          'O',
          'Moz',
          'Webkit'
        ], i = prefixes.length, name = 'userSelect', prefix;
      // Iterate prefixes from most to least likely
      do {
        if (typeof style[name] !== 'undefined') {
          // Supported; return property name
          return name;
        }
      } while (i-- && (name = prefixes[i] + 'UserSelect'));
      // Not supported if we didn't return before now
      return false;
    });
    /*=====
    	dom.setSelectable = function(node, selectable){
    		// summary:
    		//		Enable or disable selection on a node
    		// node: DOMNode|String
    		//		id or reference to node
    		// selectable: Boolean
    		//		state to put the node in. false indicates unselectable, true
    		//		allows selection.
    		// example:
    		//		Make the node id="bar" unselectable
    		//	|	require(["dojo/dom"], function(dom){
    		//	|		dom.setSelectable("bar");
    		//	|	});
    		// example:
    		//		Make the node id="bar" selectable
    		//	|	require(["dojo/dom"], function(dom){
    		//	|		dom.setSelectable("bar", true);
    		//	|	});
    	};
    	=====*/
    var cssUserSelect = has('css-user-select');
    dom.setSelectable = cssUserSelect ? function (node, selectable) {
      // css-user-select returns a (possibly vendor-prefixed) CSS property name
      dom.byId(node).style[cssUserSelect] = selectable ? '' : 'none';
    } : function (node, selectable) {
      node = dom.byId(node);
      // (IE < 10 / Opera) Fall back to setting/removing the
      // unselectable attribute on the element and all its children
      var nodes = node.getElementsByTagName('*'), i = nodes.length;
      if (selectable) {
        node.removeAttribute('unselectable');
        while (i--) {
          nodes[i].removeAttribute('unselectable');
        }
      } else {
        node.setAttribute('unselectable', 'on');
        while (i--) {
          nodes[i].setAttribute('unselectable', 'on');
        }
      }
    };
    return dom;
  }(dojo_sniff, dojo__base_window);
  dojo_on = function (aspect, dojo, has) {
    if (true) {
      // check to make sure we are in a browser, this module should work anywhere
      var major = window.ScriptEngineMajorVersion;
      has.add('jscript', major && major() + ScriptEngineMinorVersion() / 10);
      has.add('event-orientationchange', has('touch') && !has('android'));
      // TODO: how do we detect this?
      has.add('event-stopimmediatepropagation', window.Event && !!window.Event.prototype && !!window.Event.prototype.stopImmediatePropagation);
      has.add('event-focusin', function (global, doc, element) {
        return 'onfocusin' in element;
      });
      if (has('touch')) {
        has.add('touch-can-modify-event-delegate', function () {
          // This feature test checks whether deleting a property of an event delegate works
          // for a touch-enabled device. If it works, event delegation can be used as fallback
          // for browsers such as Safari in older iOS where deleting properties of the original
          // event does not work.
          var EventDelegate = function () {
          };
          EventDelegate.prototype = document.createEvent('MouseEvents');
          // original event
          // Attempt to modify a property of an event delegate and check if
          // it succeeds. Depending on browsers and on whether dojo/on's
          // strict mode is stripped in a Dojo build, there are 3 known behaviors:
          // it may either succeed, or raise an error, or fail to set the property
          // without raising an error.
          try {
            var eventDelegate = new EventDelegate();
            eventDelegate.target = null;
            return eventDelegate.target === null;
          } catch (e) {
            return false;
          }
        });
      }
    }
    var on = function (target, type, listener, dontFix) {
      // summary:
      //		A function that provides core event listening functionality. With this function
      //		you can provide a target, event type, and listener to be notified of
      //		future matching events that are fired.
      // target: Element|Object
      //		This is the target object or DOM element that to receive events from
      // type: String|Function
      //		This is the name of the event to listen for or an extension event type.
      // listener: Function
      //		This is the function that should be called when the event fires.
      // returns: Object
      //		An object with a remove() method that can be used to stop listening for this
      //		event.
      // description:
      //		To listen for "click" events on a button node, we can do:
      //		|	define(["dojo/on"], function(listen){
      //		|		on(button, "click", clickHandler);
      //		|		...
      //		Evented JavaScript objects can also have their own events.
      //		|	var obj = new Evented;
      //		|	on(obj, "foo", fooHandler);
      //		And then we could publish a "foo" event:
      //		|	on.emit(obj, "foo", {key: "value"});
      //		We can use extension events as well. For example, you could listen for a tap gesture:
      //		|	define(["dojo/on", "dojo/gesture/tap", function(listen, tap){
      //		|		on(button, tap, tapHandler);
      //		|		...
      //		which would trigger fooHandler. Note that for a simple object this is equivalent to calling:
      //		|	obj.onfoo({key:"value"});
      //		If you use on.emit on a DOM node, it will use native event dispatching when possible.
      if (typeof target.on == 'function' && typeof type != 'function' && !target.nodeType) {
        // delegate to the target's on() method, so it can handle it's own listening if it wants (unless it
        // is DOM node and we may be dealing with jQuery or Prototype's incompatible addition to the
        // Element prototype
        return target.on(type, listener);
      }
      // delegate to main listener code
      return on.parse(target, type, listener, addListener, dontFix, this);
    };
    on.pausable = function (target, type, listener, dontFix) {
      // summary:
      //		This function acts the same as on(), but with pausable functionality. The
      //		returned signal object has pause() and resume() functions. Calling the
      //		pause() method will cause the listener to not be called for future events. Calling the
      //		resume() method will cause the listener to again be called for future events.
      var paused;
      var signal = on(target, type, function () {
        if (!paused) {
          return listener.apply(this, arguments);
        }
      }, dontFix);
      signal.pause = function () {
        paused = true;
      };
      signal.resume = function () {
        paused = false;
      };
      return signal;
    };
    on.once = function (target, type, listener, dontFix) {
      // summary:
      //		This function acts the same as on(), but will only call the listener once. The
      //		listener will be called for the first
      //		event that takes place and then listener will automatically be removed.
      var signal = on(target, type, function () {
        // remove this listener
        signal.remove();
        // proceed to call the listener
        return listener.apply(this, arguments);
      });
      return signal;
    };
    on.parse = function (target, type, listener, addListener, dontFix, matchesTarget) {
      if (type.call) {
        // event handler function
        // on(node, touch.press, touchListener);
        return type.call(matchesTarget, target, listener);
      }
      if (type instanceof Array) {
        // allow an array of event names (or event handler functions)
        events = type;
      } else if (type.indexOf(',') > -1) {
        // we allow comma delimited event names, so you can register for multiple events at once
        var events = type.split(/\s*,\s*/);
      }
      if (events) {
        var handles = [];
        var i = 0;
        var eventName;
        while (eventName = events[i++]) {
          handles.push(on.parse(target, eventName, listener, addListener, dontFix, matchesTarget));
        }
        handles.remove = function () {
          for (var i = 0; i < handles.length; i++) {
            handles[i].remove();
          }
        };
        return handles;
      }
      return addListener(target, type, listener, dontFix, matchesTarget);
    };
    var touchEvents = /^touch/;
    function addListener(target, type, listener, dontFix, matchesTarget) {
      // event delegation:
      var selector = type.match(/(.*):(.*)/);
      // if we have a selector:event, the last one is interpreted as an event, and we use event delegation
      if (selector) {
        type = selector[2];
        selector = selector[1];
        // create the extension event for selectors and directly call it
        return on.selector(selector, type).call(matchesTarget, target, listener);
      }
      // test to see if it a touch event right now, so we don't have to do it every time it fires
      if (has('touch')) {
        if (touchEvents.test(type)) {
          // touch event, fix it
          listener = fixTouchListener(listener);
        }
        if (!has('event-orientationchange') && type == 'orientationchange') {
          //"orientationchange" not supported <= Android 2.1,
          //but works through "resize" on window
          type = 'resize';
          target = window;
          listener = fixTouchListener(listener);
        }
      }
      if (addStopImmediate) {
        // add stopImmediatePropagation if it doesn't exist
        listener = addStopImmediate(listener);
      }
      // normal path, the target is |this|
      if (target.addEventListener) {
        // the target has addEventListener, which should be used if available (might or might not be a node, non-nodes can implement this method as well)
        // check for capture conversions
        var capture = type in captures, adjustedType = capture ? captures[type] : type;
        target.addEventListener(adjustedType, listener, capture);
        // create and return the signal
        return {
          remove: function () {
            target.removeEventListener(adjustedType, listener, capture);
          }
        };
      }
      type = 'on' + type;
      if (fixAttach && target.attachEvent) {
        return fixAttach(target, type, listener);
      }
      throw new Error('Target must be an event emitter');
    }
    on.matches = function (node, selector, context, children, matchesTarget) {
      // summary:
      //		Check if a node match the current selector within the constraint of a context
      // node: DOMNode
      //		The node that originate the event
      // selector: String
      //		The selector to check against
      // context: DOMNode
      //		The context to search in.
      // children: Boolean
      //		Indicates if children elements of the selector should be allowed. This defaults to
      //		true
      // matchesTarget: Object|dojo/query?
      //		An object with a property "matches" as a function. Default is dojo/query.
      //		Matching DOMNodes will be done against this function
      //		The function must return a Boolean.
      //		It will have 3 arguments: "node", "selector" and "context"
      //		True is expected if "node" is matching the current "selector" in the passed "context"
      // returns: DOMNode?
      //		The matching node, if any. Else you get false
      // see if we have a valid matchesTarget or default to dojo/query
      matchesTarget = matchesTarget && matchesTarget.matches ? matchesTarget : dojo.query;
      children = children !== false;
      // there is a selector, so make sure it matches
      if (node.nodeType != 1) {
        // text node will fail in native match selector
        node = node.parentNode;
      }
      while (!matchesTarget.matches(node, selector, context)) {
        if (node == context || children === false || !(node = node.parentNode) || node.nodeType != 1) {
          // intentional assignment
          return false;
        }
      }
      return node;
    };
    on.selector = function (selector, eventType, children) {
      // summary:
      //		Creates a new extension event with event delegation. This is based on
      //		the provided event type (can be extension event) that
      //		only calls the listener when the CSS selector matches the target of the event.
      //
      //		The application must require() an appropriate level of dojo/query to handle the selector.
      // selector:
      //		The CSS selector to use for filter events and determine the |this| of the event listener.
      // eventType:
      //		The event to listen for
      // children:
      //		Indicates if children elements of the selector should be allowed. This defaults to
      //		true
      // example:
      // |	require(["dojo/on", "dojo/mouse", "dojo/query!css2"], function(listen, mouse){
      // |		on(node, on.selector(".my-class", mouse.enter), handlerForMyHover);
      return function (target, listener) {
        // if the selector is function, use it to select the node, otherwise use the matches method
        var matchesTarget = typeof selector == 'function' ? { matches: selector } : this, bubble = eventType.bubble;
        function select(eventTarget) {
          return on.matches(eventTarget, selector, target, children, matchesTarget);
        }
        if (bubble) {
          // the event type doesn't naturally bubble, but has a bubbling form, use that, and give it the selector so it can perform the select itself
          return on(target, bubble(select), listener);
        }
        // standard event delegation
        return on(target, eventType, function (event) {
          // call select to see if we match
          var eventTarget = select(event.target);
          // if it matches we call the listener
          if (eventTarget) {
            return listener.call(eventTarget, event);
          }
        });
      };
    };
    function syntheticPreventDefault() {
      this.cancelable = false;
      this.defaultPrevented = true;
    }
    function syntheticStopPropagation() {
      this.bubbles = false;
    }
    var slice = [].slice, syntheticDispatch = on.emit = function (target, type, event) {
        // summary:
        //		Fires an event on the target object.
        // target:
        //		The target object to fire the event on. This can be a DOM element or a plain
        //		JS object. If the target is a DOM element, native event emitting mechanisms
        //		are used when possible.
        // type:
        //		The event type name. You can emulate standard native events like "click" and
        //		"mouseover" or create custom events like "open" or "finish".
        // event:
        //		An object that provides the properties for the event. See https://developer.mozilla.org/en/DOM/event.initEvent
        //		for some of the properties. These properties are copied to the event object.
        //		Of particular importance are the cancelable and bubbles properties. The
        //		cancelable property indicates whether or not the event has a default action
        //		that can be cancelled. The event is cancelled by calling preventDefault() on
        //		the event object. The bubbles property indicates whether or not the
        //		event will bubble up the DOM tree. If bubbles is true, the event will be called
        //		on the target and then each parent successively until the top of the tree
        //		is reached or stopPropagation() is called. Both bubbles and cancelable
        //		default to false.
        // returns:
        //		If the event is cancelable and the event is not cancelled,
        //		emit will return true. If the event is cancelable and the event is cancelled,
        //		emit will return false.
        // details:
        //		Note that this is designed to emit events for listeners registered through
        //		dojo/on. It should actually work with any event listener except those
        //		added through IE's attachEvent (IE8 and below's non-W3C event emitting
        //		doesn't support custom event types). It should work with all events registered
        //		through dojo/on. Also note that the emit method does do any default
        //		action, it only returns a value to indicate if the default action should take
        //		place. For example, emitting a keypress event would not cause a character
        //		to appear in a textbox.
        // example:
        //		To fire our own click event
        //	|	require(["dojo/on", "dojo/dom"
        //	|	], function(on, dom){
        //	|		on.emit(dom.byId("button"), "click", {
        //	|			cancelable: true,
        //	|			bubbles: true,
        //	|			screenX: 33,
        //	|			screenY: 44
        //	|		});
        //		We can also fire our own custom events:
        //	|		on.emit(dom.byId("slider"), "slide", {
        //	|			cancelable: true,
        //	|			bubbles: true,
        //	|			direction: "left-to-right"
        //	|		});
        //	|	});
        var args = slice.call(arguments, 2);
        var method = 'on' + type;
        if ('parentNode' in target) {
          // node (or node-like), create event controller methods
          var newEvent = args[0] = {};
          for (var i in event) {
            newEvent[i] = event[i];
          }
          newEvent.preventDefault = syntheticPreventDefault;
          newEvent.stopPropagation = syntheticStopPropagation;
          newEvent.target = target;
          newEvent.type = type;
          event = newEvent;
        }
        do {
          // call any node which has a handler (note that ideally we would try/catch to simulate normal event propagation but that causes too much pain for debugging)
          target[method] && target[method].apply(target, args);  // and then continue up the parent node chain if it is still bubbling (if started as bubbles and stopPropagation hasn't been called)
        } while (event && event.bubbles && (target = target.parentNode));
        return event && event.cancelable && event;  // if it is still true (was cancelable and was cancelled), return the event to indicate default action should happen
      };
    var captures = has('event-focusin') ? {} : {
      focusin: 'focus',
      focusout: 'blur'
    };
    if (!has('event-stopimmediatepropagation')) {
      var stopImmediatePropagation = function () {
        this.immediatelyStopped = true;
        this.modified = true;  // mark it as modified so the event will be cached in IE
      };
      var addStopImmediate = function (listener) {
        return function (event) {
          if (!event.immediatelyStopped) {
            // check to make sure it hasn't been stopped immediately
            event.stopImmediatePropagation = stopImmediatePropagation;
            return listener.apply(this, arguments);
          }
        };
      };
    }
    if (has('dom-addeventlistener')) {
      // emitter that works with native event handling
      on.emit = function (target, type, event) {
        if (target.dispatchEvent && document.createEvent) {
          // use the native event emitting mechanism if it is available on the target object
          // create a generic event
          // we could create branch into the different types of event constructors, but
          // that would be a lot of extra code, with little benefit that I can see, seems
          // best to use the generic constructor and copy properties over, making it
          // easy to have events look like the ones created with specific initializers
          var ownerDocument = target.ownerDocument || document;
          var nativeEvent = ownerDocument.createEvent('HTMLEvents');
          nativeEvent.initEvent(type, !!event.bubbles, !!event.cancelable);
          // and copy all our properties over
          for (var i in event) {
            if (!(i in nativeEvent)) {
              nativeEvent[i] = event[i];
            }
          }
          return target.dispatchEvent(nativeEvent) && nativeEvent;
        }
        return syntheticDispatch.apply(on, arguments);  // emit for a non-node
      };
    } else {
      // no addEventListener, basically old IE event normalization
      on._fixEvent = function (evt, sender) {
        // summary:
        //		normalizes properties on the event object including event
        //		bubbling methods, keystroke normalization, and x/y positions
        // evt:
        //		native event object
        // sender:
        //		node to treat as "currentTarget"
        if (!evt) {
          var w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;
          evt = w.event;
        }
        if (!evt) {
          return evt;
        }
        try {
          if (lastEvent && evt.type == lastEvent.type && evt.srcElement == lastEvent.target) {
            // should be same event, reuse event object (so it can be augmented);
            // accessing evt.srcElement rather than evt.target since evt.target not set on IE until fixup below
            evt = lastEvent;
          }
        } catch (e) {
        }
        if (!evt.target) {
          // check to see if it has been fixed yet
          evt.target = evt.srcElement;
          evt.currentTarget = sender || evt.srcElement;
          if (evt.type == 'mouseover') {
            evt.relatedTarget = evt.fromElement;
          }
          if (evt.type == 'mouseout') {
            evt.relatedTarget = evt.toElement;
          }
          if (!evt.stopPropagation) {
            evt.stopPropagation = stopPropagation;
            evt.preventDefault = preventDefault;
          }
          switch (evt.type) {
          case 'keypress':
            var c = 'charCode' in evt ? evt.charCode : evt.keyCode;
            if (c == 10) {
              // CTRL-ENTER is CTRL-ASCII(10) on IE, but CTRL-ENTER on Mozilla
              c = 0;
              evt.keyCode = 13;
            } else if (c == 13 || c == 27) {
              c = 0;  // Mozilla considers ENTER and ESC non-printable
            } else if (c == 3) {
              c = 99;  // Mozilla maps CTRL-BREAK to CTRL-c
            }
            // Mozilla sets keyCode to 0 when there is a charCode
            // but that stops the event on IE.
            evt.charCode = c;
            _setKeyChar(evt);
            break;
          }
        }
        return evt;
      };
      var lastEvent, IESignal = function (handle) {
          this.handle = handle;
        };
      IESignal.prototype.remove = function () {
        delete _dojoIEListeners_[this.handle];
      };
      var fixListener = function (listener) {
        // this is a minimal function for closing on the previous listener with as few as variables as possible
        return function (evt) {
          evt = on._fixEvent(evt, this);
          var result = listener.call(this, evt);
          if (evt.modified) {
            // cache the last event and reuse it if we can
            if (!lastEvent) {
              setTimeout(function () {
                lastEvent = null;
              });
            }
            lastEvent = evt;
          }
          return result;
        };
      };
      var fixAttach = function (target, type, listener) {
        listener = fixListener(listener);
        if (((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) != top || has('jscript') < 5.8) && !has('config-_allow_leaks')) {
          // IE will leak memory on certain handlers in frames (IE8 and earlier) and in unattached DOM nodes for JScript 5.7 and below.
          // Here we use global redirection to solve the memory leaks
          if (typeof _dojoIEListeners_ == 'undefined') {
            _dojoIEListeners_ = [];
          }
          var emitter = target[type];
          if (!emitter || !emitter.listeners) {
            var oldListener = emitter;
            emitter = Function('event', 'var callee = arguments.callee; for(var i = 0; i<callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}');
            emitter.listeners = [];
            target[type] = emitter;
            emitter.global = this;
            if (oldListener) {
              emitter.listeners.push(_dojoIEListeners_.push(oldListener) - 1);
            }
          }
          var handle;
          emitter.listeners.push(handle = emitter.global._dojoIEListeners_.push(listener) - 1);
          return new IESignal(handle);
        }
        return aspect.after(target, type, listener, true);
      };
      var _setKeyChar = function (evt) {
        evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
        evt.charOrCode = evt.keyChar || evt.keyCode;  // TODO: remove for 2.0
      };
      // Called in Event scope
      var stopPropagation = function () {
        this.cancelBubble = true;
      };
      var preventDefault = on._preventDefault = function () {
        // Setting keyCode to 0 is the only way to prevent certain keypresses (namely
        // ctrl-combinations that correspond to menu accelerator keys).
        // Otoh, it prevents upstream listeners from getting this information
        // Try to split the difference here by clobbering keyCode only for ctrl
        // combinations. If you still need to access the key upstream, bubbledKeyCode is
        // provided as a workaround.
        this.bubbledKeyCode = this.keyCode;
        if (this.ctrlKey) {
          try {
            // squelch errors when keyCode is read-only
            // (e.g. if keyCode is ctrl or shift)
            this.keyCode = 0;
          } catch (e) {
          }
        }
        this.defaultPrevented = true;
        this.returnValue = false;
        this.modified = true;  // mark it as modified  (for defaultPrevented flag) so the event will be cached in IE
      };
    }
    if (has('touch')) {
      var EventDelegate = function () {
      };
      var windowOrientation = window.orientation;
      var fixTouchListener = function (listener) {
        return function (originalEvent) {
          //Event normalization(for ontouchxxx and resize):
          //1.incorrect e.pageX|pageY in iOS
          //2.there are no "e.rotation", "e.scale" and "onorientationchange" in Android
          //3.More TBD e.g. force | screenX | screenX | clientX | clientY | radiusX | radiusY
          // see if it has already been corrected
          var event = originalEvent.corrected;
          if (!event) {
            var type = originalEvent.type;
            try {
              delete originalEvent.type;  // on some JS engines (android), deleting properties makes them mutable
            } catch (e) {
            }
            if (originalEvent.type) {
              // Deleting the property of the original event did not work (this is the case of
              // browsers such as older Safari iOS), hence fallback:
              if (has('touch-can-modify-event-delegate')) {
                // If deleting properties of delegated event works, use event delegation:
                EventDelegate.prototype = originalEvent;
                event = new EventDelegate();
              } else {
                // Otherwise last fallback: other browsers, such as mobile Firefox, do not like
                // delegated properties, so we have to copy
                event = {};
                for (var name in originalEvent) {
                  event[name] = originalEvent[name];
                }
              }
              // have to delegate methods to make them work
              event.preventDefault = function () {
                originalEvent.preventDefault();
              };
              event.stopPropagation = function () {
                originalEvent.stopPropagation();
              };
            } else {
              // deletion worked, use property as is
              event = originalEvent;
              event.type = type;
            }
            originalEvent.corrected = event;
            if (type == 'resize') {
              if (windowOrientation == window.orientation) {
                return null;  //double tap causes an unexpected 'resize' in Android
              }
              windowOrientation = window.orientation;
              event.type = 'orientationchange';
              return listener.call(this, event);
            }
            // We use the original event and augment, rather than doing an expensive mixin operation
            if (!('rotation' in event)) {
              // test to see if it has rotation
              event.rotation = 0;
              event.scale = 1;
            }
            //use event.changedTouches[0].pageX|pageY|screenX|screenY|clientX|clientY|target
            var firstChangeTouch = event.changedTouches[0];
            for (var i in firstChangeTouch) {
              // use for-in, we don't need to have dependency on dojo/_base/lang here
              delete event[i];
              // delete it first to make it mutable
              event[i] = firstChangeTouch[i];
            }
          }
          return listener.call(this, event);
        };
      };
    }
    return on;
  }(dojo_aspect, dojo__base_kernel, dojo_sniff);
  dojo_dom_style = function (has, dom) {
    // module:
    //		dojo/dom-style
    // =============================
    // Style Functions
    // =============================
    // getComputedStyle drives most of the style code.
    // Wherever possible, reuse the returned object.
    //
    // API functions below that need to access computed styles accept an
    // optional computedStyle parameter.
    // If this parameter is omitted, the functions will call getComputedStyle themselves.
    // This way, calling code can access computedStyle once, and then pass the reference to
    // multiple API functions.
    // Although we normally eschew argument validation at this
    // level, here we test argument 'node' for (duck)type,
    // by testing nodeType, ecause 'document' is the 'parentNode' of 'body'
    // it is frequently sent to this function even
    // though it is not Element.
    var getComputedStyle, style = {};
    if (has('webkit')) {
      getComputedStyle = function (node) {
        var s;
        if (node.nodeType == 1) {
          var dv = node.ownerDocument.defaultView;
          s = dv.getComputedStyle(node, null);
          if (!s && node.style) {
            node.style.display = '';
            s = dv.getComputedStyle(node, null);
          }
        }
        return s || {};
      };
    } else if (has('ie') && (has('ie') < 9 || has('quirks'))) {
      getComputedStyle = function (node) {
        // IE (as of 7) doesn't expose Element like sane browsers
        // currentStyle can be null on IE8!
        return node.nodeType == 1  /* ELEMENT_NODE*/ && node.currentStyle ? node.currentStyle : {};
      };
    } else {
      getComputedStyle = function (node) {
        return node.nodeType == 1  /* ELEMENT_NODE*/ ? node.ownerDocument.defaultView.getComputedStyle(node, null) : {};
      };
    }
    style.getComputedStyle = getComputedStyle;
    /*=====
    	style.getComputedStyle = function(node){
    		// summary:
    		//		Returns a "computed style" object.
    		//
    		// description:
    		//		Gets a "computed style" object which can be used to gather
    		//		information about the current state of the rendered node.
    		//
    		//		Note that this may behave differently on different browsers.
    		//		Values may have different formats and value encodings across
    		//		browsers.
    		//
    		//		Note also that this method is expensive.  Wherever possible,
    		//		reuse the returned object.
    		//
    		//		Use the dojo/dom-style.get() method for more consistent (pixelized)
    		//		return values.
    		//
    		// node: DOMNode
    		//		A reference to a DOM node. Does NOT support taking an
    		//		ID string for speed reasons.
    		// example:
    		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
    		//	|		domStyle.getComputedStyle(dom.byId('foo')).borderWidth;
    		//	|	});
    		//
    		// example:
    		//		Reusing the returned object, avoiding multiple lookups:
    		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
    		//	|		var cs = domStyle.getComputedStyle(dom.byId("someNode"));
    		//	|		var w = cs.width, h = cs.height;
    		//	|	});
    		return; // CSS2Properties
    	};
    	=====*/
    var toPixel;
    if (!has('ie')) {
      toPixel = function (element, value) {
        // style values can be floats, client code may want
        // to round for integer pixels.
        return parseFloat(value) || 0;
      };
    } else {
      toPixel = function (element, avalue) {
        if (!avalue) {
          return 0;
        }
        // on IE7, medium is usually 4 pixels
        if (avalue == 'medium') {
          return 4;
        }
        // style values can be floats, client code may
        // want to round this value for integer pixels.
        if (avalue.slice && avalue.slice(-2) == 'px') {
          return parseFloat(avalue);
        }
        var s = element.style, rs = element.runtimeStyle, cs = element.currentStyle, sLeft = s.left, rsLeft = rs.left;
        rs.left = cs.left;
        try {
          // 'avalue' may be incompatible with style.left, which can cause IE to throw
          // this has been observed for border widths using "thin", "medium", "thick" constants
          // those particular constants could be trapped by a lookup
          // but perhaps there are more
          s.left = avalue;
          avalue = s.pixelLeft;
        } catch (e) {
          avalue = 0;
        }
        s.left = sLeft;
        rs.left = rsLeft;
        return avalue;
      };
    }
    style.toPixelValue = toPixel;
    /*=====
    	style.toPixelValue = function(node, value){
    		// summary:
    		//		converts style value to pixels on IE or return a numeric value.
    		// node: DOMNode
    		// value: String
    		// returns: Number
    	};
    	=====*/
    // FIXME: there opacity quirks on FF that we haven't ported over. Hrm.
    var astr = 'DXImageTransform.Microsoft.Alpha';
    var af = function (n, f) {
      try {
        return n.filters.item(astr);
      } catch (e) {
        return f ? {} : null;
      }
    };
    var _getOpacity = has('ie') < 9 || has('ie') < 10 && has('quirks') ? function (node) {
      try {
        return af(node).Opacity / 100;  // Number
      } catch (e) {
        return 1;
      }
    } : function (node) {
      return getComputedStyle(node).opacity;
    };
    var _setOpacity = has('ie') < 9 || has('ie') < 10 && has('quirks') ? function (node, opacity) {
      if (opacity === '') {
        opacity = 1;
      }
      var ov = opacity * 100, fullyOpaque = opacity === 1;
      // on IE7 Alpha(Filter opacity=100) makes text look fuzzy so disable it altogether (bug #2661),
      // but still update the opacity value so we can get a correct reading if it is read later:
      // af(node, 1).Enabled = !fullyOpaque;
      if (fullyOpaque) {
        node.style.zoom = '';
        if (af(node)) {
          node.style.filter = node.style.filter.replace(new RegExp('\\s*progid:' + astr + '\\([^\\)]+?\\)', 'i'), '');
        }
      } else {
        node.style.zoom = 1;
        if (af(node)) {
          af(node, 1).Opacity = ov;
        } else {
          node.style.filter += ' progid:' + astr + '(Opacity=' + ov + ')';
        }
        af(node, 1).Enabled = true;
      }
      if (node.tagName.toLowerCase() == 'tr') {
        for (var td = node.firstChild; td; td = td.nextSibling) {
          if (td.tagName.toLowerCase() == 'td') {
            _setOpacity(td, opacity);
          }
        }
      }
      return opacity;
    } : function (node, opacity) {
      return node.style.opacity = opacity;
    };
    var _pixelNamesCache = {
      left: true,
      top: true
    };
    var _pixelRegExp = /margin|padding|width|height|max|min|offset/;
    // |border
    function _toStyleValue(node, type, value) {
      //TODO: should we really be doing string case conversion here? Should we cache it? Need to profile!
      type = type.toLowerCase();
      if (has('ie') || has('trident')) {
        if (value == 'auto') {
          if (type == 'height') {
            return node.offsetHeight;
          }
          if (type == 'width') {
            return node.offsetWidth;
          }
        }
        if (type == 'fontweight') {
          switch (value) {
          case 700:
            return 'bold';
          case 400:
          default:
            return 'normal';
          }
        }
      }
      if (!(type in _pixelNamesCache)) {
        _pixelNamesCache[type] = _pixelRegExp.test(type);
      }
      return _pixelNamesCache[type] ? toPixel(node, value) : value;
    }
    var _floatAliases = {
      cssFloat: 1,
      styleFloat: 1,
      'float': 1
    };
    // public API
    style.get = function getStyle(node, name) {
      // summary:
      //		Accesses styles on a node.
      // description:
      //		Getting the style value uses the computed style for the node, so the value
      //		will be a calculated value, not just the immediate node.style value.
      //		Also when getting values, use specific style names,
      //		like "borderBottomWidth" instead of "border" since compound values like
      //		"border" are not necessarily reflected as expected.
      //		If you want to get node dimensions, use `dojo/dom-geometry.getMarginBox()`,
      //		`dojo/dom-geometry.getContentBox()` or `dojo/dom-geometry.getPosition()`.
      // node: DOMNode|String
      //		id or reference to node to get style for
      // name: String?
      //		the style property to get
      // example:
      //		Passing only an ID or node returns the computed style object of
      //		the node:
      //	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
      //	|		domStyle.get("thinger");
      //	|	});
      // example:
      //		Passing a node and a style property returns the current
      //		normalized, computed value for that property:
      //	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
      //	|		domStyle.get("thinger", "opacity"); // 1 by default
      //	|	});
      var n = dom.byId(node), l = arguments.length, op = name == 'opacity';
      if (l == 2 && op) {
        return _getOpacity(n);
      }
      name = _floatAliases[name] ? 'cssFloat' in n.style ? 'cssFloat' : 'styleFloat' : name;
      var s = style.getComputedStyle(n);
      return l == 1 ? s : _toStyleValue(n, name, s[name] || n.style[name]);  /* CSS2Properties||String||Number */
    };
    style.set = function setStyle(node, name, value) {
      // summary:
      //		Sets styles on a node.
      // node: DOMNode|String
      //		id or reference to node to set style for
      // name: String|Object
      //		the style property to set in DOM-accessor format
      //		("borderWidth", not "border-width") or an object with key/value
      //		pairs suitable for setting each property.
      // value: String?
      //		If passed, sets value on the node for style, handling
      //		cross-browser concerns.  When setting a pixel value,
      //		be sure to include "px" in the value. For instance, top: "200px".
      //		Otherwise, in some cases, some browsers will not apply the style.
      //
      // example:
      //		Passing a node, a style property, and a value changes the
      //		current display of the node and returns the new computed value
      //	|	require(["dojo/dom-style"], function(domStyle){
      //	|		domStyle.set("thinger", "opacity", 0.5); // == 0.5
      //	|	});
      //
      // example:
      //		Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
      //	|	require(["dojo/dom-style"], function(domStyle){
      //	|		domStyle.set("thinger", {
      //	|			"opacity": 0.5,
      //	|			"border": "3px solid black",
      //	|			"height": "300px"
      //	|		});
      //	|	});
      //
      // example:
      //		When the CSS style property is hyphenated, the JavaScript property is camelCased.
      //		font-size becomes fontSize, and so on.
      //	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
      //	|		domStyle.set("thinger",{
      //	|			fontSize:"14pt",
      //	|			letterSpacing:"1.2em"
      //	|		});
      //	|	});
      //
      // example:
      //		dojo/NodeList implements .style() using the same syntax, omitting the "node" parameter, calling
      //		dojo/dom-style.get() on every element of the list. See: `dojo/query` and `dojo/NodeList`
      //	|	require(["dojo/dom-style", "dojo/query", "dojo/NodeList-dom"],
      //	|	function(domStyle, query){
      //	|		query(".someClassName").style("visibility","hidden");
      //	|		// or
      //	|		query("#baz > div").style({
      //	|			opacity:0.75,
      //	|			fontSize:"13pt"
      //	|		});
      //	|	});
      var n = dom.byId(node), l = arguments.length, op = name == 'opacity';
      name = _floatAliases[name] ? 'cssFloat' in n.style ? 'cssFloat' : 'styleFloat' : name;
      if (l == 3) {
        return op ? _setOpacity(n, value) : n.style[name] = value;  // Number
      }
      for (var x in name) {
        style.set(node, x, name[x]);
      }
      return style.getComputedStyle(n);
    };
    return style;
  }(dojo_sniff, dojo_dom);
  dojo_dom_geometry = function (has, win, dom, style) {
    // module:
    //		dojo/dom-geometry
    // the result object
    var geom = {};
    // Box functions will assume this model.
    // On IE/Opera, BORDER_BOX will be set if the primary document is in quirks mode.
    // Can be set to change behavior of box setters.
    // can be either:
    //	"border-box"
    //	"content-box" (default)
    geom.boxModel = 'content-box';
    // We punt per-node box mode testing completely.
    // If anybody cares, we can provide an additional (optional) unit
    // that overrides existing code to include per-node box sensitivity.
    // Opera documentation claims that Opera 9 uses border-box in BackCompat mode.
    // but experiments (Opera 9.10.8679 on Windows Vista) indicate that it actually continues to use content-box.
    // IIRC, earlier versions of Opera did in fact use border-box.
    // Opera guys, this is really confusing. Opera being broken in quirks mode is not our fault.
    if (has('ie')  /*|| has("opera")*/) {
      // client code may have to adjust if compatMode varies across iframes
      geom.boxModel = document.compatMode == 'BackCompat' ? 'border-box' : 'content-box';
    }
    geom.getPadExtents = function getPadExtents(node, computedStyle) {
      // summary:
      //		Returns object with special values specifically useful for node
      //		fitting.
      // description:
      //		Returns an object with `w`, `h`, `l`, `t` properties:
      //	|		l/t/r/b = left/top/right/bottom padding (respectively)
      //	|		w = the total of the left and right padding
      //	|		h = the total of the top and bottom padding
      //		If 'node' has position, l/t forms the origin for child nodes.
      //		The w/h are used for calculating boxes.
      //		Normally application code will not need to invoke this
      //		directly, and will use the ...box... functions instead.
      // node: DOMNode
      // computedStyle: Object?
      //		This parameter accepts computed styles object.
      //		If this parameter is omitted, the functions will call
      //		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
      //		dojo/dom-style.getComputedStyle once, and then pass the reference to this
      //		computedStyle parameter. Wherever possible, reuse the returned
      //		object of dojo/dom-style.getComputedStyle().
      node = dom.byId(node);
      var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue, l = px(node, s.paddingLeft), t = px(node, s.paddingTop), r = px(node, s.paddingRight), b = px(node, s.paddingBottom);
      return {
        l: l,
        t: t,
        r: r,
        b: b,
        w: l + r,
        h: t + b
      };
    };
    var none = 'none';
    geom.getBorderExtents = function getBorderExtents(node, computedStyle) {
      // summary:
      //		returns an object with properties useful for noting the border
      //		dimensions.
      // description:
      //		- l/t/r/b = the sum of left/top/right/bottom border (respectively)
      //		- w = the sum of the left and right border
      //		- h = the sum of the top and bottom border
      //
      //		The w/h are used for calculating boxes.
      //		Normally application code will not need to invoke this
      //		directly, and will use the ...box... functions instead.
      // node: DOMNode
      // computedStyle: Object?
      //		This parameter accepts computed styles object.
      //		If this parameter is omitted, the functions will call
      //		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
      //		dojo/dom-style.getComputedStyle once, and then pass the reference to this
      //		computedStyle parameter. Wherever possible, reuse the returned
      //		object of dojo/dom-style.getComputedStyle().
      node = dom.byId(node);
      var px = style.toPixelValue, s = computedStyle || style.getComputedStyle(node), l = s.borderLeftStyle != none ? px(node, s.borderLeftWidth) : 0, t = s.borderTopStyle != none ? px(node, s.borderTopWidth) : 0, r = s.borderRightStyle != none ? px(node, s.borderRightWidth) : 0, b = s.borderBottomStyle != none ? px(node, s.borderBottomWidth) : 0;
      return {
        l: l,
        t: t,
        r: r,
        b: b,
        w: l + r,
        h: t + b
      };
    };
    geom.getPadBorderExtents = function getPadBorderExtents(node, computedStyle) {
      // summary:
      //		Returns object with properties useful for box fitting with
      //		regards to padding.
      // description:
      //		- l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)
      //		- w = the sum of the left and right padding and border
      //		- h = the sum of the top and bottom padding and border
      //
      //		The w/h are used for calculating boxes.
      //		Normally application code will not need to invoke this
      //		directly, and will use the ...box... functions instead.
      // node: DOMNode
      // computedStyle: Object?
      //		This parameter accepts computed styles object.
      //		If this parameter is omitted, the functions will call
      //		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
      //		dojo/dom-style.getComputedStyle once, and then pass the reference to this
      //		computedStyle parameter. Wherever possible, reuse the returned
      //		object of dojo/dom-style.getComputedStyle().
      node = dom.byId(node);
      var s = computedStyle || style.getComputedStyle(node), p = geom.getPadExtents(node, s), b = geom.getBorderExtents(node, s);
      return {
        l: p.l + b.l,
        t: p.t + b.t,
        r: p.r + b.r,
        b: p.b + b.b,
        w: p.w + b.w,
        h: p.h + b.h
      };
    };
    geom.getMarginExtents = function getMarginExtents(node, computedStyle) {
      // summary:
      //		returns object with properties useful for box fitting with
      //		regards to box margins (i.e., the outer-box).
      //
      //		- l/t = marginLeft, marginTop, respectively
      //		- w = total width, margin inclusive
      //		- h = total height, margin inclusive
      //
      //		The w/h are used for calculating boxes.
      //		Normally application code will not need to invoke this
      //		directly, and will use the ...box... functions instead.
      // node: DOMNode
      // computedStyle: Object?
      //		This parameter accepts computed styles object.
      //		If this parameter is omitted, the functions will call
      //		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
      //		dojo/dom-style.getComputedStyle once, and then pass the reference to this
      //		computedStyle parameter. Wherever possible, reuse the returned
      //		object of dojo/dom-style.getComputedStyle().
      node = dom.byId(node);
      var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue, l = px(node, s.marginLeft), t = px(node, s.marginTop), r = px(node, s.marginRight), b = px(node, s.marginBottom);
      return {
        l: l,
        t: t,
        r: r,
        b: b,
        w: l + r,
        h: t + b
      };
    };
    // Box getters work in any box context because offsetWidth/clientWidth
    // are invariant wrt box context
    //
    // They do *not* work for display: inline objects that have padding styles
    // because the user agent ignores padding (it's bogus styling in any case)
    //
    // Be careful with IMGs because they are inline or block depending on
    // browser and browser mode.
    // Although it would be easier to read, there are not separate versions of
    // _getMarginBox for each browser because:
    // 1. the branching is not expensive
    // 2. factoring the shared code wastes cycles (function call overhead)
    // 3. duplicating the shared code wastes bytes
    geom.getMarginBox = function getMarginBox(node, computedStyle) {
      // summary:
      //		returns an object that encodes the width, height, left and top
      //		positions of the node's margin box.
      // node: DOMNode
      // computedStyle: Object?
      //		This parameter accepts computed styles object.
      //		If this parameter is omitted, the functions will call
      //		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
      //		dojo/dom-style.getComputedStyle once, and then pass the reference to this
      //		computedStyle parameter. Wherever possible, reuse the returned
      //		object of dojo/dom-style.getComputedStyle().
      node = dom.byId(node);
      var s = computedStyle || style.getComputedStyle(node), me = geom.getMarginExtents(node, s), l = node.offsetLeft - me.l, t = node.offsetTop - me.t, p = node.parentNode, px = style.toPixelValue, pcs;
      if (has('mozilla')) {
        // Mozilla:
        // If offsetParent has a computed overflow != visible, the offsetLeft is decreased
        // by the parent's border.
        // We don't want to compute the parent's style, so instead we examine node's
        // computed left/top which is more stable.
        var sl = parseFloat(s.left), st = parseFloat(s.top);
        if (!isNaN(sl) && !isNaN(st)) {
          l = sl;
          t = st;
        } else {
          // If child's computed left/top are not parseable as a number (e.g. "auto"), we
          // have no choice but to examine the parent's computed style.
          if (p && p.style) {
            pcs = style.getComputedStyle(p);
            if (pcs.overflow != 'visible') {
              l += pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
              t += pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
            }
          }
        }
      } else if (has('opera') || has('ie') == 8 && !has('quirks')) {
        // On Opera and IE 8, offsetLeft/Top includes the parent's border
        if (p) {
          pcs = style.getComputedStyle(p);
          l -= pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
          t -= pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
        }
      }
      return {
        l: l,
        t: t,
        w: node.offsetWidth + me.w,
        h: node.offsetHeight + me.h
      };
    };
    geom.getContentBox = function getContentBox(node, computedStyle) {
      // summary:
      //		Returns an object that encodes the width, height, left and top
      //		positions of the node's content box, irrespective of the
      //		current box model.
      // node: DOMNode
      // computedStyle: Object?
      //		This parameter accepts computed styles object.
      //		If this parameter is omitted, the functions will call
      //		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
      //		dojo/dom-style.getComputedStyle once, and then pass the reference to this
      //		computedStyle parameter. Wherever possible, reuse the returned
      //		object of dojo/dom-style.getComputedStyle().
      // clientWidth/Height are important since the automatically account for scrollbars
      // fallback to offsetWidth/Height for special cases (see #3378)
      node = dom.byId(node);
      var s = computedStyle || style.getComputedStyle(node), w = node.clientWidth, h, pe = geom.getPadExtents(node, s), be = geom.getBorderExtents(node, s);
      if (!w) {
        w = node.offsetWidth;
        h = node.offsetHeight;
      } else {
        h = node.clientHeight;
        be.w = be.h = 0;
      }
      // On Opera, offsetLeft includes the parent's border
      if (has('opera')) {
        pe.l += be.l;
        pe.t += be.t;
      }
      return {
        l: pe.l,
        t: pe.t,
        w: w - pe.w - be.w,
        h: h - pe.h - be.h
      };
    };
    // Box setters depend on box context because interpretation of width/height styles
    // vary wrt box context.
    //
    // The value of boxModel is used to determine box context.
    // boxModel can be set directly to change behavior.
    //
    // Beware of display: inline objects that have padding styles
    // because the user agent ignores padding (it's a bogus setup anyway)
    //
    // Be careful with IMGs because they are inline or block depending on
    // browser and browser mode.
    //
    // Elements other than DIV may have special quirks, like built-in
    // margins or padding, or values not detectable via computedStyle.
    // In particular, margins on TABLE do not seems to appear
    // at all in computedStyle on Mozilla.
    function setBox(node, l, t, w, h, u) {
      // summary:
      //		sets width/height/left/top in the current (native) box-model
      //		dimensions. Uses the unit passed in u.
      // node:
      //		DOM Node reference. Id string not supported for performance
      //		reasons.
      // l:
      //		left offset from parent.
      // t:
      //		top offset from parent.
      // w:
      //		width in current box model.
      // h:
      //		width in current box model.
      // u:
      //		unit measure to use for other measures. Defaults to "px".
      u = u || 'px';
      var s = node.style;
      if (!isNaN(l)) {
        s.left = l + u;
      }
      if (!isNaN(t)) {
        s.top = t + u;
      }
      if (w >= 0) {
        s.width = w + u;
      }
      if (h >= 0) {
        s.height = h + u;
      }
    }
    function isButtonTag(node) {
      // summary:
      //		True if the node is BUTTON or INPUT.type="button".
      return node.tagName.toLowerCase() == 'button' || node.tagName.toLowerCase() == 'input' && (node.getAttribute('type') || '').toLowerCase() == 'button';  // boolean
    }
    function usesBorderBox(node) {
      // summary:
      //		True if the node uses border-box layout.
      // We could test the computed style of node to see if a particular box
      // has been specified, but there are details and we choose not to bother.
      // TABLE and BUTTON (and INPUT type=button) are always border-box by default.
      // If you have assigned a different box to either one via CSS then
      // box functions will break.
      return geom.boxModel == 'border-box' || node.tagName.toLowerCase() == 'table' || isButtonTag(node);  // boolean
    }
    geom.setContentSize = function setContentSize(node, box, computedStyle) {
      // summary:
      //		Sets the size of the node's contents, irrespective of margins,
      //		padding, or borders.
      // node: DOMNode
      // box: Object
      //		hash with optional "w", and "h" properties for "width", and "height"
      //		respectively. All specified properties should have numeric values in whole pixels.
      // computedStyle: Object?
      //		This parameter accepts computed styles object.
      //		If this parameter is omitted, the functions will call
      //		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
      //		dojo/dom-style.getComputedStyle once, and then pass the reference to this
      //		computedStyle parameter. Wherever possible, reuse the returned
      //		object of dojo/dom-style.getComputedStyle().
      node = dom.byId(node);
      var w = box.w, h = box.h;
      if (usesBorderBox(node)) {
        var pb = geom.getPadBorderExtents(node, computedStyle);
        if (w >= 0) {
          w += pb.w;
        }
        if (h >= 0) {
          h += pb.h;
        }
      }
      setBox(node, NaN, NaN, w, h);
    };
    var nilExtents = {
      l: 0,
      t: 0,
      w: 0,
      h: 0
    };
    geom.setMarginBox = function setMarginBox(node, box, computedStyle) {
      // summary:
      //		sets the size of the node's margin box and placement
      //		(left/top), irrespective of box model. Think of it as a
      //		passthrough to setBox that handles box-model vagaries for
      //		you.
      // node: DOMNode
      // box: Object
      //		hash with optional "l", "t", "w", and "h" properties for "left", "right", "width", and "height"
      //		respectively. All specified properties should have numeric values in whole pixels.
      // computedStyle: Object?
      //		This parameter accepts computed styles object.
      //		If this parameter is omitted, the functions will call
      //		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
      //		dojo/dom-style.getComputedStyle once, and then pass the reference to this
      //		computedStyle parameter. Wherever possible, reuse the returned
      //		object of dojo/dom-style.getComputedStyle().
      node = dom.byId(node);
      var s = computedStyle || style.getComputedStyle(node), w = box.w, h = box.h,
        // Some elements have special padding, margin, and box-model settings.
        // To use box functions you may need to set padding, margin explicitly.
        // Controlling box-model is harder, in a pinch you might set dojo/dom-geometry.boxModel.
        pb = usesBorderBox(node) ? nilExtents : geom.getPadBorderExtents(node, s), mb = geom.getMarginExtents(node, s);
      if (has('webkit')) {
        // on Safari (3.1.2), button nodes with no explicit size have a default margin
        // setting an explicit size eliminates the margin.
        // We have to swizzle the width to get correct margin reading.
        if (isButtonTag(node)) {
          var ns = node.style;
          if (w >= 0 && !ns.width) {
            ns.width = '4px';
          }
          if (h >= 0 && !ns.height) {
            ns.height = '4px';
          }
        }
      }
      if (w >= 0) {
        w = Math.max(w - pb.w - mb.w, 0);
      }
      if (h >= 0) {
        h = Math.max(h - pb.h - mb.h, 0);
      }
      setBox(node, box.l, box.t, w, h);
    };
    // =============================
    // Positioning
    // =============================
    geom.isBodyLtr = function isBodyLtr(doc) {
      // summary:
      //		Returns true if the current language is left-to-right, and false otherwise.
      // doc: Document?
      //		Optional document to query.   If unspecified, use win.doc.
      // returns: Boolean
      doc = doc || win.doc;
      return (win.body(doc).dir || doc.documentElement.dir || 'ltr').toLowerCase() == 'ltr';  // Boolean
    };
    geom.docScroll = function docScroll(doc) {
      // summary:
      //		Returns an object with {node, x, y} with corresponding offsets.
      // doc: Document?
      //		Optional document to query.   If unspecified, use win.doc.
      // returns: Object
      doc = doc || win.doc;
      var node = win.doc.parentWindow || win.doc.defaultView;
      // use UI window, not dojo.global window.   TODO: use dojo/window::get() except for circular dependency problem
      return 'pageXOffset' in node ? {
        x: node.pageXOffset,
        y: node.pageYOffset
      } : (node = has('quirks') ? win.body(doc) : doc.documentElement) && {
        x: geom.fixIeBiDiScrollLeft(node.scrollLeft || 0, doc),
        y: node.scrollTop || 0
      };
    };
    if (has('ie')) {
      geom.getIeDocumentElementOffset = function getIeDocumentElementOffset(doc) {
        // summary:
        //		returns the offset in x and y from the document body to the
        //		visual edge of the page for IE
        // doc: Document?
        //		Optional document to query.   If unspecified, use win.doc.
        // description:
        //		The following values in IE contain an offset:
        //	|		event.clientX
        //	|		event.clientY
        //	|		node.getBoundingClientRect().left
        //	|		node.getBoundingClientRect().top
        //		But other position related values do not contain this offset,
        //		such as node.offsetLeft, node.offsetTop, node.style.left and
        //		node.style.top. The offset is always (2, 2) in LTR direction.
        //		When the body is in RTL direction, the offset counts the width
        //		of left scroll bar's width.  This function computes the actual
        //		offset.
        //NOTE: assumes we're being called in an IE browser
        doc = doc || win.doc;
        var de = doc.documentElement;
        // only deal with HTML element here, position() handles body/quirks
        if (has('ie') < 8) {
          var r = de.getBoundingClientRect(),
            // works well for IE6+
            l = r.left, t = r.top;
          if (has('ie') < 7) {
            l += de.clientLeft;
            // scrollbar size in strict/RTL, or,
            t += de.clientTop;  // HTML border size in strict
          }
          return {
            x: l < 0 ? 0 : l,
            // FRAME element border size can lead to inaccurate negative values
            y: t < 0 ? 0 : t
          };
        } else {
          return {
            x: 0,
            y: 0
          };
        }
      };
    }
    geom.fixIeBiDiScrollLeft = function fixIeBiDiScrollLeft(scrollLeft, doc) {
      // summary:
      //		In RTL direction, scrollLeft should be a negative value, but IE
      //		returns a positive one. All codes using documentElement.scrollLeft
      //		must call this function to fix this error, otherwise the position
      //		will offset to right when there is a horizontal scrollbar.
      // scrollLeft: Number
      // doc: Document?
      //		Optional document to query.   If unspecified, use win.doc.
      // returns: Number
      // In RTL direction, scrollLeft should be a negative value, but IE
      // returns a positive one. All codes using documentElement.scrollLeft
      // must call this function to fix this error, otherwise the position
      // will offset to right when there is a horizontal scrollbar.
      doc = doc || win.doc;
      var ie = has('ie');
      if (ie && !geom.isBodyLtr(doc)) {
        var qk = has('quirks'), de = qk ? win.body(doc) : doc.documentElement, pwin = win.global;
        // TODO: use winUtils.get(doc) after resolving circular dependency b/w dom-geometry.js and dojo/window.js
        if (ie == 6 && !qk && pwin.frameElement && de.scrollHeight > de.clientHeight) {
          scrollLeft += de.clientLeft;  // workaround ie6+strict+rtl+iframe+vertical-scrollbar bug where clientWidth is too small by clientLeft pixels
        }
        return ie < 8 || qk ? scrollLeft + de.clientWidth - de.scrollWidth : -scrollLeft;  // Integer
      }
      return scrollLeft;  // Integer
    };
    geom.position = function (node, includeScroll) {
      // summary:
      //		Gets the position and size of the passed element relative to
      //		the viewport (if includeScroll==false), or relative to the
      //		document root (if includeScroll==true).
      //
      // description:
      //		Returns an object of the form:
      //		`{ x: 100, y: 300, w: 20, h: 15 }`.
      //		If includeScroll==true, the x and y values will include any
      //		document offsets that may affect the position relative to the
      //		viewport.
      //		Uses the border-box model (inclusive of border and padding but
      //		not margin).  Does not act as a setter.
      // node: DOMNode|String
      // includeScroll: Boolean?
      // returns: Object
      node = dom.byId(node);
      var db = win.body(node.ownerDocument), ret = node.getBoundingClientRect();
      ret = {
        x: ret.left,
        y: ret.top,
        w: ret.right - ret.left,
        h: ret.bottom - ret.top
      };
      if (has('ie') < 9) {
        // On IE<9 there's a 2px offset that we need to adjust for, see dojo.getIeDocumentElementOffset()
        var offset = geom.getIeDocumentElementOffset(node.ownerDocument);
        // fixes the position in IE, quirks mode
        ret.x -= offset.x + (has('quirks') ? db.clientLeft + db.offsetLeft : 0);
        ret.y -= offset.y + (has('quirks') ? db.clientTop + db.offsetTop : 0);
      }
      // account for document scrolling
      // if offsetParent is used, ret value already includes scroll position
      // so we may have to actually remove that value if !includeScroll
      if (includeScroll) {
        var scroll = geom.docScroll(node.ownerDocument);
        ret.x += scroll.x;
        ret.y += scroll.y;
      }
      return ret;  // Object
    };
    // random "private" functions wildly used throughout the toolkit
    geom.getMarginSize = function getMarginSize(node, computedStyle) {
      // summary:
      //		returns an object that encodes the width and height of
      //		the node's margin box
      // node: DOMNode|String
      // computedStyle: Object?
      //		This parameter accepts computed styles object.
      //		If this parameter is omitted, the functions will call
      //		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
      //		dojo/dom-style.getComputedStyle once, and then pass the reference to this
      //		computedStyle parameter. Wherever possible, reuse the returned
      //		object of dojo/dom-style.getComputedStyle().
      node = dom.byId(node);
      var me = geom.getMarginExtents(node, computedStyle || style.getComputedStyle(node));
      var size = node.getBoundingClientRect();
      return {
        w: size.right - size.left + me.w,
        h: size.bottom - size.top + me.h
      };
    };
    geom.normalizeEvent = function (event) {
      // summary:
      //		Normalizes the geometry of a DOM event, normalizing the pageX, pageY,
      //		offsetX, offsetY, layerX, and layerX properties
      // event: Object
      if (!('layerX' in event)) {
        event.layerX = event.offsetX;
        event.layerY = event.offsetY;
      }
      if (!has('dom-addeventlistener')) {
        // old IE version
        // FIXME: scroll position query is duped from dojo/_base/html to
        // avoid dependency on that entire module. Now that HTML is in
        // Base, we should convert back to something similar there.
        var se = event.target;
        var doc = se && se.ownerDocument || document;
        // DO NOT replace the following to use dojo/_base/window.body(), in IE, document.documentElement should be used
        // here rather than document.body
        var docBody = has('quirks') ? doc.body : doc.documentElement;
        var offset = geom.getIeDocumentElementOffset(doc);
        event.pageX = event.clientX + geom.fixIeBiDiScrollLeft(docBody.scrollLeft || 0, doc) - offset.x;
        event.pageY = event.clientY + (docBody.scrollTop || 0) - offset.y;
      }
    };
    // TODO: evaluate separate getters/setters for position and sizes?
    return geom;
  }(dojo_sniff, dojo__base_window, dojo_dom, dojo_dom_style);
  dojo__base_event = function (dojo, on, has, dom) {
    // module:
    //		dojo/_base/event
    if (on._fixEvent) {
      var fixEvent = on._fixEvent;
      on._fixEvent = function (evt, se) {
        // add some additional normalization for back-compat, this isn't in on.js because it is somewhat more expensive
        evt = fixEvent(evt, se);
        if (evt) {
          dom.normalizeEvent(evt);
        }
        return evt;
      };
    }
    var ret = {
      // summary:
      //		This module defines dojo DOM event API.   Usually you should use dojo/on, and evt.stopPropagation() +
      //		evt.preventDefault(), rather than this module.
      fix: function (evt, sender) {
        // summary:
        //		normalizes properties on the event object including event
        //		bubbling methods, keystroke normalization, and x/y positions
        // evt: Event
        //		native event object
        // sender: DOMNode
        //		node to treat as "currentTarget"
        if (on._fixEvent) {
          return on._fixEvent(evt, sender);
        }
        return evt;  // Event
      },
      stop: function (evt) {
        // summary:
        //		prevents propagation and clobbers the default action of the
        //		passed event
        // evt: Event
        //		The event object. If omitted, window.event is used on IE.
        if (has('dom-addeventlistener') || evt && typeof evt.preventDefault === 'function') {
          //PATCHED
          try {
            evt.preventDefault();
            evt.stopPropagation();
          } catch (e) {
            console.warn('Failed to stop event propagation');
          }
        } else {
          evt = evt || window.event;
          evt.cancelBubble = true;
          on._preventDefault.call(evt);
        }
      }
    };
    if (has('extend-dojo')) {
      dojo.fixEvent = ret.fix;
      dojo.stopEvent = ret.stop;
    }
    return ret;
  }(dojo__base_kernel, dojo_on, dojo_has, dojo_dom_geometry);
  dojo_errors_create = function (lang) {
    return function (name, ctor, base, props) {
      base = base || Error;
      var ErrorCtor = function (message) {
        if (base === Error) {
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, ErrorCtor);
          }
          // Error.call() operates on the returned error
          // object rather than operating on |this|
          var err = Error.call(this, message), prop;
          // Copy own properties from err to |this|
          for (prop in err) {
            if (err.hasOwnProperty(prop)) {
              this[prop] = err[prop];
            }
          }
          // messsage is non-enumerable in ES5
          this.message = message;
          // stack is non-enumerable in at least Firefox
          this.stack = err.stack;
        } else {
          base.apply(this, arguments);
        }
        if (ctor) {
          ctor.apply(this, arguments);
        }
      };
      ErrorCtor.prototype = lang.delegate(base.prototype, props);
      ErrorCtor.prototype.name = name;
      ErrorCtor.prototype.constructor = ErrorCtor;
      return ErrorCtor;
    };
  }(dojo__base_lang);
  dojo_errors_CancelError = function (create) {
    // module:
    //		dojo/errors/CancelError
    /*=====
    	return function(){
    		// summary:
    		//		Default error if a promise is canceled without a reason.
    	};
    	=====*/
    return create('CancelError', null, null, { dojoType: 'cancel' });
  }(dojo_errors_create);
  dojo_promise_Promise = function (lang) {
    // module:
    //		dojo/promise/Promise
    function throwAbstract() {
      throw new TypeError('abstract');
    }
    return lang.extend(function Promise() {
    }, {
      then: function (callback, errback, progback) {
        // summary:
        //		Add new callbacks to the promise.
        // description:
        //		Add new callbacks to the deferred. Callbacks can be added
        //		before or after the deferred is fulfilled.
        // callback: Function?
        //		Callback to be invoked when the promise is resolved.
        //		Receives the resolution value.
        // errback: Function?
        //		Callback to be invoked when the promise is rejected.
        //		Receives the rejection error.
        // progback: Function?
        //		Callback to be invoked when the promise emits a progress
        //		update. Receives the progress update.
        // returns: dojo/promise/Promise
        //		Returns a new promise for the result of the callback(s).
        //		This can be used for chaining many asynchronous operations.
        throwAbstract();
      },
      cancel: function (reason, strict) {
        // summary:
        //		Inform the deferred it may cancel its asynchronous operation.
        // description:
        //		Inform the deferred it may cancel its asynchronous operation.
        //		The deferred's (optional) canceler is invoked and the
        //		deferred will be left in a rejected state. Can affect other
        //		promises that originate with the same deferred.
        // reason: any
        //		A message that may be sent to the deferred's canceler,
        //		explaining why it's being canceled.
        // strict: Boolean?
        //		If strict, will throw an error if the deferred has already
        //		been fulfilled and consequently cannot be canceled.
        // returns: any
        //		Returns the rejection reason if the deferred was canceled
        //		normally.
        throwAbstract();
      },
      isResolved: function () {
        // summary:
        //		Checks whether the promise has been resolved.
        // returns: Boolean
        throwAbstract();
      },
      isRejected: function () {
        // summary:
        //		Checks whether the promise has been rejected.
        // returns: Boolean
        throwAbstract();
      },
      isFulfilled: function () {
        // summary:
        //		Checks whether the promise has been resolved or rejected.
        // returns: Boolean
        throwAbstract();
      },
      isCanceled: function () {
        // summary:
        //		Checks whether the promise has been canceled.
        // returns: Boolean
        throwAbstract();
      },
      always: function (callbackOrErrback) {
        // summary:
        //		Add a callback to be invoked when the promise is resolved
        //		or rejected.
        // callbackOrErrback: Function?
        //		A function that is used both as a callback and errback.
        // returns: dojo/promise/Promise
        //		Returns a new promise for the result of the callback/errback.
        return this.then(callbackOrErrback, callbackOrErrback);
      },
      otherwise: function (errback) {
        // summary:
        //		Add new errbacks to the promise.
        // errback: Function?
        //		Callback to be invoked when the promise is rejected.
        // returns: dojo/promise/Promise
        //		Returns a new promise for the result of the errback.
        return this.then(null, errback);
      },
      trace: function () {
        return this;
      },
      traceRejected: function () {
        return this;
      },
      toString: function () {
        // returns: string
        //		Returns `[object Promise]`.
        return '[object Promise]';
      }
    });
  }(dojo__base_lang);
  dojo_Deferred = function (has, lang, CancelError, Promise, instrumentation) {
    // module:
    //		dojo/Deferred
    var PROGRESS = 0, RESOLVED = 1, REJECTED = 2;
    var FULFILLED_ERROR_MESSAGE = 'This deferred has already been fulfilled.';
    var freezeObject = Object.freeze || function () {
    };
    var signalWaiting = function (waiting, type, result, rejection, deferred) {
      if (false) {
        if (type === REJECTED && Deferred.instrumentRejected && waiting.length === 0) {
          Deferred.instrumentRejected(result, false, rejection, deferred);
        }
      }
      for (var i = 0; i < waiting.length; i++) {
        signalListener(waiting[i], type, result, rejection);
      }
    };
    var signalListener = function (listener, type, result, rejection) {
      var func = listener[type];
      var deferred = listener.deferred;
      if (func) {
        try {
          var newResult = func(result);
          if (type === PROGRESS) {
            if (typeof newResult !== 'undefined') {
              signalDeferred(deferred, type, newResult);
            }
          } else {
            if (newResult && typeof newResult.then === 'function') {
              listener.cancel = newResult.cancel;
              newResult.then(// Only make resolvers if they're actually going to be used
              makeDeferredSignaler(deferred, RESOLVED), makeDeferredSignaler(deferred, REJECTED), makeDeferredSignaler(deferred, PROGRESS));
              return;
            }
            signalDeferred(deferred, RESOLVED, newResult);
          }
        } catch (error) {
          signalDeferred(deferred, REJECTED, error);
        }
      } else {
        signalDeferred(deferred, type, result);
      }
      if (false) {
        if (type === REJECTED && Deferred.instrumentRejected) {
          Deferred.instrumentRejected(result, !!func, rejection, deferred.promise);
        }
      }
    };
    var makeDeferredSignaler = function (deferred, type) {
      return function (value) {
        signalDeferred(deferred, type, value);
      };
    };
    var signalDeferred = function (deferred, type, result) {
      if (!deferred.isCanceled()) {
        switch (type) {
        case PROGRESS:
          deferred.progress(result);
          break;
        case RESOLVED:
          deferred.resolve(result);
          break;
        case REJECTED:
          deferred.reject(result);
          break;
        }
      }
    };
    var Deferred = function (canceler) {
      // summary:
      //		Creates a new deferred. This API is preferred over
      //		`dojo/_base/Deferred`.
      // description:
      //		Creates a new deferred, as an abstraction over (primarily)
      //		asynchronous operations. The deferred is the private interface
      //		that should not be returned to calling code. That's what the
      //		`promise` is for. See `dojo/promise/Promise`.
      // canceler: Function?
      //		Will be invoked if the deferred is canceled. The canceler
      //		receives the reason the deferred was canceled as its argument.
      //		The deferred is rejected with its return value, or a new
      //		`dojo/errors/CancelError` instance.
      // promise: dojo/promise/Promise
      //		The public promise object that clients can add callbacks to. 
      var promise = this.promise = new Promise();
      var deferred = this;
      var fulfilled, result, rejection;
      var canceled = false;
      var waiting = [];
      if (false && Error.captureStackTrace) {
        Error.captureStackTrace(deferred, Deferred);
        Error.captureStackTrace(promise, Deferred);
      }
      this.isResolved = promise.isResolved = function () {
        // summary:
        //		Checks whether the deferred has been resolved.
        // returns: Boolean
        return fulfilled === RESOLVED;
      };
      this.isRejected = promise.isRejected = function () {
        // summary:
        //		Checks whether the deferred has been rejected.
        // returns: Boolean
        return fulfilled === REJECTED;
      };
      this.isFulfilled = promise.isFulfilled = function () {
        // summary:
        //		Checks whether the deferred has been resolved or rejected.
        // returns: Boolean
        return !!fulfilled;
      };
      this.isCanceled = promise.isCanceled = function () {
        // summary:
        //		Checks whether the deferred has been canceled.
        // returns: Boolean
        return canceled;
      };
      this.progress = function (update, strict) {
        // summary:
        //		Emit a progress update on the deferred.
        // description:
        //		Emit a progress update on the deferred. Progress updates
        //		can be used to communicate updates about the asynchronous
        //		operation before it has finished.
        // update: any
        //		The progress update. Passed to progbacks.
        // strict: Boolean?
        //		If strict, will throw an error if the deferred has already
        //		been fulfilled and consequently no progress can be emitted.
        // returns: dojo/promise/Promise
        //		Returns the original promise for the deferred.
        if (!fulfilled) {
          signalWaiting(waiting, PROGRESS, update, null, deferred);
          return promise;
        } else if (strict === true) {
          throw new Error(FULFILLED_ERROR_MESSAGE);
        } else {
          return promise;
        }
      };
      this.resolve = function (value, strict) {
        // summary:
        //		Resolve the deferred.
        // description:
        //		Resolve the deferred, putting it in a success state.
        // value: any
        //		The result of the deferred. Passed to callbacks.
        // strict: Boolean?
        //		If strict, will throw an error if the deferred has already
        //		been fulfilled and consequently cannot be resolved.
        // returns: dojo/promise/Promise
        //		Returns the original promise for the deferred.
        if (!fulfilled) {
          // Set fulfilled, store value. After signaling waiting listeners unset
          // waiting.
          signalWaiting(waiting, fulfilled = RESOLVED, result = value, null, deferred);
          waiting = null;
          return promise;
        } else if (strict === true) {
          throw new Error(FULFILLED_ERROR_MESSAGE);
        } else {
          return promise;
        }
      };
      var reject = this.reject = function (error, strict) {
        // summary:
        //		Reject the deferred.
        // description:
        //		Reject the deferred, putting it in an error state.
        // error: any
        //		The error result of the deferred. Passed to errbacks.
        // strict: Boolean?
        //		If strict, will throw an error if the deferred has already
        //		been fulfilled and consequently cannot be rejected.
        // returns: dojo/promise/Promise
        //		Returns the original promise for the deferred.
        if (!fulfilled) {
          if (false && Error.captureStackTrace) {
            Error.captureStackTrace(rejection = {}, reject);
          }
          signalWaiting(waiting, fulfilled = REJECTED, result = error, rejection, deferred);
          waiting = null;
          return promise;
        } else if (strict === true) {
          throw new Error(FULFILLED_ERROR_MESSAGE);
        } else {
          return promise;
        }
      };
      this.then = promise.then = function (callback, errback, progback) {
        // summary:
        //		Add new callbacks to the deferred.
        // description:
        //		Add new callbacks to the deferred. Callbacks can be added
        //		before or after the deferred is fulfilled.
        // callback: Function?
        //		Callback to be invoked when the promise is resolved.
        //		Receives the resolution value.
        // errback: Function?
        //		Callback to be invoked when the promise is rejected.
        //		Receives the rejection error.
        // progback: Function?
        //		Callback to be invoked when the promise emits a progress
        //		update. Receives the progress update.
        // returns: dojo/promise/Promise
        //		Returns a new promise for the result of the callback(s).
        //		This can be used for chaining many asynchronous operations.
        var listener = [
          progback,
          callback,
          errback
        ];
        // Ensure we cancel the promise we're waiting for, or if callback/errback
        // have returned a promise, cancel that one.
        listener.cancel = promise.cancel;
        listener.deferred = new Deferred(function (reason) {
          // Check whether cancel is really available, returned promises are not
          // required to expose `cancel`
          return listener.cancel && listener.cancel(reason);
        });
        if (fulfilled && !waiting) {
          signalListener(listener, fulfilled, result, rejection);
        } else {
          waiting.push(listener);
        }
        return listener.deferred.promise;
      };
      this.cancel = promise.cancel = function (reason, strict) {
        // summary:
        //		Inform the deferred it may cancel its asynchronous operation.
        // description:
        //		Inform the deferred it may cancel its asynchronous operation.
        //		The deferred's (optional) canceler is invoked and the
        //		deferred will be left in a rejected state. Can affect other
        //		promises that originate with the same deferred.
        // reason: any
        //		A message that may be sent to the deferred's canceler,
        //		explaining why it's being canceled.
        // strict: Boolean?
        //		If strict, will throw an error if the deferred has already
        //		been fulfilled and consequently cannot be canceled.
        // returns: any
        //		Returns the rejection reason if the deferred was canceled
        //		normally.
        if (!fulfilled) {
          // Cancel can be called even after the deferred is fulfilled
          if (canceler) {
            var returnedReason = canceler(reason);
            reason = typeof returnedReason === 'undefined' ? reason : returnedReason;
          }
          canceled = true;
          if (!fulfilled) {
            // Allow canceler to provide its own reason, but fall back to a CancelError
            if (typeof reason === 'undefined') {
              reason = new CancelError();
            }
            reject(reason);
            return reason;
          } else if (fulfilled === REJECTED && result === reason) {
            return reason;
          }
        } else if (strict === true) {
          throw new Error(FULFILLED_ERROR_MESSAGE);
        }
      };
      freezeObject(promise);
    };
    Deferred.prototype.toString = function () {
      // returns: String
      //		Returns `[object Deferred]`.
      return '[object Deferred]';
    };
    if (instrumentation) {
      instrumentation(Deferred);
    }
    return Deferred;
  }(dojo_has, dojo__base_lang, dojo_errors_CancelError, dojo_promise_Promise, 0 /* removed ./has!config-deferredInstrumentation?./promise/instrumentation */);
  dojo_aspect = function () {
    var undefined, nextId = 0;
    function advise(dispatcher, type, advice, receiveArguments) {
      var previous = dispatcher[type];
      var around = type == 'around';
      var signal;
      if (around) {
        var advised = advice(function () {
          return previous.advice(this, arguments);
        });
        signal = {
          remove: function () {
            if (advised) {
              advised = dispatcher = advice = null;
            }
          },
          advice: function (target, args) {
            return advised ? advised.apply(target, args) : // called the advised function
            previous.advice(target, args);  // cancelled, skip to next one
          }
        };
      } else {
        // create the remove handler
        signal = {
          remove: function () {
            if (signal.advice) {
              var previous = signal.previous;
              var next = signal.next;
              if (!next && !previous) {
                delete dispatcher[type];
              } else {
                if (previous) {
                  previous.next = next;
                } else {
                  dispatcher[type] = next;
                }
                if (next) {
                  next.previous = previous;
                }
              }
              // remove the advice to signal that this signal has been removed
              dispatcher = advice = signal.advice = null;
            }
          },
          id: nextId++,
          advice: advice,
          receiveArguments: receiveArguments
        };
      }
      if (previous && !around) {
        if (type == 'after') {
          // add the listener to the end of the list
          // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug
          while (previous.next && (previous = previous.next)) {
          }
          previous.next = signal;
          signal.previous = previous;
        } else if (type == 'before') {
          // add to beginning
          dispatcher[type] = signal;
          signal.next = previous;
          previous.previous = signal;
        }
      } else {
        // around or first one just replaces
        dispatcher[type] = signal;
      }
      return signal;
    }
    function aspect(type) {
      return function (target, methodName, advice, receiveArguments) {
        var existing = target[methodName], dispatcher;
        if (!existing || existing.target != target) {
          // no dispatcher in place
          target[methodName] = dispatcher = function () {
            var executionId = nextId;
            // before advice
            var args = arguments;
            var before = dispatcher.before;
            while (before) {
              args = before.advice.apply(this, args) || args;
              before = before.next;
            }
            // around advice
            if (dispatcher.around) {
              var results = dispatcher.around.advice(this, args);
            }
            // after advice
            var after = dispatcher.after;
            while (after && after.id < executionId) {
              if (after.receiveArguments) {
                var newResults = after.advice.apply(this, args);
                // change the return value only if a new value was returned
                results = newResults === undefined ? results : newResults;
              } else {
                results = after.advice.call(this, results, args);
              }
              after = after.next;
            }
            return results;
          };
          if (existing) {
            dispatcher.around = {
              advice: function (target, args) {
                return existing.apply(target, args);
              }
            };
          }
          dispatcher.target = target;
        }
        var results = advise(dispatcher || existing, type, advice, receiveArguments);
        advice = null;
        return results;
      };
    }
    // TODOC: after/before/around return object
    var after = aspect('after');
    /*=====
    	after = function(target, methodName, advice, receiveArguments){
    		// summary:
    		//		The "after" export of the aspect module is a function that can be used to attach
    		//		"after" advice to a method. This function will be executed after the original method
    		//		is executed. By default the function will be called with a single argument, the return
    		//		value of the original method, or the the return value of the last executed advice (if a previous one exists).
    		//		The fourth (optional) argument can be set to true to so the function receives the original
    		//		arguments (from when the original method was called) rather than the return value.
    		//		If there are multiple "after" advisors, they are executed in the order they were registered.
    		// target: Object
    		//		This is the target object
    		// methodName: String
    		//		This is the name of the method to attach to.
    		// advice: Function
    		//		This is function to be called after the original method
    		// receiveArguments: Boolean?
    		//		If this is set to true, the advice function receives the original arguments (from when the original mehtod
    		//		was called) rather than the return value of the original/previous method.
    		// returns:
    		//		A signal object that can be used to cancel the advice. If remove() is called on this signal object, it will
    		//		stop the advice function from being executed.
    	};
    	=====*/
    var before = aspect('before');
    /*=====
    	before = function(target, methodName, advice){
    		// summary:
    		//		The "before" export of the aspect module is a function that can be used to attach
    		//		"before" advice to a method. This function will be executed before the original method
    		//		is executed. This function will be called with the arguments used to call the method.
    		//		This function may optionally return an array as the new arguments to use to call
    		//		the original method (or the previous, next-to-execute before advice, if one exists).
    		//		If the before method doesn't return anything (returns undefined) the original arguments
    		//		will be preserved.
    		//		If there are multiple "before" advisors, they are executed in the reverse order they were registered.
    		// target: Object
    		//		This is the target object
    		// methodName: String
    		//		This is the name of the method to attach to.
    		// advice: Function
    		//		This is function to be called before the original method
    	};
    	=====*/
    var around = aspect('around');
    /*=====
    	 around = function(target, methodName, advice){
    		// summary:
    		//		The "around" export of the aspect module is a function that can be used to attach
    		//		"around" advice to a method. The advisor function is immediately executed when
    		//		the around() is called, is passed a single argument that is a function that can be
    		//		called to continue execution of the original method (or the next around advisor).
    		//		The advisor function should return a function, and this function will be called whenever
    		//		the method is called. It will be called with the arguments used to call the method.
    		//		Whatever this function returns will be returned as the result of the method call (unless after advise changes it).
    		// example:
    		//		If there are multiple "around" advisors, the most recent one is executed first,
    		//		which can then delegate to the next one and so on. For example:
    		//		|	around(obj, "foo", function(originalFoo){
    		//		|		return function(){
    		//		|			var start = new Date().getTime();
    		//		|			var results = originalFoo.apply(this, arguments); // call the original
    		//		|			var end = new Date().getTime();
    		//		|			console.log("foo execution took " + (end - start) + " ms");
    		//		|			return results;
    		//		|		};
    		//		|	});
    		// target: Object
    		//		This is the target object
    		// methodName: String
    		//		This is the name of the method to attach to.
    		// advice: Function
    		//		This is function to be called around the original method
    	};
    	=====*/
    return {
      // summary:
      //		provides aspect oriented programming functionality, allowing for
      //		one to add before, around, or after advice on existing methods.
      // example:
      //	|	define(["dojo/aspect"], function(aspect){
      //	|		var signal = aspect.after(targetObject, "methodName", function(someArgument){
      //	|			this will be called when targetObject.methodName() is called, after the original function is called
      //	|		});
      //
      // example:
      //	The returned signal object can be used to cancel the advice.
      //	|	signal.remove(); // this will stop the advice from being executed anymore
      //	|	aspect.before(targetObject, "methodName", function(someArgument){
      //	|		// this will be called when targetObject.methodName() is called, before the original function is called
      //	|	 });
      before: before,
      around: around,
      after: after
    };
  }();
  dojo_regexp = function (dojo, lang) {
    // module:
    //		dojo/regexp
    var regexp = {};
    lang.setObject('dojo.regexp', regexp);
    regexp.escapeString = function (str, except) {
      // summary:
      //		Adds escape sequences for special characters in regular expressions
      // except:
      //		a String with special characters to be left unescaped
      return str.replace(/([\.$?*|{}\(\)\[\]\\\/\+\-^])/g, function (ch) {
        if (except && except.indexOf(ch) != -1) {
          return ch;
        }
        return '\\' + ch;
      });  // String
    };
    regexp.buildGroupRE = function (arr, re, nonCapture) {
      // summary:
      //		Builds a regular expression that groups subexpressions
      // description:
      //		A utility function used by some of the RE generators. The
      //		subexpressions are constructed by the function, re, in the second
      //		parameter.  re builds one subexpression for each elem in the array
      //		a, in the first parameter. Returns a string for a regular
      //		expression that groups all the subexpressions.
      // arr:
      //		A single value or an array of values.
      // re:
      //		A function. Takes one parameter and converts it to a regular
      //		expression.
      // nonCapture:
      //		If true, uses non-capturing match, otherwise matches are retained
      //		by regular expression. Defaults to false
      // case 1: a is a single value.
      if (!(arr instanceof Array)) {
        return re(arr);  // String
      }
      // case 2: a is an array
      var b = [];
      for (var i = 0; i < arr.length; i++) {
        // convert each elem to a RE
        b.push(re(arr[i]));
      }
      // join the REs as alternatives in a RE group.
      return regexp.group(b.join('|'), nonCapture);  // String
    };
    regexp.group = function (expression, nonCapture) {
      // summary:
      //		adds group match to expression
      // nonCapture:
      //		If true, uses non-capturing match, otherwise matches are retained
      //		by regular expression.
      return '(' + (nonCapture ? '?:' : '') + expression + ')';  // String
    };
    return regexp;
  }(dojo__base_kernel, dojo__base_lang);
  dojo_cookie = function (dojo, regexp) {
    // module:
    //		dojo/cookie
    /*=====
    var __cookieProps = {
    	// expires: Date|String|Number?
    	//		If a number, the number of days from today at which the cookie
    	//		will expire. If a date, the date past which the cookie will expire.
    	//		If expires is in the past, the cookie will be deleted.
    	//		If expires is omitted or is 0, the cookie will expire when the browser closes.
    	// path: String?
    	//		The path to use for the cookie.
    	// domain: String?
    	//		The domain to use for the cookie.
    	// secure: Boolean?
    	//		Whether to only send the cookie on secure connections
    };
    =====*/
    dojo.cookie = function (name, value, props) {
      // summary:
      //		Get or set a cookie.
      // description:
      //		If one argument is passed, returns the value of the cookie
      //		For two or more arguments, acts as a setter.
      // name:
      //		Name of the cookie
      // value:
      //		Value for the cookie
      // props:
      //		Properties for the cookie
      // example:
      //		set a cookie with the JSON-serialized contents of an object which
      //		will expire 5 days from now:
      //	|	require(["dojo/cookie", "dojo/json"], function(cookie, json){
      //	|		cookie("configObj", json.stringify(config, {expires: 5 }));
      //	|	});
      //
      // example:
      //		de-serialize a cookie back into a JavaScript object:
      //	|	require(["dojo/cookie", "dojo/json"], function(cookie, json){
      //	|		config = json.parse(cookie("configObj"));
      //	|	});
      //
      // example:
      //		delete a cookie:
      //	|	require(["dojo/cookie"], function(cookie){
      //	|		cookie("configObj", null, {expires: -1});
      //	|	});
      var c = document.cookie, ret;
      if (arguments.length == 1) {
        var matches = c.match(new RegExp('(?:^|; )' + regexp.escapeString(name) + '=([^;]*)'));
        ret = matches ? decodeURIComponent(matches[1]) : undefined;
      } else {
        props = props || {};
        // FIXME: expires=0 seems to disappear right away, not on close? (FF3)  Change docs?
        var exp = props.expires;
        if (typeof exp == 'number') {
          var d = new Date();
          d.setTime(d.getTime() + exp * 24 * 60 * 60 * 1000);
          exp = props.expires = d;
        }
        if (exp && exp.toUTCString) {
          props.expires = exp.toUTCString();
        }
        value = encodeURIComponent(value);
        var updatedCookie = name + '=' + value, propName;
        for (propName in props) {
          updatedCookie += '; ' + propName;
          var propValue = props[propName];
          if (propValue !== true) {
            updatedCookie += '=' + propValue;
          }
        }
        document.cookie = updatedCookie;
      }
      return ret;  // String|undefined
    };
    dojo.cookie.isSupported = function () {
      // summary:
      //		Use to determine if the current browser supports cookies or not.
      //
      //		Returns true if user allows cookies.
      //		Returns false if user doesn't allow cookies.
      if (!('cookieEnabled' in navigator)) {
        this('__djCookieTest__', 'CookiesAllowed');
        navigator.cookieEnabled = this('__djCookieTest__') == 'CookiesAllowed';
        if (navigator.cookieEnabled) {
          this('__djCookieTest__', '', { expires: -1 });
        }
      }
      return navigator.cookieEnabled;
    };
    return dojo.cookie;
  }(dojo__base_kernel, dojo_regexp);
  dojo_errors_RequestError = function (create) {
    // module:
    //		dojo/errors/RequestError
    /*=====
    return function(){
     // summary:
     //		TODOC
    };
    =====*/
    return create('RequestError', function (message, response) {
      this.response = response;
    });
  }(dojo_errors_create);
  dojo_io_query = function (lang) {
    // module:
    //		dojo/io-query
    var backstop = {};
    return {
      // summary:
      //		This module defines query string processing functions.
      objectToQuery: function objectToQuery(map) {
        // summary:
        //		takes a name/value mapping object and returns a string representing
        //		a URL-encoded version of that object.
        // example:
        //		this object:
        //
        //	|	{
        //	|		blah: "blah",
        //	|		multi: [
        //	|			"thud",
        //	|			"thonk"
        //	|		]
        //	|	};
        //
        //		yields the following query string:
        //
        //	|	"blah=blah&multi=thud&multi=thonk"
        // FIXME: need to implement encodeAscii!!
        var enc = encodeURIComponent, pairs = [];
        for (var name in map) {
          var value = map[name];
          if (value != backstop[name]) {
            var assign = enc(name) + '=';
            if (lang.isArray(value)) {
              for (var i = 0, l = value.length; i < l; ++i) {
                pairs.push(assign + enc(value[i]));
              }
            } else {
              pairs.push(assign + enc(value));
            }
          }
        }
        return pairs.join('&');  // String
      },
      queryToObject: function queryToObject(str) {
        // summary:
        //		Create an object representing a de-serialized query section of a
        //		URL. Query keys with multiple values are returned in an array.
        //
        // example:
        //		This string:
        //
        //	|		"foo=bar&foo=baz&thinger=%20spaces%20=blah&zonk=blarg&"
        //
        //		results in this object structure:
        //
        //	|		{
        //	|			foo: [ "bar", "baz" ],
        //	|			thinger: " spaces =blah",
        //	|			zonk: "blarg"
        //	|		}
        //
        //		Note that spaces and other urlencoded entities are correctly
        //		handled.
        // FIXME: should we grab the URL string if we're not passed one?
        var dec = decodeURIComponent, qp = str.split('&'), ret = {}, name, val;
        for (var i = 0, l = qp.length, item; i < l; ++i) {
          item = qp[i];
          if (item.length) {
            var s = item.indexOf('=');
            if (s < 0) {
              name = dec(item);
              val = '';
            } else {
              name = dec(item.slice(0, s));
              val = dec(item.slice(s + 1));
            }
            if (typeof ret[name] == 'string') {
              // inline'd type check
              ret[name] = [ret[name]];
            }
            if (lang.isArray(ret[name])) {
              ret[name].push(val);
            } else {
              ret[name] = val;
            }
          }
        }
        return ret;  // Object
      }
    };
  }(dojo__base_lang);
  dojo__base_array = function (dojo, has, lang) {
    // module:
    //		dojo/_base/array
    // our old simple function builder stuff
    var cache = {}, u;
    function buildFn(fn) {
      return cache[fn] = new Function('item', 'index', 'array', fn);  // Function
    }
    // magic snippet: if(typeof fn == "string") fn = cache[fn] || buildFn(fn);
    // every & some
    function everyOrSome(some) {
      var every = !some;
      return function (a, fn, o) {
        var i = 0, l = a && a.length || 0, result;
        if (l && typeof a == 'string')
          a = a.split('');
        if (typeof fn == 'string')
          fn = cache[fn] || buildFn(fn);
        if (o) {
          for (; i < l; ++i) {
            result = !fn.call(o, a[i], i, a);
            if (some ^ result) {
              return !result;
            }
          }
        } else {
          for (; i < l; ++i) {
            result = !fn(a[i], i, a);
            if (some ^ result) {
              return !result;
            }
          }
        }
        return every;  // Boolean
      };
    }
    // indexOf, lastIndexOf
    function index(up) {
      var delta = 1, lOver = 0, uOver = 0;
      if (!up) {
        delta = lOver = uOver = -1;
      }
      return function (a, x, from, last) {
        if (last && delta > 0) {
          // TODO: why do we use a non-standard signature? why do we need "last"?
          return array.lastIndexOf(a, x, from);
        }
        var l = a && a.length || 0, end = up ? l + uOver : lOver, i;
        if (from === u) {
          i = up ? lOver : l + uOver;
        } else {
          if (from < 0) {
            i = l + from;
            if (i < 0) {
              i = lOver;
            }
          } else {
            i = from >= l ? l + uOver : from;
          }
        }
        if (l && typeof a == 'string')
          a = a.split('');
        for (; i != end; i += delta) {
          if (a[i] == x) {
            return i;  // Number
          }
        }
        return -1;  // Number
      };
    }
    var array = {
      // summary:
      //		The Javascript v1.6 array extensions.
      every: everyOrSome(false),
      /*=====
       every: function(arr, callback, thisObject){
      	 // summary:
      	 //		Determines whether or not every item in arr satisfies the
      	 //		condition implemented by callback.
      	 // arr: Array|String
      	 //		the array to iterate on. If a string, operates on individual characters.
      	 // callback: Function|String
      	 //		a function is invoked with three arguments: item, index,
      	 //		and array and returns true if the condition is met.
      	 // thisObject: Object?
      	 //		may be used to scope the call to callback
      	 // returns: Boolean
      	 // description:
      	 //		This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
      	 //		run over sparse arrays, this implementation passes the "holes" in the sparse array to
      	 //		the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
      	 //		For more details, see:
      	 //		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
      	 // example:
      	 //	|	// returns false
      	 //	|	array.every([1, 2, 3, 4], function(item){ return item>1; });
      	 // example:
      	 //	|	// returns true
      	 //	|	array.every([1, 2, 3, 4], function(item){ return item>0; });
       },
       =====*/
      some: everyOrSome(true),
      /*=====
      some: function(arr, callback, thisObject){
      	// summary:
      	//		Determines whether or not any item in arr satisfies the
      	//		condition implemented by callback.
      	// arr: Array|String
      	//		the array to iterate over. If a string, operates on individual characters.
      	// callback: Function|String
      	//		a function is invoked with three arguments: item, index,
      	//		and array and returns true if the condition is met.
      	// thisObject: Object?
      	//		may be used to scope the call to callback
      	// returns: Boolean
      	// description:
      	//		This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
      	//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
      	//		the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
      	//		For more details, see:
      	//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
      	// example:
      	//	| // is true
      	//	| array.some([1, 2, 3, 4], function(item){ return item>1; });
      	// example:
      	//	| // is false
      	//	| array.some([1, 2, 3, 4], function(item){ return item<1; });
      },
      =====*/
      indexOf: index(true),
      /*=====
      indexOf: function(arr, value, fromIndex, findLast){
      	// summary:
      	//		locates the first index of the provided value in the
      	//		passed array. If the value is not found, -1 is returned.
      	// description:
      	//		This method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:
      	//
      	//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
      	//		   whereas JavaScript 1.6's indexOf skips the holes in the sparse array.
      	//		2. uses equality (==) rather than strict equality (===)
      	//
      	//		For details on this method, see:
      	//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf
      	// arr: Array
      	// value: Object
      	// fromIndex: Integer?
      	// findLast: Boolean?
      	//		Makes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.
      	// returns: Number
      },
      =====*/
      lastIndexOf: index(false),
      /*=====
      lastIndexOf: function(arr, value, fromIndex){
      	// summary:
      	//		locates the last index of the provided value in the passed
      	//		array. If the value is not found, -1 is returned.
      	// description:
       	//		This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:
       	//
       	//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
       	//		   whereas JavaScript 1.6's lasIndexOf skips the holes in the sparse array.
       	//		2. uses equality (==) rather than strict equality (===)
       	//
       	//		For details on this method, see:
       	//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf
      	// arr: Array,
      	// value: Object,
      	// fromIndex: Integer?
      	// returns: Number
      },
      =====*/
      forEach: function (arr, callback, thisObject) {
        // summary:
        //		for every item in arr, callback is invoked. Return values are ignored.
        //		If you want to break out of the loop, consider using array.every() or array.some().
        //		forEach does not allow breaking out of the loop over the items in arr.
        // arr:
        //		the array to iterate over. If a string, operates on individual characters.
        // callback:
        //		a function is invoked with three arguments: item, index, and array
        // thisObject:
        //		may be used to scope the call to callback
        // description:
        //		This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
        //		run over sparse arrays, this implementation passes the "holes" in the sparse array to
        //		the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
        //		For more details, see:
        //		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
        // example:
        //	| // log out all members of the array:
        //	| array.forEach(
        //	|		[ "thinger", "blah", "howdy", 10 ],
        //	|		function(item){
        //	|			console.log(item);
        //	|		}
        //	| );
        // example:
        //	| // log out the members and their indexes
        //	| array.forEach(
        //	|		[ "thinger", "blah", "howdy", 10 ],
        //	|		function(item, idx, arr){
        //	|			console.log(item, "at index:", idx);
        //	|		}
        //	| );
        // example:
        //	| // use a scoped object member as the callback
        //	|
        //	| var obj = {
        //	|		prefix: "logged via obj.callback:",
        //	|		callback: function(item){
        //	|			console.log(this.prefix, item);
        //	|		}
        //	| };
        //	|
        //	| // specifying the scope function executes the callback in that scope
        //	| array.forEach(
        //	|		[ "thinger", "blah", "howdy", 10 ],
        //	|		obj.callback,
        //	|		obj
        //	| );
        //	|
        //	| // alternately, we can accomplish the same thing with lang.hitch()
        //	| array.forEach(
        //	|		[ "thinger", "blah", "howdy", 10 ],
        //	|		lang.hitch(obj, "callback")
        //	| );
        // arr: Array|String
        // callback: Function|String
        // thisObject: Object?
        var i = 0, l = arr && arr.length || 0;
        if (l && typeof arr == 'string')
          arr = arr.split('');
        if (typeof callback == 'string')
          callback = cache[callback] || buildFn(callback);
        if (thisObject) {
          for (; i < l; ++i) {
            callback.call(thisObject, arr[i], i, arr);
          }
        } else {
          for (; i < l; ++i) {
            callback(arr[i], i, arr);
          }
        }
      },
      map: function (arr, callback, thisObject, Ctr) {
        // summary:
        //		applies callback to each element of arr and returns
        //		an Array with the results
        // arr: Array|String
        //		the array to iterate on. If a string, operates on
        //		individual characters.
        // callback: Function|String
        //		a function is invoked with three arguments, (item, index,
        //		array),	 and returns a value
        // thisObject: Object?
        //		may be used to scope the call to callback
        // returns: Array
        // description:
        //		This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
        //		run over sparse arrays, this implementation passes the "holes" in the sparse array to
        //		the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
        //		For more details, see:
        //		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
        // example:
        //	| // returns [2, 3, 4, 5]
        //	| array.map([1, 2, 3, 4], function(item){ return item+1 });
        // TODO: why do we have a non-standard signature here? do we need "Ctr"?
        var i = 0, l = arr && arr.length || 0, out = new (Ctr || Array)(l);
        if (l && typeof arr == 'string')
          arr = arr.split('');
        if (typeof callback == 'string')
          callback = cache[callback] || buildFn(callback);
        if (thisObject) {
          for (; i < l; ++i) {
            out[i] = callback.call(thisObject, arr[i], i, arr);
          }
        } else {
          for (; i < l; ++i) {
            out[i] = callback(arr[i], i, arr);
          }
        }
        return out;  // Array
      },
      filter: function (arr, callback, thisObject) {
        // summary:
        //		Returns a new Array with those items from arr that match the
        //		condition implemented by callback.
        // arr: Array
        //		the array to iterate over.
        // callback: Function|String
        //		a function that is invoked with three arguments (item,
        //		index, array). The return of this function is expected to
        //		be a boolean which determines whether the passed-in item
        //		will be included in the returned array.
        // thisObject: Object?
        //		may be used to scope the call to callback
        // returns: Array
        // description:
        //		This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
        //		run over sparse arrays, this implementation passes the "holes" in the sparse array to
        //		the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
        //		For more details, see:
        //		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
        // example:
        //	| // returns [2, 3, 4]
        //	| array.filter([1, 2, 3, 4], function(item){ return item>1; });
        // TODO: do we need "Ctr" here like in map()?
        var i = 0, l = arr && arr.length || 0, out = [], value;
        if (l && typeof arr == 'string')
          arr = arr.split('');
        if (typeof callback == 'string')
          callback = cache[callback] || buildFn(callback);
        if (thisObject) {
          for (; i < l; ++i) {
            value = arr[i];
            if (callback.call(thisObject, value, i, arr)) {
              out.push(value);
            }
          }
        } else {
          for (; i < l; ++i) {
            value = arr[i];
            if (callback(value, i, arr)) {
              out.push(value);
            }
          }
        }
        return out;  // Array
      },
      clearCache: function () {
        cache = {};
      }
    };
    has('extend-dojo') && lang.mixin(dojo, array);
    return array;
  }(dojo__base_kernel, dojo_has, dojo__base_lang);
  dojo_request_util = function (exports, RequestError, CancelError, Deferred, ioQuery, array, lang, Promise) {
    exports.deepCopy = function deepCopy(target, source) {
      for (var name in source) {
        var tval = target[name], sval = source[name];
        if (tval !== sval) {
          if (tval && typeof tval === 'object' && sval && typeof sval === 'object') {
            exports.deepCopy(tval, sval);
          } else {
            target[name] = sval;
          }
        }
      }
      return target;
    };
    exports.deepCreate = function deepCreate(source, properties) {
      properties = properties || {};
      var target = lang.delegate(source), name, value;
      for (name in source) {
        value = source[name];
        if (value && typeof value === 'object') {
          target[name] = exports.deepCreate(value, properties[name]);
        }
      }
      return exports.deepCopy(target, properties);
    };
    var freeze = Object.freeze || function (obj) {
      return obj;
    };
    function okHandler(response) {
      return freeze(response);
    }
    function dataHandler(response) {
      return response.data || response.text;
    }
    exports.deferred = function deferred(response, cancel, isValid, isReady, handleResponse, last) {
      var def = new Deferred(function (reason) {
        cancel && cancel(def, response);
        if (!reason || !(reason instanceof RequestError) && !(reason instanceof CancelError)) {
          return new CancelError('Request canceled', response);
        }
        return reason;
      });
      def.response = response;
      def.isValid = isValid;
      def.isReady = isReady;
      def.handleResponse = handleResponse;
      function errHandler(error) {
        error.response = response;
        throw error;
      }
      var responsePromise = def.then(okHandler).otherwise(errHandler);
      if (exports.notify) {
        responsePromise.then(lang.hitch(exports.notify, 'emit', 'load'), lang.hitch(exports.notify, 'emit', 'error'));
      }
      var dataPromise = responsePromise.then(dataHandler);
      // http://bugs.dojotoolkit.org/ticket/16794
      // The following works around a leak in IE9 through the
      // prototype using lang.delegate on dataPromise and
      // assigning the result a property with a reference to
      // responsePromise.
      var promise = new Promise();
      for (var prop in dataPromise) {
        if (dataPromise.hasOwnProperty(prop)) {
          promise[prop] = dataPromise[prop];
        }
      }
      promise.response = responsePromise;
      freeze(promise);
      // End leak fix
      if (last) {
        def.then(function (response) {
          last.call(def, response);
        }, function (error) {
          last.call(def, response, error);
        });
      }
      def.promise = promise;
      def.then = promise.then;
      return def;
    };
    exports.addCommonMethods = function addCommonMethods(provider, methods) {
      array.forEach(methods || [
        'GET',
        'POST',
        'PUT',
        'DELETE'
      ], function (method) {
        provider[(method === 'DELETE' ? 'DEL' : method).toLowerCase()] = function (url, options) {
          options = lang.delegate(options || {});
          options.method = method;
          return provider(url, options);
        };
      });
    };
    exports.parseArgs = function parseArgs(url, options, skipData) {
      var data = options.data, query = options.query;
      if (data && !skipData) {
        if (typeof data === 'object') {
          options.data = ioQuery.objectToQuery(data);
        }
      }
      if (query) {
        if (typeof query === 'object') {
          query = ioQuery.objectToQuery(query);
        }
        if (options.preventCache) {
          query += (query ? '&' : '') + 'request.preventCache=' + +new Date();
        }
      } else if (options.preventCache) {
        query = 'request.preventCache=' + +new Date();
      }
      if (url && query) {
        url += (~url.indexOf('?') ? '&' : '?') + query;
      }
      return {
        url: url,
        options: options,
        getHeader: function (headerName) {
          return null;
        }
      };
    };
    exports.checkStatus = function (stat) {
      stat = stat || 0;
      return stat >= 200 && stat < 300 || // allow any 2XX response code
      stat === 304 || // or, get it out of the cache
      stat === 1223 || // or, Internet Explorer mangled the status code
      !stat;  // or, we're Titanium/browser chrome/chrome extension requesting a local file
    };
    return exports;
  }(dojo_request_util, dojo_errors_RequestError, dojo_errors_CancelError, dojo_Deferred, dojo_io_query, dojo__base_array, dojo__base_lang, dojo_promise_Promise);
  dojo_errors_RequestTimeoutError = function (create, RequestError) {
    // module:
    //		dojo/errors/RequestTimeoutError
    /*=====
    return function(){
     // summary:
     //		TODOC
    };
    =====*/
    return create('RequestTimeoutError', null, RequestError, { dojoType: 'timeout' });
  }(dojo_errors_create, dojo_errors_RequestError);
  dojo_request_watch = function (util, RequestTimeoutError, CancelError, array, win, on) {
    // avoid setting a timer per request. It degrades performance on IE
    // something fierece if we don't use unified loops.
    var _inFlightIntvl = null, _inFlight = [];
    function watchInFlight() {
      // summary:
      //		internal method that checks each inflight XMLHttpRequest to see
      //		if it has completed or if the timeout situation applies.
      var now = +new Date();
      // we need manual loop because we often modify _inFlight (and therefore 'i') while iterating
      for (var i = 0, dfd; i < _inFlight.length && (dfd = _inFlight[i]); i++) {
        var response = dfd.response, options = response.options;
        if (dfd.isCanceled && dfd.isCanceled() || dfd.isValid && !dfd.isValid(response)) {
          _inFlight.splice(i--, 1);
          watch._onAction && watch._onAction();
        } else if (dfd.isReady && dfd.isReady(response)) {
          _inFlight.splice(i--, 1);
          dfd.handleResponse(response);
          watch._onAction && watch._onAction();
        } else if (dfd.startTime) {
          // did we timeout?
          if (dfd.startTime + (options.timeout || 0) < now) {
            _inFlight.splice(i--, 1);
            // Cancel the request so the io module can do appropriate cleanup.
            dfd.cancel(new RequestTimeoutError('Timeout exceeded', response));
            watch._onAction && watch._onAction();
          }
        }
      }
      watch._onInFlight && watch._onInFlight(dfd);
      if (!_inFlight.length) {
        clearInterval(_inFlightIntvl);
        _inFlightIntvl = null;
      }
    }
    function watch(dfd) {
      // summary:
      //		Watches the io request represented by dfd to see if it completes.
      // dfd: Deferred
      //		The Deferred object to watch.
      // response: Object
      //		The object used as the value of the request promise.
      // validCheck: Function
      //		Function used to check if the IO request is still valid. Gets the dfd
      //		object as its only argument.
      // ioCheck: Function
      //		Function used to check if basic IO call worked. Gets the dfd
      //		object as its only argument.
      // resHandle: Function
      //		Function used to process response. Gets the dfd
      //		object as its only argument.
      if (dfd.response.options.timeout) {
        dfd.startTime = +new Date();
      }
      if (dfd.isFulfilled()) {
        // bail out if the deferred is already fulfilled
        return;
      }
      _inFlight.push(dfd);
      if (!_inFlightIntvl) {
        _inFlightIntvl = setInterval(watchInFlight, 50);
      }
      // handle sync requests separately from async:
      // http://bugs.dojotoolkit.org/ticket/8467
      if (dfd.response.options.sync) {
        watchInFlight();
      }
    }
    watch.cancelAll = function cancelAll() {
      // summary:
      //		Cancels all pending IO requests, regardless of IO type
      try {
        array.forEach(_inFlight, function (dfd) {
          try {
            dfd.cancel(new CancelError('All requests canceled.'));
          } catch (e) {
          }
        });
      } catch (e) {
      }
    };
    if (win && on && win.doc.attachEvent) {
      // Automatically call cancel all io calls on unload in IE
      // http://bugs.dojotoolkit.org/ticket/2357
      on(win.global, 'unload', function () {
        watch.cancelAll();
      });
    }
    return watch;
  }(dojo_request_util, dojo_errors_RequestTimeoutError, dojo_errors_CancelError, dojo__base_array, dojo__base_window, dojo_on);
  dojo_json = function (has) {
    var hasJSON = typeof JSON != 'undefined';
    has.add('json-parse', hasJSON);
    // all the parsers work fine
    // Firefox 3.5/Gecko 1.9 fails to use replacer in stringify properly https://bugzilla.mozilla.org/show_bug.cgi?id=509184
    // PATCHED improved detection of JSON.stringify manipulation
    has.add('json-stringify', hasJSON && JSON.stringify([{ a: 0 }], function (k, v) {
      return v || 1;
    }) == '[{"a":1}]');
    // END PATCH
    /*=====
    	return {
    		// summary:
    		//		Functions to parse and serialize JSON
    
    		parse: function(str, strict){
    			// summary:
    			//		Parses a [JSON](http://json.org) string to return a JavaScript object.
    			// description:
    			//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
    			//		Throws for invalid JSON strings. This delegates to eval() if native JSON
    			//		support is not available. By default this will evaluate any valid JS expression.
    			//		With the strict parameter set to true, the parser will ensure that only
    			//		valid JSON strings are parsed (otherwise throwing an error). Without the strict
    			//		parameter, the content passed to this method must come
    			//		from a trusted source.
    			// str:
    			//		a string literal of a JSON item, for instance:
    			//		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`
    			// strict:
    			//		When set to true, this will ensure that only valid, secure JSON is ever parsed.
    			//		Make sure this is set to true for untrusted content. Note that on browsers/engines
    			//		without native JSON support, setting this to true will run slower.
    		},
    		stringify: function(value, replacer, spacer){
    			// summary:
    			//		Returns a [JSON](http://json.org) serialization of an object.
    			// description:
    			//		Returns a [JSON](http://json.org) serialization of an object.
    			//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
    			//		Note that this doesn't check for infinite recursion, so don't do that!
    			// value:
    			//		A value to be serialized.
    			// replacer:
    			//		A replacer function that is called for each value and can return a replacement
    			// spacer:
    			//		A spacer string to be used for pretty printing of JSON
    			// example:
    			//		simple serialization of a trivial object
    			//	|	define(["dojo/json"], function(JSON){
    			// 	|		var jsonStr = JSON.stringify({ howdy: "stranger!", isStrange: true });
    			//	|		doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
    		}
    	};
    	=====*/
    if (has('json-stringify')) {
      return JSON;
    } else {
      var escapeString = function (str) {
        // summary:
        //		Adds escape sequences for non-visual characters, double quote and
        //		backslash and surrounds with double quotes to form a valid string
        //		literal.
        return ('"' + str.replace(/(["\\])/g, '\\$1') + '"').replace(/[\f]/g, '\\f').replace(/[\b]/g, '\\b').replace(/[\n]/g, '\\n').replace(/[\t]/g, '\\t').replace(/[\r]/g, '\\r');  // string
      };
      return {
        parse: has('json-parse') ? JSON.parse : function (str, strict) {
          if (strict && !/^([\s\[\{]*(?:"(?:\\.|[^"])*"|-?\d[\d\.]*(?:[Ee][+-]?\d+)?|null|true|false|)[\s\]\}]*(?:,|:|$))+$/.test(str)) {
            throw new SyntaxError('Invalid characters in JSON');
          }
          return eval('(' + str + ')');
        },
        stringify: function (value, replacer, spacer) {
          var undef;
          if (typeof replacer == 'string') {
            spacer = replacer;
            replacer = null;
          }
          function stringify(it, indent, key) {
            if (replacer) {
              it = replacer(key, it);
            }
            var val, objtype = typeof it;
            if (objtype == 'number') {
              return isFinite(it) ? it + '' : 'null';
            }
            if (objtype == 'boolean') {
              return it + '';
            }
            if (it === null) {
              return 'null';
            }
            if (typeof it == 'string') {
              return escapeString(it);
            }
            if (objtype == 'function' || objtype == 'undefined') {
              return undef;  // undefined
            }
            // short-circuit for objects that support "json" serialization
            // if they return "self" then just pass-through...
            //PATCHED Sometimes Object.toJSON is overwritten (e.g. by prototype.js) and should not be used because the returned JSON is not valid
            //					if(typeof it.toJSON == "function"){
            //						return stringify(it.toJSON(key), indent, key);
            //					}
            // END PATCH
            if (it instanceof Date) {
              return '"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z"'.replace(/\{(\w+)(\+)?\}/g, function (t, prop, plus) {
                var num = it['getUTC' + prop]() + (plus ? 1 : 0);
                return num < 10 ? '0' + num : num;
              });
            }
            if (it.valueOf() !== it) {
              // primitive wrapper, try again unwrapped:
              return stringify(it.valueOf(), indent, key);
            }
            var nextIndent = spacer ? indent + spacer : '';
            /* we used to test for DOM nodes and throw, but FF serializes them as {}, so cross-browser consistency is probably not efficiently attainable */
            var sep = spacer ? ' ' : '';
            var newLine = spacer ? '\n' : '';
            // array
            if (it instanceof Array) {
              var itl = it.length, res = [];
              for (key = 0; key < itl; key++) {
                var obj = it[key];
                val = stringify(obj, nextIndent, key);
                if (typeof val != 'string') {
                  val = 'null';
                }
                res.push(newLine + nextIndent + val);
              }
              return '[' + res.join(',') + newLine + indent + ']';
            }
            // generic object code path
            var output = [];
            for (key in it) {
              var keyStr;
              if (it.hasOwnProperty(key)) {
                if (typeof key == 'number') {
                  keyStr = '"' + key + '"';
                } else if (typeof key == 'string') {
                  keyStr = escapeString(key);
                } else {
                  // skip non-string or number keys
                  continue;
                }
                val = stringify(it[key], nextIndent, key);
                if (typeof val != 'string') {
                  // skip non-serializable values
                  continue;
                }
                // At this point, the most non-IE browsers don't get in this branch
                // (they have native JSON), so push is definitely the way to
                output.push(newLine + nextIndent + keyStr + ':' + sep + val);
              }
            }
            return '{' + output.join(',') + newLine + indent + '}';  // String
          }
          return stringify(value, '', '');
        }
      };
    }
  }(dojo_has);
  dojo_request_handlers = function (JSON, kernel, array, has) {
    has.add('activex', typeof ActiveXObject !== 'undefined');
    has.add('dom-parser', function (global) {
      return 'DOMParser' in global;
    });
    var handleXML;
    if (has('activex')) {
      // GUIDs obtained from http://msdn.microsoft.com/en-us/library/ms757837(VS.85).aspx
      var dp = [
        'Msxml2.DOMDocument.6.0',
        'Msxml2.DOMDocument.4.0',
        'MSXML2.DOMDocument.3.0',
        'MSXML.DOMDocument'  // 2.0
      ];
      var lastParser;
      handleXML = function (response) {
        var result = response.data;
        var text = response.text;
        if (result && has('dom-qsa2.1') && !result.querySelectorAll && has('dom-parser')) {
          // http://bugs.dojotoolkit.org/ticket/15631
          // IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation
          // returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain
          // the fuller-featured implementation and avoid bugs caused by the inconsistency
          result = new DOMParser().parseFromString(text, 'application/xml');
        }
        function createDocument(p) {
          try {
            var dom = new ActiveXObject(p);
            dom.async = false;
            dom.loadXML(text);
            result = dom;
            lastParser = p;
          } catch (e) {
            return false;
          }
          return true;
        }
        if (!result || !result.documentElement) {
          // The creation of an ActiveX object is expensive, so we cache the
          // parser type to avoid trying all parser types each time we handle a
          // document. There is some concern that some parser types might fail
          // depending on the document being parsed. If parsing using the cached
          // parser type fails, we do the more expensive operation of finding one
          // that works for the given document.
          // https://bugs.dojotoolkit.org/ticket/15246
          if (!lastParser || !createDocument(lastParser)) {
            array.some(dp, createDocument);
          }
        }
        return result;
      };
    }
    var handleNativeResponse = function (response) {
      if (!has('native-xhr2-blob') && response.options.handleAs === 'blob' && typeof Blob !== 'undefined') {
        return new Blob([response.xhr.response], { type: response.xhr.getResponseHeader('Content-Type') });
      }
      return response.xhr.response;
    };
    var handlers = {
      'javascript': function (response) {
        return kernel.eval(response.text || '');
      },
      'json': function (response) {
        return JSON.parse(response.text || null);
      },
      'xml': handleXML,
      'blob': handleNativeResponse,
      'arraybuffer': handleNativeResponse,
      'document': handleNativeResponse
    };
    function handle(response) {
      var handler = handlers[response.options.handleAs];
      response.data = handler ? handler(response) : response.data || response.text;
      return response;
    }
    handle.register = function (name, handler) {
      handlers[name] = handler;
    };
    return handle;
  }(dojo_json, dojo__base_kernel, dojo__base_array, dojo_has);
  dojo_request_xhr = function (RequestError, watch, handlers, util, has) {
    has.add('native-xhr', function () {
      // if true, the environment has a native XHR implementation
      return typeof XMLHttpRequest !== 'undefined';
    });
    has.add('dojo-force-activex-xhr', function () {
      return has('activex') && !document.addEventListener && window.location.protocol === 'file:';
    });
    has.add('native-xhr2', function () {
      if (!has('native-xhr')) {
        return;
      }
      var x = new XMLHttpRequest();
      return typeof x['addEventListener'] !== 'undefined' && (typeof opera === 'undefined' || typeof x['upload'] !== 'undefined');
    });
    has.add('native-formdata', function () {
      // if true, the environment has a native FormData implementation
      return typeof FormData !== 'undefined';
    });
    has.add('native-response-type', function () {
      return has('native-xhr') && typeof new XMLHttpRequest().responseType !== 'undefined';
    });
    has.add('native-xhr2-blob', function () {
      if (!has('native-response-type')) {
        return;
      }
      var responseType;
      try {
        var x = new XMLHttpRequest();
        x.open('GET', '/', true);
        x.responseType = 'blob';
        // will not be set if unsupported
        responseType = x.responseType;
        x.abort();
      } catch (e) {
      }
      return responseType === 'blob';
    });
    // Google Chrome doesn't support "json" response type
    // up to version 30, so it's intentionally not included here
    var nativeResponseTypes = {
      'blob': has('native-xhr2-blob') ? 'blob' : 'arraybuffer',
      'document': 'document',
      'arraybuffer': 'arraybuffer'
    };
    function handleResponse(response, error) {
      var _xhr = response.xhr;
      response.status = response.xhr.status;
      try {
        // Firefox throws an error when trying to access
        // xhr.responseText if response isn't text
        response.text = _xhr.responseText;
      } catch (e) {
      }
      if (response.options.handleAs === 'xml') {
        response.data = _xhr.responseXML;
      }
      if (!error) {
        try {
          handlers(response);
        } catch (e) {
          error = e;
        }
      }
      if (error) {
        this.reject(error);
      } else if (util.checkStatus(_xhr.status)) {
        this.resolve(response);
      } else {
        error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);
        this.reject(error);
      }
    }
    var isValid, isReady, addListeners, cancel;
    if (has('native-xhr2')) {
      // Any platform with XHR2 will only use the watch mechanism for timeout.
      isValid = function (response) {
        // summary:
        //		Check to see if the request should be taken out of the watch queue
        return !this.isFulfilled();
      };
      cancel = function (dfd, response) {
        // summary:
        //		Canceler for deferred
        response.xhr.abort();
      };
      addListeners = function (_xhr, dfd, response) {
        // summary:
        //		Adds event listeners to the XMLHttpRequest object
        function onLoad(evt) {
          dfd.handleResponse(response);
        }
        function onError(evt) {
          var _xhr = evt.target;
          var error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);
          dfd.handleResponse(response, error);
        }
        function onProgress(evt) {
          if (evt.lengthComputable) {
            response.loaded = evt.loaded;
            response.total = evt.total;
            dfd.progress(response);
          } else if (response.xhr.readyState === 3) {
            response.loaded = 'loaded' in evt ? evt.loaded : evt.position;
            //PATCHED https://github.com/dojo/dojo/commit/d400e28ad88aca5a3244710ad2ac1d341868d3d7
            dfd.progress(response);
          }
        }
        _xhr.addEventListener('load', onLoad, false);
        _xhr.addEventListener('error', onError, false);
        _xhr.addEventListener('progress', onProgress, false);
        return function () {
          _xhr.removeEventListener('load', onLoad, false);
          _xhr.removeEventListener('error', onError, false);
          _xhr.removeEventListener('progress', onProgress, false);
          _xhr = null;
        };
      };
    } else {
      isValid = function (response) {
        return response.xhr.readyState;  //boolean
      };
      isReady = function (response) {
        return 4 === response.xhr.readyState;  //boolean
      };
      cancel = function (dfd, response) {
        // summary:
        //		canceller function for util.deferred call.
        var xhr = response.xhr;
        var _at = typeof xhr.abort;
        if (_at === 'function' || _at === 'object' || _at === 'unknown') {
          xhr.abort();
        }
      };
    }
    function getHeader(headerName) {
      return this.xhr.getResponseHeader(headerName);
    }
    var undefined, defaultOptions = {
        data: null,
        query: null,
        sync: false,
        method: 'GET'
      };
    function xhr(url, options, returnDeferred) {
      var isFormData = has('native-formdata') && options && options.data && options.data instanceof FormData;
      var response = util.parseArgs(url, util.deepCreate(defaultOptions, options), isFormData);
      url = response.url;
      options = response.options;
      var remover, last = function () {
          remover && remover();
        };
      //Make the Deferred object for this xhr request.
      var dfd = util.deferred(response, cancel, isValid, isReady, handleResponse, last);
      var _xhr = response.xhr = xhr._create();
      if (!_xhr) {
        // If XHR factory somehow returns nothings,
        // cancel the deferred.
        dfd.cancel(new RequestError('XHR was not created'));
        return returnDeferred ? dfd : dfd.promise;
      }
      response.getHeader = getHeader;
      if (addListeners) {
        remover = addListeners(_xhr, dfd, response);
      }
      var data = options.data, async = !options.sync, method = options.method;
      try {
        // IE6 won't let you call apply() on the native function.
        _xhr.open(method, url, async, options.user || undefined, options.password || undefined);
        if (options.withCredentials) {
          _xhr.withCredentials = options.withCredentials;
        }
        if (has('native-response-type') && options.handleAs in nativeResponseTypes) {
          _xhr.responseType = nativeResponseTypes[options.handleAs];
        }
        var headers = options.headers, contentType = isFormData ? false : 'application/x-www-form-urlencoded';
        if (headers) {
          for (var hdr in headers) {
            if (hdr.toLowerCase() === 'content-type') {
              contentType = headers[hdr];
            } else if (headers[hdr]) {
              //Only add header if it has a value. This allows for instance, skipping
              //insertion of X-Requested-With by specifying empty value.
              _xhr.setRequestHeader(hdr, headers[hdr]);
            }
          }
        }
        if (contentType && contentType !== false) {
          _xhr.setRequestHeader('Content-Type', contentType);
        }
        if (!headers || !('X-Requested-With' in headers)) {
          _xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
        }
        if (util.notify) {
          util.notify.emit('send', response, dfd.promise.cancel);
        }
        _xhr.send(data);
      } catch (e) {
        dfd.reject(e);
      }
      watch(dfd);
      _xhr = null;
      return returnDeferred ? dfd : dfd.promise;
    }
    /*=====
    	xhr = function(url, options){
    		// summary:
    		//		Sends a request using XMLHttpRequest with the given URL and options.
    		// url: String
    		//		URL to request
    		// options: dojo/request/xhr.__Options?
    		//		Options for the request.
    		// returns: dojo/request.__Promise
    	};
    	xhr.__BaseOptions = declare(request.__BaseOptions, {
    		// sync: Boolean?
    		//		Whether to make a synchronous request or not. Default
    		//		is `false` (asynchronous).
    		// data: String|Object|FormData?
    		//		Data to transfer. This is ignored for GET and DELETE
    		//		requests.
    		// headers: Object?
    		//		Headers to use for the request.
    		// user: String?
    		//		Username to use during the request.
    		// password: String?
    		//		Password to use during the request.
    		// withCredentials: Boolean?
    		//		For cross-site requests, whether to send credentials
    		//		or not.
    	});
    	xhr.__MethodOptions = declare(null, {
    		// method: String?
    		//		The HTTP method to use to make the request. Must be
    		//		uppercase. Default is `"GET"`.
    	});
    	xhr.__Options = declare([xhr.__BaseOptions, xhr.__MethodOptions]);
    
    	xhr.get = function(url, options){
    		// summary:
    		//		Send an HTTP GET request using XMLHttpRequest with the given URL and options.
    		// url: String
    		//		URL to request
    		// options: dojo/request/xhr.__BaseOptions?
    		//		Options for the request.
    		// returns: dojo/request.__Promise
    	};
    	xhr.post = function(url, options){
    		// summary:
    		//		Send an HTTP POST request using XMLHttpRequest with the given URL and options.
    		// url: String
    		//		URL to request
    		// options: dojo/request/xhr.__BaseOptions?
    		//		Options for the request.
    		// returns: dojo/request.__Promise
    	};
    	xhr.put = function(url, options){
    		// summary:
    		//		Send an HTTP PUT request using XMLHttpRequest with the given URL and options.
    		// url: String
    		//		URL to request
    		// options: dojo/request/xhr.__BaseOptions?
    		//		Options for the request.
    		// returns: dojo/request.__Promise
    	};
    	xhr.del = function(url, options){
    		// summary:
    		//		Send an HTTP DELETE request using XMLHttpRequest with the given URL and options.
    		// url: String
    		//		URL to request
    		// options: dojo/request/xhr.__BaseOptions?
    		//		Options for the request.
    		// returns: dojo/request.__Promise
    	};
    	=====*/
    xhr._create = function () {
      // summary:
      //		does the work of portably generating a new XMLHTTPRequest object.
      throw new Error('XMLHTTP not available');
    };
    if (has('native-xhr') && !has('dojo-force-activex-xhr')) {
      xhr._create = function () {
        return new XMLHttpRequest();
      };
    } else if (has('activex')) {
      try {
        new ActiveXObject('Msxml2.XMLHTTP');
        xhr._create = function () {
          return new ActiveXObject('Msxml2.XMLHTTP');
        };
      } catch (e) {
        try {
          new ActiveXObject('Microsoft.XMLHTTP');
          xhr._create = function () {
            return new ActiveXObject('Microsoft.XMLHTTP');
          };
        } catch (e) {
        }
      }
    }
    util.addCommonMethods(xhr);
    return xhr;
  }(dojo_errors_RequestError, dojo_request_watch, dojo_request_handlers, dojo_request_util, dojo_has);
  dojo_request = function (xhr) {
    return xhr;
  }(dojo_request_xhr);
  synchronite_constants_strings = function () {
    var SYNCHRONITE_WIN_REF = '_$W';
    var strings = {
      // Proxy Parameters
      TARGET_FRAME: 'targetFrame',
      TARGET_PROTOCOL: 'targetProtocol',
      IS_SCRIPT: 'isScript',
      IS_IMAGE: 'isImage',
      IS_XHR: 'isXHR',
      IS_POPUP: 'ispopup',
      DISABLE_CACHE: 'disableCache',
      CACHE_KEY: 'cacheKey',
      PUBLISH: 'publish',
      NO_PROTOCOL_CHANGE: 'noProtocolChange',
      NO_PROXY: 'noProxy',
      LOCALE: 'locale',
      WINDOW_ID: '__cobrowseWindowId',
      // We use this to mark monitored windows
      DATA_ATTR_NO: 'data-no',
      PROP_CHANGE_MONITORED: 'changeMonitored',
      PROP_CLICK_MONITORED: 'cobrowse_cm',
      PROP_KEY_MONITORED: 'cobrowse_km',
      // Synchronite References
      SYNCHRONITE_WIN_REF: SYNCHRONITE_WIN_REF,
      SYNCHRONITE_OBJ_REF: SYNCHRONITE_WIN_REF + '.synch',
      // Window Identifiers
      SYNCHRONIZED_WINDOW: 'displayContent',
      // Servlet Paths
      AJAX_PATH: '/ajax',
      ACCESS_TOKEN_LOGIN_PATH: '/login/access_token'
    };
    return strings;
  }();
  dojox_encoding_base64 = function (lang) {
    var base64 = lang.getObject('dojox.encoding.base64', true);
    var p = '=';
    var tab = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    base64.encode = function (ba) {
      // summary:
      //		Encode an array of bytes as a base64-encoded string
      var s = [], l = ba.length;
      var rm = l % 3;
      var x = l - rm;
      for (var i = 0; i < x;) {
        var t = ba[i++] << 16 | ba[i++] << 8 | ba[i++];
        s.push(tab.charAt(t >>> 18 & 63));
        s.push(tab.charAt(t >>> 12 & 63));
        s.push(tab.charAt(t >>> 6 & 63));
        s.push(tab.charAt(t & 63));
      }
      //	deal with trailers, based on patch from Peter Wood.
      switch (rm) {
      case 2: {
          var t = ba[i++] << 16 | ba[i++] << 8;
          s.push(tab.charAt(t >>> 18 & 63));
          s.push(tab.charAt(t >>> 12 & 63));
          s.push(tab.charAt(t >>> 6 & 63));
          s.push(p);
          break;
        }
      case 1: {
          var t = ba[i++] << 16;
          s.push(tab.charAt(t >>> 18 & 63));
          s.push(tab.charAt(t >>> 12 & 63));
          s.push(p);
          s.push(p);
          break;
        }
      }
      return s.join('');  //	string
    };
    base64.decode = function (str) {
      // summary:
      //		Convert a base64-encoded string to an array of bytes
      var s = str.split(''), out = [];
      var l = s.length;
      while (s[--l] == p) {
      }
      //	strip off trailing padding
      for (var i = 0; i < l;) {
        var t = tab.indexOf(s[i++]) << 18;
        if (i <= l) {
          t |= tab.indexOf(s[i++]) << 12;
        }
        if (i <= l) {
          t |= tab.indexOf(s[i++]) << 6;
        }
        if (i <= l) {
          t |= tab.indexOf(s[i++]);
        }
        out.push(t >>> 16 & 255);
        out.push(t >>> 8 & 255);
        out.push(t & 255);
      }
      //	strip off any null bytes
      while (out[out.length - 1] == 0) {
        out.pop();
      }
      return out;  //	byte[]
    };
    return base64;
  }(dojo__base_lang);
  synchronite__base_base64 = function (base64Coding) {
    // summary: base64 encoder/decoder that converts strings to UTF8 bytes
    // Using UTF-8 Encoding allows better handling of special characters and safe decoding/encoding
    // by server-side components
    var utf8getBytes = function (str) {
        var byteArray = [];
        for (var i = 0; i < str.length; i++) {
          if (str.charCodeAt(i) <= 127) {
            byteArray.push(str.charCodeAt(i));
          } else {
            var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
            for (var j = 0; j < h.length; j++) {
              byteArray.push(parseInt(h[j], 16));
            }
          }
        }
        return byteArray;
      }, utf8toString = function (byteArray) {
        var str = '';
        for (var i = 0; i < byteArray.length; i++) {
          str += byteArray[i] <= 127 ? byteArray[i] === 37 ? '%25' : // %
          String.fromCharCode(byteArray[i]) : '%' + byteArray[i].toString(16).toUpperCase();
        }
        return decodeURIComponent(str);
      };
    var base64 = {
      decode: function (input) {
        var byteArray = base64Coding.decode(input);
        return utf8toString(byteArray);
      },
      encode: function (input) {
        var byteArray = utf8getBytes(input);
        return base64Coding.encode(byteArray);
      },
      encodeChannel: function (input) {
        var reEqual = new RegExp('=', 'g');
        var byteArray = utf8getBytes(input);
        var encoded = base64Coding.encode(byteArray);
        return encoded.replace(reEqual, '');
      }
    };
    return base64;
  }(dojox_encoding_base64);
  synchronite__base_analytics = function (baseArray, lang) {
    var win = window;
    var isFirebugEnabled = function () {
      return !!(win.console && (win.console.firebug || win.console.exception));
    };
    var areDevToolsEnabled = function () {
      // inspired by: https://github.com/sindresorhus/devtools-detect/
      var threshold = 175;
      var dWidth = win.outerWidth - win.innerWidth;
      var dHeight = win.outerHeight - win.innerHeight;
      return dWidth > threshold || dHeight > threshold;
    };
    var isDebuggerEnabled = function () {
      return isFirebugEnabled() || areDevToolsEnabled();
    };
    var referrer = function () {
      var ref = document.referrer;
      if (ref) {
        var decoded = decodeReferrer(ref.toString());
        if (lang.isArray(decoded)) {
          ref = decoded[0] + ': ';
          if (decoded[1]) {
            ref += decoded[1].join(' ');
          }
          return ref;
        }
      } else {
        return '';
      }
    };
    var searchEngines = [
      [
        'google',
        /^http:\/\/(www\.)?google\./i,
        /q=([^&]+)/i
      ],
      // Google
      [
        'yahoo',
        /^http:\/\/(www\.)?search\.yahoo\./i,
        /p=([^&]+)/i
      ],
      // Yahoo
      [
        'msn',
        /^http:\/\/(www\.)?search\.msn\./i,
        /q=([^&]+)/i
      ],
      // MSN
      [
        'msn live',
        /^http:\/\/(www\.)?search\.live\./i,
        /query=([^&]+)/i
      ],
      // MSN Live
      [
        'aol',
        /^http:\/\/(www\.)?search\.aol\./i,
        /userQuery=([^&]+)/i
      ],
      // AOL
      [
        'ask',
        /^http:\/\/(www\.)?ask\.com/i,
        /q=([^&]+)/i
      ],
      // Ask.com
      [
        'altavista',
        /^http:\/\/(www\.)?altavista\./i,
        /q=([^&]+)/i
      ],
      // AltaVista
      [
        'feedster',
        /^http:\/\/(www\.)?feedster\./i,
        /q=([^&]+)/i
      ],
      // Feedster
      [
        'lycos',
        /^http:\/\/(www\.)?search\.lycos\./i,
        /q=([^&]+)/i
      ],
      // Lycos
      [
        'alltheweb',
        /^http:\/\/(www\.)?alltheweb\./i,
        /q=([^&]+)/i
      ],
      // AllTheWeb
      [
        'technorati',
        /^http:\/\/(www\.)?technorati\.com/i,
        /([^\?\/]+)(?:\?.*)$/i
      ]  // Technorati
    ];
    var decodeReferrer = function (URL) {
      URL = decodeURIComponent(URL);
      var result;
      var query;
      baseArray.some(searchEngines, function (n, i) {
        if (n[1].test(URL)) {
          result = [];
          result.push(n[0]);
          //search engine id
          var match = URL.match(n[2]);
          if (match) {
            query = match[1];
            if (query) {
              query = query.replace(/(\'|")/, '$1');
              query = query.split(/[\s,\+\.]+/);
            }
            result.push(query);  //search engine query
          }
        }
        return result;  // returning a value that is truthy aborts the loop
      });
      return result;
    };
    var synchAnalytics = {
      debuggerEnabled: isDebuggerEnabled,
      referrer: referrer
    };
    return synchAnalytics;
  }(dojo__base_array, dojo__base_lang);
  synchronite_integration_visitor_info = function (dojoLang, cookie, request, strings, base64, synchAnalytics) {
    var synchroniteAPI = 'synchronite API';
    var config = synchroniteConfig;
    var SYNCHRONITE_VISITOR_COOKIE_NAME = 's.vis';
    var _resumeVisitor = function () {
        // Check if there was a saved application state
        var state = cookie(SYNCHRONITE_VISITOR_COOKIE_NAME);
        if (state) {
          state = JSON.parse(base64.decode(state));
        }
        // Restore the state, if present. Once set, the visitorId should never change. So
        // we always override the visitorId with the saved value.
        if (state && state.visitorId) {
          visitorId = state.visitorId;
        }
        // Restore saved value if currently not set.
        if (state && state.fullname && !visitorFullname) {
          visitorFullname = state.fullname;
        }
        if (state && state.mail && !mail) {
          mail = state.mail;
        }
        // Restore the state,  if currently not set.
        if (state && state.supportId && !supportId) {
          supportId = state.supportId;
        }
        if (state && state.custom && !customVars) {
          customVars = state.custom;
        }
      }, _getCurrentUrl = function () {
        console.debug('webContent Current Url: ' + window.location.href);
        return window.location.href;
      };
    var visitorId;
    // unique id of this web visitor
    var visitorFullname;
    // the fullname of this visitor e.g. "John Smith"
    var mail;
    // the email address of the visitor e.g. test@example.com
    var supportId;
    // the supportId of the last support session this user was offered or has requested
    var termsAccepted = false;
    var customVars;
    var visitorInfo = {
      fullname: function (cachedAllowed) {
        if (cachedAllowed && visitorFullname) {
          return visitorFullname;
        }
        return null;
      },
      setFullname: function (_fullname) {
        visitorFullname = _fullname;
      },
      setMail: function (_mail) {
        mail = _mail;
      },
      supportId: function (_supportId) {
        if (_supportId) {
          supportId = _supportId;
        }
        return supportId;
      },
      clearServiceID: function () {
        this.serviceId = null;
      },
      termsAccepted: function () {
        return termsAccepted;
      },
      setTermsAccepted: function (accepted) {
        termsAccepted = !!accepted;
      },
      id: function () {
        _resumeVisitor();
        if (visitorId) {
          return visitorId;
        }
        // Do not use fullname instead of id. Id should always be the id
        // visitorId = visitorId || _onlyAlphaNumeric(visitorInfo.fullname(true));
        if (!visitorId) {
          var sld = document.domain.split('.');
          var rnd = new Date().getTime() + '-' + Math.floor(Math.random() * 5000000);
          visitorId = '_' + sld[sld.length - 2] + '-' + rnd;
        }
        return visitorId;
      },
      lookupAgent: function (serviceId, callback) {
        var vi = this;
        // save reference because require function below is executed in scope of
        //remove whitespace and dashes
        serviceId = (serviceId || vi.serviceId) + '';
        // convert number to string
        serviceId = serviceId.replace(/\s/gi, '');
        // FIXED: URL should be calculated when invoked and not when module loads.
        var requestUrl = synchroniteConfig.serverUrl + strings.AJAX_PATH;
        var deferred = request.post(requestUrl, {
          preventCache: true,
          handleAs: 'json',
          data: {
            action: 'findAgent',
            sI: serviceId,
            vI: vi.id(),
            // visitorId does not exist in scope of window.
            tI: synchroniteConfig.tenantId
          }
        });
        deferred.then(function (data) {
          var agent = data.result;
          console.debug('Got agent alias: ' + agent.aA);
          console.debug('Got agent id: ' + agent.aI);
          vi.connectedAgentAlias = agent.aA;
          if (callback) {
            callback(agent);
          } else {
            console.debug('No callback specified');
          }
        }, function () {
          console.warn('Failed to get serviceId');
        });
        return deferred;
      },
      createServiceId: function (serviceIdOrCallback, callback) {
        var vi = this;
        // save reference because require function below is executed in scope of
        var serviceId;
        var forceNew;
        if (arguments.length === 0) {
          throw {
            name: synchroniteAPI,
            message: 'At least one argument expected.'
          };
        }
        if (arguments.length === 1) {
          if (typeof serviceIdOrCallback === 'function') {
            callback = serviceIdOrCallback;
          } else {
            throw {
              name: synchroniteAPI,
              message: 'When using one parameter it should be a function.'
            };
          }
        } else if (arguments.length >= 2) {
          forceNew = !!serviceIdOrCallback;
          serviceId = serviceIdOrCallback;
          if (typeof callback !== 'function') {
            throw {
              name: synchroniteAPI,
              message: 'When using two parameters, the second should be a function.'
            };
          }
        }
        if (vi.serviceId && !forceNew) {
          // Use existing serviceNumber instead of generating a new one.
          if (callback) {
            callback(vi.serviceId);
          }
        } else {
          // FIXED: URL should be calculated when invoked and not when module loads.
          var requestUrl = synchroniteConfig.serverUrl + strings.AJAX_PATH;
          var queryParams = {
            action: 'createSN',
            vI: vi.id(),
            // visitorId does not exist in scope of window.
            tI: synchroniteConfig.tenantId
          };
          if (serviceId) {
            // We set an explicit serviceId
            queryParams.sI = serviceId;
          }
          request.post(requestUrl, {
            preventCache: true,
            handleAs: 'json',
            data: queryParams
          }).then(function (data) {
            var serviceId = data.result;
            console.debug('Got service ID:' + serviceId);
            vi.serviceId = serviceId;
            if (callback) {
              callback(serviceId);
            } else {
              console.debug('No callback specified');
            }
          }, function () {
            // FIXME: Should we return null to the callback?
            console.warn('Failed to get serviceId');
          });
        }
      },
      getCustomVars: function () {
        return customVars;
      },
      setCustomVar: function (name, value) {
        if (!customVars) {
          customVars = {};
        }
        customVars[name] = value;
        return true;  // Success
      },
      allInfo: function () {
        //get existing visitorId or create new one
        var userInfo = {
          fullname: visitorFullname,
          username: visitorId,
          mail: mail,
          url: _getCurrentUrl()
        };
        if (typeof screen !== 'undefined') {
          userInfo.screenWidth = screen.width;
          userInfo.screenHeight = screen.height;
        }
        userInfo.developer = synchAnalytics.debuggerEnabled();
        userInfo.referrer = userInfo.referrer || synchAnalytics.referrer();
        try {
          if (customVars) {
            dojoLang.mixin(userInfo, customVars);
          }
        } catch (e) {
          console.warn('Error mixin userInfo.');
        }
        return userInfo;
      },
      event: function () {
        var eventInfo = {
          visitorId: visitorInfo.id(),
          fullname: visitorInfo.fullname(true),
          url: _getCurrentUrl()
        };
        if (supportId) {
          eventInfo.supportId = supportId;
        }
        if (mail) {
          eventInfo.mail = mail;
        }
        if (customVars) {
          eventInfo.custom = customVars;
        }
        return eventInfo;
      },
      persist: function () {
        var info = {};
        if (visitorId) {
          info.visitorId = visitorId;
          if (visitorFullname) {
            info.fullname = visitorFullname;
          }
          if (supportId) {
            info.supportId = supportId;
          }
          if (mail) {
            info.mail = mail;
          }
          if (customVars) {
            info.custom = customVars;
          }
          var cookieProps = {
            //FIXED: Use no max-age so the user has the same id after
            //       returning from a synchronite session
            //"max-age": 40,
            path: '/'
          };
          cookie(SYNCHRONITE_VISITOR_COOKIE_NAME, base64.encode(JSON.stringify(info)), cookieProps);
        }
      },
      //the agentAlias of the call agent that has accepted the support request
      connectedAgentAlias: null
    };
    return visitorInfo;
  }(dojo__base_lang, dojo_cookie, dojo_request, synchronite_constants_strings, synchronite__base_base64, synchronite__base_analytics);
  dojo_string = function (kernel, lang) {
    // module:
    //		dojo/string
    var ESCAPE_REGEXP = /[&<>'"\/]/g;
    var ESCAPE_MAP = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      '\'': '&#x27;',
      '/': '&#x2F;'
    };
    var string = {};
    lang.setObject('dojo.string', string);
    string.escape = function (str) {
      // summary:
      //		Efficiently escape a string for insertion into HTML (innerHTML or attributes), replacing &, <, >, ", ', and / characters.
      // str:
      //		the string to escape
      if (!str) {
        return '';
      }
      return str.replace(ESCAPE_REGEXP, function (c) {
        return ESCAPE_MAP[c];
      });
    };
    string.rep = function (str, num) {
      // summary:
      //		Efficiently replicate a string `n` times.
      // str:
      //		the string to replicate
      // num:
      //		number of times to replicate the string
      if (num <= 0 || !str) {
        return '';
      }
      var buf = [];
      for (;;) {
        if (num & 1) {
          buf.push(str);
        }
        if (!(num >>= 1)) {
          break;
        }
        str += str;
      }
      return buf.join('');  // String
    };
    string.pad = function (text, size, ch, end) {
      // summary:
      //		Pad a string to guarantee that it is at least `size` length by
      //		filling with the character `ch` at either the start or end of the
      //		string. Pads at the start, by default.
      // text:
      //		the string to pad
      // size:
      //		length to provide padding
      // ch:
      //		character to pad, defaults to '0'
      // end:
      //		adds padding at the end if true, otherwise pads at start
      // example:
      //	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
      //	|	string.pad("Dojo", 10, "+", true);
      if (!ch) {
        ch = '0';
      }
      var out = String(text), pad = string.rep(ch, Math.ceil((size - out.length) / ch.length));
      return end ? out + pad : pad + out;  // String
    };
    string.substitute = function (template, map, transform, thisObject) {
      // summary:
      //		Performs parameterized substitutions on a string. Throws an
      //		exception if any parameter is unmatched.
      // template:
      //		a string with expressions in the form `${key}` to be replaced or
      //		`${key:format}` which specifies a format function. keys are case-sensitive.
      // map:
      //		hash to search for substitutions
      // transform:
      //		a function to process all parameters before substitution takes
      //		place, e.g. mylib.encodeXML
      // thisObject:
      //		where to look for optional format function; default to the global
      //		namespace
      // example:
      //		Substitutes two expressions in a string from an Array or Object
      //	|	// returns "File 'foo.html' is not found in directory '/temp'."
      //	|	// by providing substitution data in an Array
      //	|	string.substitute(
      //	|		"File '${0}' is not found in directory '${1}'.",
      //	|		["foo.html","/temp"]
      //	|	);
      //	|
      //	|	// also returns "File 'foo.html' is not found in directory '/temp'."
      //	|	// but provides substitution data in an Object structure.  Dotted
      //	|	// notation may be used to traverse the structure.
      //	|	string.substitute(
      //	|		"File '${name}' is not found in directory '${info.dir}'.",
      //	|		{ name: "foo.html", info: { dir: "/temp" } }
      //	|	);
      // example:
      //		Use a transform function to modify the values:
      //	|	// returns "file 'foo.html' is not found in directory '/temp'."
      //	|	string.substitute(
      //	|		"${0} is not found in ${1}.",
      //	|		["foo.html","/temp"],
      //	|		function(str){
      //	|			// try to figure out the type
      //	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
      //	|			return prefix + " '" + str + "'";
      //	|		}
      //	|	);
      // example:
      //		Use a formatter
      //	|	// returns "thinger -- howdy"
      //	|	string.substitute(
      //	|		"${0:postfix}", ["thinger"], null, {
      //	|			postfix: function(value, key){
      //	|				return value + " -- howdy";
      //	|			}
      //	|		}
      //	|	);
      thisObject = thisObject || kernel.global;
      transform = transform ? lang.hitch(thisObject, transform) : function (v) {
        return v;
      };
      return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g, function (match, key, format) {
        var value = lang.getObject(key, false, map);
        if (format) {
          value = lang.getObject(format, false, thisObject).call(thisObject, value, key);
        }
        return transform(value, key).toString();
      });  // String
    };
    string.trim = String.prototype.trim ? lang.trim : // aliasing to the native function
    function (str) {
      str = str.replace(/^\s+/, '');
      for (var i = str.length - 1; i >= 0; i--) {
        if (/\S/.test(str.charAt(i))) {
          str = str.substring(0, i + 1);
          break;
        }
      }
      return str;
    };
    /*=====
     string.trim = function(str){
    	 // summary:
    	 //		Trims whitespace from both sides of the string
    	 // str: String
    	 //		String to be trimmed
    	 // returns: String
    	 //		Returns the trimmed string
    	 // description:
    	 //		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
    	 //		The short yet performant version of this function is dojo/_base/lang.trim(),
    	 //		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
    	 return "";	// String
     };
     =====*/
    return string;
  }(dojo__base_kernel, dojo__base_lang);
  /*
   * Copyright (c) 2008-2017 the original author or authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /* CometD Version 3.1.1 */
  (function (root, factory) {
    if (typeof exports === 'object') {
      // CommonJS.
      module.exports = factory();
    } else if (true) {
      org_cometd = function () {
        return typeof factory === 'function' ? factory() : factory;
      }();
    } else {
      // Globals.
      root.org = root.org || {};
      root.org.cometd = factory();
    }
  }(this, function () {
    /**
     * Utility functions.
     */
    var Utils = {
      isString: function (value) {
        if (value === undefined || value === null) {
          return false;
        }
        return typeof value === 'string' || value instanceof String;
      },
      isArray: function (value) {
        if (value === undefined || value === null) {
          return false;
        }
        return value instanceof Array;
      },
      /**
       * Returns whether the given element is contained into the given array.
       * @param element the element to check presence for
       * @param array the array to check for the element presence
       * @return the index of the element, if present, or a negative index if the element is not present
       */
      inArray: function (element, array) {
        for (var i = 0; i < array.length; ++i) {
          if (element === array[i]) {
            return i;
          }
        }
        return -1;
      },
      setTimeout: function (cometd, funktion, delay) {
        return window.setTimeout(function () {
          try {
            cometd._debug('Invoking timed function', funktion);
            funktion();
          } catch (x) {
            cometd._debug('Exception invoking timed function', funktion, x);
          }
        }, delay);
      },
      clearTimeout: function (timeoutHandle) {
        window.clearTimeout(timeoutHandle);
      }
    };
    /**
     * A registry for transports used by the CometD object.
     */
    var TransportRegistry = function () {
      var _types = [];
      var _transports = {};
      this.getTransportTypes = function () {
        return _types.slice(0);
      };
      this.findTransportTypes = function (version, crossDomain, url) {
        var result = [];
        for (var i = 0; i < _types.length; ++i) {
          var type = _types[i];
          if (_transports[type].accept(version, crossDomain, url) === true) {
            result.push(type);
          }
        }
        return result;
      };
      this.negotiateTransport = function (types, version, crossDomain, url) {
        for (var i = 0; i < _types.length; ++i) {
          var type = _types[i];
          for (var j = 0; j < types.length; ++j) {
            if (type === types[j]) {
              var transport = _transports[type];
              if (transport.accept(version, crossDomain, url) === true) {
                return transport;
              }
            }
          }
        }
        return null;
      };
      this.add = function (type, transport, index) {
        var existing = false;
        for (var i = 0; i < _types.length; ++i) {
          if (_types[i] === type) {
            existing = true;
            break;
          }
        }
        if (!existing) {
          if (typeof index !== 'number') {
            _types.push(type);
          } else {
            _types.splice(index, 0, type);
          }
          _transports[type] = transport;
        }
        return !existing;
      };
      this.find = function (type) {
        for (var i = 0; i < _types.length; ++i) {
          if (_types[i] === type) {
            return _transports[type];
          }
        }
        return null;
      };
      this.remove = function (type) {
        for (var i = 0; i < _types.length; ++i) {
          if (_types[i] === type) {
            _types.splice(i, 1);
            var transport = _transports[type];
            delete _transports[type];
            return transport;
          }
        }
        return null;
      };
      this.clear = function () {
        _types = [];
        _transports = {};
      };
      this.reset = function (init) {
        for (var i = 0; i < _types.length; ++i) {
          _transports[_types[i]].reset(init);
        }
      };
    };
    /**
     * Base object with the common functionality for transports.
     */
    var Transport = function () {
      var _type;
      var _cometd;
      var _url;
      /**
       * Function invoked just after a transport has been successfully registered.
       * @param type the type of transport (for example 'long-polling')
       * @param cometd the cometd object this transport has been registered to
       * @see #unregistered()
       */
      this.registered = function (type, cometd) {
        _type = type;
        _cometd = cometd;
      };
      /**
       * Function invoked just after a transport has been successfully unregistered.
       * @see #registered(type, cometd)
       */
      this.unregistered = function () {
        _type = null;
        _cometd = null;
      };
      this._debug = function () {
        _cometd._debug.apply(_cometd, arguments);
      };
      this._mixin = function () {
        return _cometd._mixin.apply(_cometd, arguments);
      };
      this.getConfiguration = function () {
        return _cometd.getConfiguration();
      };
      this.getAdvice = function () {
        return _cometd.getAdvice();
      };
      this.setTimeout = function (funktion, delay) {
        return Utils.setTimeout(_cometd, funktion, delay);
      };
      this.clearTimeout = function (handle) {
        Utils.clearTimeout(handle);
      };
      /**
       * Converts the given response into an array of bayeux messages
       * @param response the response to convert
       * @return an array of bayeux messages obtained by converting the response
       */
      this.convertToMessages = function (response) {
        if (Utils.isString(response)) {
          try {
            return JSON.parse(response);
          } catch (x) {
            this._debug('Could not convert to JSON the following string', '"' + response + '"');
            throw x;
          }
        }
        if (Utils.isArray(response)) {
          return response;
        }
        if (response === undefined || response === null) {
          return [];
        }
        if (response instanceof Object) {
          return [response];
        }
        throw 'Conversion Error ' + response + ', typeof ' + typeof response;
      };
      /**
       * Returns whether this transport can work for the given version and cross domain communication case.
       * @param version a string indicating the transport version
       * @param crossDomain a boolean indicating whether the communication is cross domain
       * @param url the URL to connect to
       * @return true if this transport can work for the given version and cross domain communication case,
       * false otherwise
       */
      this.accept = function (version, crossDomain, url) {
        throw 'Abstract';
      };
      /**
       * Returns the type of this transport.
       * @see #registered(type, cometd)
       */
      this.getType = function () {
        return _type;
      };
      this.getURL = function () {
        return _url;
      };
      this.setURL = function (url) {
        _url = url;
      };
      this.send = function (envelope, metaConnect) {
        throw 'Abstract';
      };
      this.reset = function (init) {
        this._debug('Transport', _type, 'reset', init ? 'initial' : 'retry');
      };
      this.abort = function () {
        this._debug('Transport', _type, 'aborted');
      };
      this.toString = function () {
        return this.getType();
      };
    };
    Transport.derive = function (baseObject) {
      function F() {
      }
      F.prototype = baseObject;
      return new F();
    };
    /**
     * Base object with the common functionality for transports based on requests.
     * The key responsibility is to allow at most 2 outstanding requests to the server,
     * to avoid that requests are sent behind a long poll.
     * To achieve this, we have one reserved request for the long poll, and all other
     * requests are serialized one after the other.
     */
    var RequestTransport = function () {
      var _super = new Transport();
      var _self = Transport.derive(_super);
      var _requestIds = 0;
      var _metaConnectRequest = null;
      var _requests = [];
      var _envelopes = [];
      function _coalesceEnvelopes(envelope) {
        while (_envelopes.length > 0) {
          var envelopeAndRequest = _envelopes[0];
          var newEnvelope = envelopeAndRequest[0];
          var newRequest = envelopeAndRequest[1];
          if (newEnvelope.url === envelope.url && newEnvelope.sync === envelope.sync) {
            _envelopes.shift();
            envelope.messages = envelope.messages.concat(newEnvelope.messages);
            this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);
            continue;
          }
          break;
        }
      }
      function _transportSend(envelope, request) {
        this.transportSend(envelope, request);
        request.expired = false;
        if (!envelope.sync) {
          var maxDelay = this.getConfiguration().maxNetworkDelay;
          var delay = maxDelay;
          if (request.metaConnect === true) {
            delay += this.getAdvice().timeout;
          }
          this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);
          var self = this;
          request.timeout = this.setTimeout(function () {
            request.expired = true;
            var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';
            var failure = { reason: errorMessage };
            var xhr = request.xhr;
            failure.httpCode = self.xhrStatus(xhr);
            self.abortXHR(xhr);
            self._debug(errorMessage);
            self.complete(request, false, request.metaConnect);
            envelope.onFailure(xhr, envelope.messages, failure);
          }, delay);
        }
      }
      function _queueSend(envelope) {
        var requestId = ++_requestIds;
        var request = {
          id: requestId,
          metaConnect: false,
          envelope: envelope
        };
        // Consider the metaConnect requests which should always be present
        if (_requests.length < this.getConfiguration().maxConnections - 1) {
          _requests.push(request);
          _transportSend.call(this, envelope, request);
        } else {
          this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);
          _envelopes.push([
            envelope,
            request
          ]);
        }
      }
      function _metaConnectComplete(request) {
        var requestId = request.id;
        this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);
        if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId) {
          throw 'Longpoll request mismatch, completing request ' + requestId;
        }
        // Reset metaConnect request
        _metaConnectRequest = null;
      }
      function _complete(request, success) {
        var index = Utils.inArray(request, _requests);
        // The index can be negative if the request has been aborted
        if (index >= 0) {
          _requests.splice(index, 1);
        }
        if (_envelopes.length > 0) {
          var envelopeAndRequest = _envelopes.shift();
          var nextEnvelope = envelopeAndRequest[0];
          var nextRequest = envelopeAndRequest[1];
          this._debug('Transport dequeued request', nextRequest.id);
          if (success) {
            if (this.getConfiguration().autoBatch) {
              _coalesceEnvelopes.call(this, nextEnvelope);
            }
            _queueSend.call(this, nextEnvelope);
            this._debug('Transport completed request', request.id, nextEnvelope);
          } else {
            // Keep the semantic of calling response callbacks asynchronously after the request
            var self = this;
            this.setTimeout(function () {
              self.complete(nextRequest, false, nextRequest.metaConnect);
              var failure = { reason: 'Previous request failed' };
              var xhr = nextRequest.xhr;
              failure.httpCode = self.xhrStatus(xhr);
              nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);
            }, 0);
          }
        }
      }
      _self.complete = function (request, success, metaConnect) {
        if (metaConnect) {
          _metaConnectComplete.call(this, request);
        } else {
          _complete.call(this, request, success);
        }
      };
      /**
       * Performs the actual send depending on the transport type details.
       * @param envelope the envelope to send
       * @param request the request information
       */
      _self.transportSend = function (envelope, request) {
        throw 'Abstract';
      };
      _self.transportSuccess = function (envelope, request, responses) {
        if (!request.expired) {
          this.clearTimeout(request.timeout);
          this.complete(request, true, request.metaConnect);
          if (responses && responses.length > 0) {
            envelope.onSuccess(responses);
          } else {
            envelope.onFailure(request.xhr, envelope.messages, { httpCode: 204 });
          }
        }
      };
      _self.transportFailure = function (envelope, request, failure) {
        if (!request.expired) {
          this.clearTimeout(request.timeout);
          this.complete(request, false, request.metaConnect);
          envelope.onFailure(request.xhr, envelope.messages, failure);
        }
      };
      function _metaConnectSend(envelope) {
        if (_metaConnectRequest !== null) {
          throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';
        }
        var requestId = ++_requestIds;
        this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);
        var request = {
          id: requestId,
          metaConnect: true,
          envelope: envelope
        };
        _transportSend.call(this, envelope, request);
        _metaConnectRequest = request;
      }
      _self.send = function (envelope, metaConnect) {
        if (metaConnect) {
          _metaConnectSend.call(this, envelope);
        } else {
          _queueSend.call(this, envelope);
        }
      };
      _self.abort = function () {
        _super.abort();
        for (var i = 0; i < _requests.length; ++i) {
          var request = _requests[i];
          if (request) {
            this._debug('Aborting request', request);
            if (!this.abortXHR(request.xhr)) {
              this.transportFailure(request.envelope, request, { reason: 'abort' });
            }
          }
        }
        var metaConnectRequest = _metaConnectRequest;
        if (metaConnectRequest) {
          this._debug('Aborting metaConnect request', metaConnectRequest);
          if (!this.abortXHR(metaConnectRequest.xhr)) {
            this.transportFailure(metaConnectRequest.envelope, metaConnectRequest, { reason: 'abort' });
          }
        }
        this.reset(true);
      };
      _self.reset = function (init) {
        _super.reset(init);
        _metaConnectRequest = null;
        _requests = [];
        _envelopes = [];
      };
      _self.abortXHR = function (xhr) {
        if (xhr) {
          try {
            var state = xhr.readyState;
            xhr.abort();
            return state !== XMLHttpRequest.UNSENT;
          } catch (x) {
            this._debug(x);
          }
        }
        return false;
      };
      _self.xhrStatus = function (xhr) {
        if (xhr) {
          try {
            return xhr.status;
          } catch (x) {
            this._debug(x);
          }
        }
        return -1;
      };
      return _self;
    };
    var LongPollingTransport = function () {
      var _super = new RequestTransport();
      var _self = Transport.derive(_super);
      // By default, support cross domain
      var _supportsCrossDomain = true;
      _self.accept = function (version, crossDomain, url) {
        return _supportsCrossDomain || !crossDomain;
      };
      _self.xhrSend = function (packet) {
        var xhr = new XMLHttpRequest();
        xhr.withCredentials = true;
        xhr.open('POST', packet.url, packet.sync !== true);
        var headers = packet.headers;
        if (headers) {
          for (var headerName in headers) {
            if (headers.hasOwnProperty(headerName)) {
              xhr.setRequestHeader(headerName, headers[headerName]);
            }
          }
        }
        xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');
        xhr.onload = function () {
          if (xhr.status === 200) {
            packet.onSuccess(xhr.responseText);
          } else {
            packet.onError(xhr.statusText);
          }
        };
        xhr.onerror = function () {
          packet.onError(xhr.statusText);
        };
        xhr.send(packet.body);
        return xhr;
      };
      _self.transportSend = function (envelope, request) {
        this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);
        var self = this;
        try {
          var sameStack = true;
          request.xhr = this.xhrSend({
            transport: this,
            url: envelope.url,
            sync: envelope.sync,
            headers: this.getConfiguration().requestHeaders,
            body: JSON.stringify(envelope.messages),
            onSuccess: function (response) {
              self._debug('Transport', self.getType(), 'received response', response);
              var success = false;
              try {
                var received = self.convertToMessages(response);
                if (received.length === 0) {
                  _supportsCrossDomain = false;
                  self.transportFailure(envelope, request, { httpCode: 204 });
                } else {
                  success = true;
                  self.transportSuccess(envelope, request, received);
                }
              } catch (x) {
                self._debug(x);
                if (!success) {
                  _supportsCrossDomain = false;
                  var failure = { exception: x };
                  failure.httpCode = self.xhrStatus(request.xhr);
                  self.transportFailure(envelope, request, failure);
                }
              }
            },
            onError: function (reason, exception) {
              self._debug('Transport', self.getType(), 'received error', reason, exception);
              _supportsCrossDomain = false;
              var failure = {
                reason: reason,
                exception: exception
              };
              failure.httpCode = self.xhrStatus(request.xhr);
              if (sameStack) {
                // Keep the semantic of calling response callbacks asynchronously after the request
                self.setTimeout(function () {
                  self.transportFailure(envelope, request, failure);
                }, 0);
              } else {
                self.transportFailure(envelope, request, failure);
              }
            }
          });
          sameStack = false;
        } catch (x) {
          _supportsCrossDomain = false;
          this.setTimeout(function () {
            self.transportFailure(envelope, request, { exception: x });
          }, 0);
        }
      };
      _self.reset = function (init) {
        _super.reset(init);
        _supportsCrossDomain = true;
      };
      return _self;
    };
    // var CallbackPollingTransport = function() {
    //     var _super = new RequestTransport();
    //     var _self = Transport.derive(_super);
    //     var _maxLength = 5000; //PATCHED
    //     var jsonp = 0;
    //
    //     _self.accept = function(version, crossDomain, url) {
    //         return true;
    //     };
    //
    //     _self.jsonpSend = function(packet) {
    //         var head = document.getElementsByTagName('head')[0];
    //         var script = document.createElement('script');
    //
    //         var callbackName = '_cometd_jsonp_' + jsonp++;
    //         window[callbackName] = function(responseText) {
    //             head.removeChild(script);
    //             delete window[callbackName];
    //             packet.onSuccess(responseText);
    //         };
    //
    //         var url = packet.url;
    //         url += url.indexOf('?') < 0 ? '?' : '&';
    //         url += 'jsonp=' + callbackName;
    //         url += '&message=' + packet.body;
    //         script.src = url;
    //         script.async = packet.sync !== true;
    //         script.type = 'application/javascript';
    //         script.onerror = function(e) {
    //             packet.onError('jsonp ' + e.type);
    //         };
    //         head.appendChild(script);
    //     };
    //
    //     function _failTransportFn(envelope, request, x) {
    //         var self = this;
    //         return function() {
    //             self.transportFailure(envelope, request, 'error', x);
    //         };
    //     }
    //
    //     _self.transportSend = function(envelope, request) {
    //         var self = this;
    //
    //         // Microsoft Internet Explorer has a 2083 URL max length
    //         // We must ensure that we stay within that length
    //         var start = 0;
    //         var length = envelope.messages.length;
    //         var lengths = [];
    //         while (length > 0) {
    //             // Encode the messages because all brackets, quotes, commas, colons, etc
    //             // present in the JSON will be URL encoded, taking many more characters
    //             var json = JSON.stringify(envelope.messages.slice(start, start + length));
    //             var urlLength = envelope.url.length + encodeURI(json).length;
    //
    //             if (urlLength > _maxLength) { // PATCHED
    //                 if (length === 1) {
    //                     var x = 'Bayeux message too big (' + urlLength + ' bytes, max is ' + maxLength + ') ' +
    //                         'for transport ' + this.getType();
    //                     // Keep the semantic of calling response callbacks asynchronously after the request
    //                     this.setTimeout(_failTransportFn.call(this, envelope, request, x), 0);
    //                     return;
    //                 }
    //
    //                 --length;
    //                 continue;
    //             }
    //
    //             lengths.push(length);
    //             start += length;
    //             length = envelope.messages.length - start;
    //         }
    //
    //         // Here we are sure that the messages can be sent within the URL limit
    //
    //         var envelopeToSend = envelope;
    //         if (lengths.length > 1) {
    //             var begin = 0;
    //             var end = lengths[0];
    //             this._debug('Transport', this.getType(), 'split', envelope.messages.length, 'messages into', lengths.join(' + '));
    //             envelopeToSend = this._mixin(false, {}, envelope);
    //             envelopeToSend.messages = envelope.messages.slice(begin, end);
    //             envelopeToSend.onSuccess = envelope.onSuccess;
    //             envelopeToSend.onFailure = envelope.onFailure;
    //
    //             for (var i = 1; i < lengths.length; ++i) {
    //                 var nextEnvelope = this._mixin(false, {}, envelope);
    //                 begin = end;
    //                 end += lengths[i];
    //                 nextEnvelope.messages = envelope.messages.slice(begin, end);
    //                 nextEnvelope.onSuccess = envelope.onSuccess;
    //                 nextEnvelope.onFailure = envelope.onFailure;
    //                 this.send(nextEnvelope, request.metaConnect);
    //             }
    //         }
    //
    //         this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelopeToSend);
    //
    //         try {
    //             var sameStack = true;
    //             this.jsonpSend({
    //                 transport: this,
    //                 url: envelopeToSend.url,
    //                 sync: envelopeToSend.sync,
    //                 headers: this.getConfiguration().requestHeaders,
    //                 body: JSON.stringify(envelopeToSend.messages),
    //                 onSuccess: function(responses) {
    //                     var success = false;
    //                     try {
    //                         var received = self.convertToMessages(responses);
    //                         if (received.length === 0) {
    //                             self.transportFailure(envelopeToSend, request, {
    //                                 httpCode: 204
    //                             });
    //                         } else {
    //                             success = true;
    //                             self.transportSuccess(envelopeToSend, request, received);
    //                         }
    //                     } catch (x) {
    //                         self._debug(x);
    //                         if (!success) {
    //                             self.transportFailure(envelopeToSend, request, {
    //                                 exception: x
    //                             });
    //                         }
    //                     }
    //                 },
    //                 onError: function(reason, exception) {
    //                     var failure = {
    //                         reason: reason,
    //                         exception: exception
    //                     };
    //                     if (sameStack) {
    //                         // Keep the semantic of calling response callbacks asynchronously after the request
    //                         self.setTimeout(function() {
    //                             self.transportFailure(envelopeToSend, request, failure);
    //                         }, 0);
    //                     } else {
    //                         self.transportFailure(envelopeToSend, request, failure);
    //                     }
    //                 }
    //             });
    //             sameStack = false;
    //         } catch (xx) {
    //             // Keep the semantic of calling response callbacks asynchronously after the request
    //             this.setTimeout(function() {
    //                 self.transportFailure(envelopeToSend, request, {
    //                     exception: xx
    //                 });
    //             }, 0);
    //         }
    //     };
    //
    //     return _self;
    // };
    var WebSocketTransport = function () {
      var _super = new Transport();
      var _self = Transport.derive(_super);
      var _cometd;
      // By default WebSocket is supported
      var _webSocketSupported = true;
      // Whether we were able to establish a WebSocket connection
      var _webSocketConnected = false;
      var _stickyReconnect = true;
      // The context contains the envelopes that have been sent
      // and the timeouts for the messages that have been sent.
      var _context = null;
      var _connecting = null;
      var _connected = false;
      var _successCallback = null;
      _self.reset = function (init) {
        _super.reset(init);
        _webSocketSupported = true;
        if (init) {
          _webSocketConnected = false;
        }
        _stickyReconnect = true;
        _context = null;
        _connecting = null;
        _connected = false;
      };
      function _forceClose(context, event) {
        if (context) {
          this.webSocketClose(context, event.code, event.reason);
          // Force immediate failure of pending messages to trigger reconnect.
          // This is needed because the server may not reply to our close()
          // and therefore the onclose function is never called.
          this.onClose(context, event);
        }
      }
      function _sameContext(context) {
        return context === _connecting || context === _context;
      }
      function _storeEnvelope(context, envelope, metaConnect) {
        var messageIds = [];
        for (var i = 0; i < envelope.messages.length; ++i) {
          var message = envelope.messages[i];
          if (message.id) {
            messageIds.push(message.id);
          }
        }
        context.envelopes[messageIds.join(',')] = [
          envelope,
          metaConnect
        ];
        this._debug('Transport', this.getType(), 'stored envelope, envelopes', context.envelopes);
      }
      function _websocketConnect(context) {
        // We may have multiple attempts to open a WebSocket
        // connection, for example a /meta/connect request that
        // may take time, along with a user-triggered publish.
        // Early return if we are already connecting.
        if (_connecting) {
          return;
        }
        // Mangle the URL, changing the scheme from 'http' to 'ws'.
        var url = _cometd.getURL().replace(/^http/, 'ws');
        this._debug('Transport', this.getType(), 'connecting to URL', url);
        try {
          var protocol = _cometd.getConfiguration().protocol;
          context.webSocket = protocol ? new window.WebSocket(url, protocol) : new window.WebSocket(url);
          _connecting = context;
        } catch (x) {
          _webSocketSupported = false;
          this._debug('Exception while creating WebSocket object', x);
          throw x;
        }
        // By default use sticky reconnects.
        _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;
        var self = this;
        var connectTimeout = _cometd.getConfiguration().connectTimeout;
        if (connectTimeout > 0) {
          context.connectTimer = this.setTimeout(function () {
            _cometd._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');
            // The connection was not opened, close anyway.
            _forceClose.call(self, context, {
              code: 1000,
              reason: 'Connect Timeout'
            });
          }, connectTimeout);
        }
        var onopen = function () {
          _cometd._debug('WebSocket onopen', context);
          if (context.connectTimer) {
            self.clearTimeout(context.connectTimer);
          }
          if (_sameContext(context)) {
            _connecting = null;
            _context = context;
            _webSocketConnected = true;
            self.onOpen(context);
          } else {
            // We have a valid connection already, close this one.
            _cometd._warn('Closing extra WebSocket connection', this, 'active connection', _context);
            _forceClose.call(self, context, {
              code: 1000,
              reason: 'Extra Connection'
            });
          }
        };
        // This callback is invoked when the server sends the close frame.
        // The close frame for a connection may arrive *after* another
        // connection has been opened, so we must make sure that actions
        // are performed only if it's the same connection.
        var onclose = function (event) {
          event = event || { code: 1000 };
          _cometd._debug('WebSocket onclose', context, event, 'connecting', _connecting, 'current', _context);
          if (context.connectTimer) {
            self.clearTimeout(context.connectTimer);
          }
          self.onClose(context, event);
        };
        var onmessage = function (wsMessage) {
          _cometd._debug('WebSocket onmessage', wsMessage, context);
          self.onMessage(context, wsMessage);
        };
        context.webSocket.onopen = onopen;
        context.webSocket.onclose = onclose;
        context.webSocket.onerror = function () {
          // Clients should call onclose(), but if they do not we do it here for safety.
          onclose({
            code: 1000,
            reason: 'Error'
          });
        };
        context.webSocket.onmessage = onmessage;
        this._debug('Transport', this.getType(), 'configured callbacks on', context);
      }
      function _webSocketSend(context, envelope, metaConnect) {
        var json = JSON.stringify(envelope.messages);
        context.webSocket.send(json);
        this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);
        // Manage the timeout waiting for the response.
        var maxDelay = this.getConfiguration().maxNetworkDelay;
        var delay = maxDelay;
        if (metaConnect) {
          delay += this.getAdvice().timeout;
          _connected = true;
        }
        var self = this;
        var messageIds = [];
        for (var i = 0; i < envelope.messages.length; ++i) {
          (function () {
            var message = envelope.messages[i];
            if (message.id) {
              messageIds.push(message.id);
              context.timeouts[message.id] = self.setTimeout(function () {
                _cometd._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', context);
                _forceClose.call(self, context, {
                  code: 1000,
                  reason: 'Message Timeout'
                });
              }, delay);
            }
          }());
        }
        this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', context.timeouts);
      }
      _self._notifySuccess = function (fn, messages) {
        fn.call(this, messages);
      };
      _self._notifyFailure = function (fn, context, messages, failure) {
        fn.call(this, context, messages, failure);
      };
      function _send(context, envelope, metaConnect) {
        try {
          if (context === null) {
            context = _connecting || {
              envelopes: {},
              timeouts: {}
            };
            _storeEnvelope.call(this, context, envelope, metaConnect);
            _websocketConnect.call(this, context);
          } else {
            _storeEnvelope.call(this, context, envelope, metaConnect);
            _webSocketSend.call(this, context, envelope, metaConnect);
          }
        } catch (x) {
          var self = this;
          this.setTimeout(function () {
            _forceClose.call(self, context, {
              code: 1000,
              reason: 'Exception',
              exception: x
            });
          }, 0);
        }
      }
      _self.onOpen = function (context) {
        var envelopes = context.envelopes;
        this._debug('Transport', this.getType(), 'opened', context, 'pending messages', envelopes);
        for (var key in envelopes) {
          if (envelopes.hasOwnProperty(key)) {
            var element = envelopes[key];
            var envelope = element[0];
            var metaConnect = element[1];
            // Store the success callback, which is independent from the envelope,
            // so that it can be used to notify arrival of messages.
            _successCallback = envelope.onSuccess;
            _webSocketSend.call(this, context, envelope, metaConnect);
          }
        }
      };
      _self.onMessage = function (context, wsMessage) {
        this._debug('Transport', this.getType(), 'received websocket message', wsMessage, context);
        var close = false;
        var messages = this.convertToMessages(wsMessage.data);
        var messageIds = [];
        for (var i = 0; i < messages.length; ++i) {
          var message = messages[i];
          // Detect if the message is a response to a request we made.
          // If it's a meta message, for sure it's a response; otherwise it's
          // a publish message and publish responses don't have the data field.
          if (/^\/meta\//.test(message.channel) || message.data === undefined) {
            if (message.id) {
              messageIds.push(message.id);
              var timeout = context.timeouts[message.id];
              if (timeout) {
                this.clearTimeout(timeout);
                delete context.timeouts[message.id];
                this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', context.timeouts);
              }
            }
          }
          if ('/meta/connect' === message.channel) {
            _connected = false;
          }
          if ('/meta/disconnect' === message.channel && !_connected) {
            close = true;
          }
        }
        // Remove the envelope corresponding to the messages.
        var removed = false;
        var envelopes = context.envelopes;
        for (var j = 0; j < messageIds.length; ++j) {
          var id = messageIds[j];
          for (var key in envelopes) {
            if (envelopes.hasOwnProperty(key)) {
              var ids = key.split(',');
              var index = Utils.inArray(id, ids);
              if (index >= 0) {
                removed = true;
                ids.splice(index, 1);
                var envelope = envelopes[key][0];
                var metaConnect = envelopes[key][1];
                delete envelopes[key];
                if (ids.length > 0) {
                  envelopes[ids.join(',')] = [
                    envelope,
                    metaConnect
                  ];
                }
                break;
              }
            }
          }
        }
        if (removed) {
          this._debug('Transport', this.getType(), 'removed envelope, envelopes', envelopes);
        }
        this._notifySuccess(_successCallback, messages);
        if (close) {
          this.webSocketClose(context, 1000, 'Disconnect');
        }
      };
      _self.onClose = function (context, event) {
        this._debug('Transport', this.getType(), 'closed', context, event);
        if (_sameContext(context)) {
          // Remember if we were able to connect.
          // This close event could be due to server shutdown,
          // and if it restarts we want to try websocket again.
          _webSocketSupported = _stickyReconnect && _webSocketConnected;
          _connecting = null;
          _context = null;
        }
        var timeouts = context.timeouts;
        context.timeouts = {};
        for (var id in timeouts) {
          if (timeouts.hasOwnProperty(id)) {
            this.clearTimeout(timeouts[id]);
          }
        }
        var envelopes = context.envelopes;
        context.envelopes = {};
        for (var key in envelopes) {
          if (envelopes.hasOwnProperty(key)) {
            var envelope = envelopes[key][0];
            var metaConnect = envelopes[key][1];
            if (metaConnect) {
              _connected = false;
            }
            var failure = {
              websocketCode: event.code,
              reason: event.reason
            };
            if (event.exception) {
              failure.exception = event.exception;
            }
            this._notifyFailure(envelope.onFailure, context, envelope.messages, failure);
          }
        }
      };
      _self.registered = function (type, cometd) {
        _super.registered(type, cometd);
        _cometd = cometd;
      };
      _self.accept = function (version, crossDomain, url) {
        this._debug('Transport', this.getType(), 'accept, supported:', _webSocketSupported);
        // Using !! to return a boolean (and not the WebSocket object).
        return _webSocketSupported && !!window.WebSocket && _cometd.websocketEnabled !== false;
      };
      _self.send = function (envelope, metaConnect) {
        this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);
        _send.call(this, _context, envelope, metaConnect);
      };
      _self.webSocketClose = function (context, code, reason) {
        try {
          if (context.webSocket) {
            context.webSocket.close(code, reason);
          }
        } catch (x) {
          this._debug(x);
        }
      };
      _self.abort = function () {
        _super.abort();
        _forceClose.call(this, _context, {
          code: 1000,
          reason: 'Abort'
        });
        this.reset(true);
      };
      return _self;
    };
    /**
     * The constructor for a CometD object, identified by an optional name.
     * The default name is the string 'default'.
     * @param name the optional name of this cometd object
     */
    var CometD = function (name) {
      var _cometd = this;
      var _name = name || 'default';
      var _crossDomain = false;
      var _transports = new TransportRegistry();
      var _transport;
      var _status = 'disconnected';
      var _messageId = 0;
      var _clientId = null;
      var _batch = 0;
      var _messageQueue = [];
      var _internalBatch = false;
      var _listenerId = 0;
      var _listeners = {};
      var _backoff = 0;
      var _scheduledSend = null;
      var _extensions = [];
      var _advice = {};
      var _handshakeProps;
      var _handshakeCallback;
      var _callbacks = {};
      var _remoteCalls = {};
      var _reestablish = false;
      var _connected = false;
      var _unconnectTime = 0;
      var _handshakeMessages = 0;
      var _config = {
        protocol: null,
        stickyReconnect: true,
        connectTimeout: 0,
        maxConnections: 2,
        backoffIncrement: 1000,
        maxBackoff: 60000,
        logLevel: 'info',
        reverseIncomingExtensions: true,
        maxNetworkDelay: 10000,
        requestHeaders: {},
        appendMessageTypeToURL: true,
        autoBatch: false,
        urls: {},
        maxURILength: 2000,
        advice: {
          timeout: 60000,
          interval: 0,
          reconnect: undefined,
          maxInterval: 0
        }
      };
      function _fieldValue(object, name) {
        try {
          return object[name];
        } catch (x) {
          return undefined;
        }
      }
      /**
       * Mixes in the given objects into the target object by copying the properties.
       * @param deep if the copy must be deep
       * @param target the target object
       * @param objects the objects whose properties are copied into the target
       */
      this._mixin = function (deep, target, objects) {
        var result = target || {};
        // Skip first 2 parameters (deep and target), and loop over the others
        for (var i = 2; i < arguments.length; ++i) {
          var object = arguments[i];
          if (object === undefined || object === null) {
            continue;
          }
          for (var propName in object) {
            if (object.hasOwnProperty(propName)) {
              var prop = _fieldValue(object, propName);
              var targ = _fieldValue(result, propName);
              // Avoid infinite loops
              if (prop === target) {
                continue;
              }
              // Do not mixin undefined values
              if (prop === undefined) {
                continue;
              }
              if (deep && typeof prop === 'object' && prop !== null) {
                if (prop instanceof Array) {
                  result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);
                } else {
                  var source = typeof targ === 'object' && !(targ instanceof Array) ? targ : {};
                  result[propName] = this._mixin(deep, source, prop);
                }
              } else {
                result[propName] = prop;
              }
            }
          }
        }
        return result;
      };
      function _isString(value) {
        return Utils.isString(value);
      }
      function _isFunction(value) {
        if (value === undefined || value === null) {
          return false;
        }
        return typeof value === 'function';
      }
      function _zeroPad(value, length) {
        var result = '';
        while (--length > 0) {
          if (value >= Math.pow(10, length)) {
            break;
          }
          result += '0';
        }
        result += value;
        return result;
      }
      function _log(level, args) {
        if (window.console) {
          var logger = window.console[level];
          if (_isFunction(logger)) {
            var now = new Date();
            [].splice.call(args, 0, 0, _zeroPad(now.getHours(), 2) + ':' + _zeroPad(now.getMinutes(), 2) + ':' + _zeroPad(now.getSeconds(), 2) + '.' + _zeroPad(now.getMilliseconds(), 3));
            logger.apply(window.console, args);
          }
        }
      }
      this._warn = function () {
        _log('warn', arguments);
      };
      this._info = function () {
        if (_config.logLevel !== 'warn') {
          _log('info', arguments);
        }
      };
      this._debug = function () {
        if (_config.logLevel === 'debug') {
          _log('debug', arguments);
        }
      };
      function _splitURL(url) {
        // [1] = protocol://,
        // [2] = host:port,
        // [3] = host,
        // [4] = IPv6_host,
        // [5] = IPv4_host,
        // [6] = :port,
        // [7] = port,
        // [8] = uri,
        // [9] = rest (query / fragment)
        return /(^https?:\/\/)?(((\[[^\]]+\])|([^:\/\?#]+))(:(\d+))?)?([^\?#]*)(.*)?/.exec(url);
      }
      /**
       * Returns whether the given hostAndPort is cross domain.
       * The default implementation checks against window.location.host
       * but this function can be overridden to make it work in non-browser
       * environments.
       *
       * @param hostAndPort the host and port in format host:port
       * @return whether the given hostAndPort is cross domain
       */
      this._isCrossDomain = function (hostAndPort) {
        return hostAndPort && hostAndPort !== window.location.host;
      };
      function _configure(configuration) {
        _cometd._debug('Configuring cometd object with', configuration);
        // Support old style param, where only the Bayeux server URL was passed
        if (_isString(configuration)) {
          configuration = { url: configuration };
        }
        if (!configuration) {
          configuration = {};
        }
        _config = _cometd._mixin(false, _config, configuration);
        var url = _cometd.getURL();
        if (!url) {
          throw 'Missing required configuration parameter \'url\' specifying the Bayeux server URL';
        }
        // Check if we're cross domain.
        var urlParts = _splitURL(url);
        var hostAndPort = urlParts[2];
        var uri = urlParts[8];
        var afterURI = urlParts[9];
        _crossDomain = _cometd._isCrossDomain(hostAndPort);
        // Check if appending extra path is supported
        if (_config.appendMessageTypeToURL) {
          if (afterURI !== undefined && afterURI.length > 0) {
            _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
            _config.appendMessageTypeToURL = false;
          } else {
            var uriSegments = uri.split('/');
            var lastSegmentIndex = uriSegments.length - 1;
            if (uri.match(/\/$/)) {
              lastSegmentIndex -= 1;
            }
            if (uriSegments[lastSegmentIndex].indexOf('.') >= 0) {
              // Very likely the CometD servlet's URL pattern is mapped to an extension, such as *.cometd
              // It will be difficult to add the extra path in this case
              _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
              _config.appendMessageTypeToURL = false;
            }
          }
        }
      }
      function _removeListener(subscription) {
        if (subscription) {
          var subscriptions = _listeners[subscription.channel];
          if (subscriptions && subscriptions[subscription.id]) {
            delete subscriptions[subscription.id];
            _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);
          }
        }
      }
      function _removeSubscription(subscription) {
        if (subscription && !subscription.listener) {
          _removeListener(subscription);
        }
      }
      function _clearSubscriptions() {
        for (var channel in _listeners) {
          if (_listeners.hasOwnProperty(channel)) {
            var subscriptions = _listeners[channel];
            if (subscriptions) {
              for (var id in subscriptions) {
                if (subscriptions.hasOwnProperty(id)) {
                  _removeSubscription(subscriptions[id]);
                }
              }
            }
          }
        }
      }
      function _setStatus(newStatus) {
        if (_status !== newStatus) {
          _cometd._debug('Status', _status, '->', newStatus);
          _status = newStatus;
        }
      }
      function _isDisconnected() {
        return _status === 'disconnecting' || _status === 'disconnected';
      }
      function _nextMessageId() {
        var result = ++_messageId;
        return '' + result;
      }
      function _applyExtension(scope, callback, name, message, outgoing) {
        try {
          return callback.call(scope, message);
        } catch (x) {
          var handler = _cometd.onExtensionException;
          if (_isFunction(handler)) {
            _cometd._debug('Invoking extension exception handler', name, x);
            try {
              handler.call(_cometd, x, name, outgoing, message);
            } catch (xx) {
              _cometd._info('Exception during execution of extension exception handler', name, xx);
            }
          } else {
            _cometd._info('Exception during execution of extension', name, x);
          }
          return message;
        }
      }
      function _applyIncomingExtensions(message) {
        for (var i = 0; i < _extensions.length; ++i) {
          if (message === undefined || message === null) {
            break;
          }
          var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i;
          var extension = _extensions[index];
          var callback = extension.extension.incoming;
          if (_isFunction(callback)) {
            var result = _applyExtension(extension.extension, callback, extension.name, message, false);
            message = result === undefined ? message : result;
          }
        }
        return message;
      }
      function _applyOutgoingExtensions(message) {
        for (var i = 0; i < _extensions.length; ++i) {
          if (message === undefined || message === null) {
            break;
          }
          var extension = _extensions[i];
          var callback = extension.extension.outgoing;
          if (_isFunction(callback)) {
            var result = _applyExtension(extension.extension, callback, extension.name, message, true);
            message = result === undefined ? message : result;
          }
        }
        return message;
      }
      function _notify(channel, message) {
        var subscriptions = _listeners[channel];
        if (subscriptions) {
          for (var id in subscriptions) {
            if (subscriptions.hasOwnProperty(id)) {
              var subscription = subscriptions[id];
              // Subscriptions may come and go, so the array may have 'holes'
              if (subscription) {
                try {
                  subscription.callback.call(subscription.scope, message);
                } catch (x) {
                  var handler = _cometd.onListenerException;
                  if (_isFunction(handler)) {
                    _cometd._debug('Invoking listener exception handler', subscription, x);
                    try {
                      handler.call(_cometd, x, subscription, subscription.listener, message);
                    } catch (xx) {
                      _cometd._info('Exception during execution of listener exception handler', subscription, xx);
                    }
                  } else {
                    _cometd._info('Exception during execution of listener', subscription, message, x);
                  }
                }
              }
            }
          }
        }
      }
      function _notifyListeners(channel, message) {
        // Notify direct listeners
        _notify(channel, message);
        // Notify the globbing listeners
        var channelParts = channel.split('/');
        var last = channelParts.length - 1;
        for (var i = last; i > 0; --i) {
          var channelPart = channelParts.slice(0, i).join('/') + '/*';
          // We don't want to notify /foo/* if the channel is /foo/bar/baz,
          // so we stop at the first non recursive globbing
          if (i === last) {
            _notify(channelPart, message);
          }
          // Add the recursive globber and notify
          channelPart += '*';
          _notify(channelPart, message);
        }
      }
      function _cancelDelayedSend() {
        if (_scheduledSend !== null) {
          Utils.clearTimeout(_scheduledSend);
        }
        _scheduledSend = null;
      }
      function _delayedSend(operation, delay) {
        _cancelDelayedSend();
        var time = _advice.interval + delay;
        _cometd._debug('Function scheduled in', time, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);
        _scheduledSend = Utils.setTimeout(_cometd, operation, time);
      }
      // Needed to break cyclic dependencies between function definitions
      var _handleMessages;
      var _handleFailure;
      /**
       * Delivers the messages to the CometD server
       * @param sync whether the send is synchronous
       * @param messages the array of messages to send
       * @param metaConnect true if this send is on /meta/connect
       * @param extraPath an extra path to append to the Bayeux server URL
       */
      function _send(sync, messages, metaConnect, extraPath) {
        // We must be sure that the messages have a clientId.
        // This is not guaranteed since the handshake may take time to return
        // (and hence the clientId is not known yet) and the application
        // may create other messages.
        for (var i = 0; i < messages.length; ++i) {
          var message = messages[i];
          var messageId = message.id;
          if (_clientId) {
            message.clientId = _clientId;
          }
          message = _applyOutgoingExtensions(message);
          if (message !== undefined && message !== null) {
            // Extensions may have modified the message id, but we need to own it.
            message.id = messageId;
            messages[i] = message;
          } else {
            delete _callbacks[messageId];
            messages.splice(i--, 1);
          }
        }
        if (messages.length === 0) {
          return;
        }
        var url = _cometd.getURL();
        if (_config.appendMessageTypeToURL) {
          // If url does not end with '/', then append it
          if (!url.match(/\/$/)) {
            url = url + '/';
          }
          if (extraPath) {
            url = url + extraPath;
          }
        }
        var envelope = {
          url: url,
          sync: sync,
          messages: messages,
          onSuccess: function (rcvdMessages) {
            try {
              _handleMessages.call(_cometd, rcvdMessages);
            } catch (x) {
              _cometd._info('Exception during handling of messages', x);
            }
          },
          onFailure: function (conduit, messages, failure) {
            try {
              var transport = _cometd.getTransport();
              failure.connectionType = transport ? transport.getType() : 'unknown';
              _handleFailure.call(_cometd, conduit, messages, failure);
            } catch (x) {
              _cometd._info('Exception during handling of failure', x);
            }
          }
        };
        _cometd._debug('Send', envelope);
        _transport.send(envelope, metaConnect);
      }
      function _queueSend(message) {
        if (_batch > 0 || _internalBatch === true) {
          _messageQueue.push(message);
        } else {
          _send(false, [message], false);
        }
      }
      /**
       * Sends a complete bayeux message.
       * This method is exposed as a public so that extensions may use it
       * to send bayeux message directly, for example in case of re-sending
       * messages that have already been sent but that for some reason must
       * be resent.
       */
      this.send = _queueSend;
      function _resetBackoff() {
        _backoff = 0;
      }
      function _increaseBackoff() {
        if (_backoff < _config.maxBackoff) {
          _backoff += _config.backoffIncrement;
        }
        return _backoff;
      }
      /**
       * Starts a the batch of messages to be sent in a single request.
       * @see #_endBatch(sendMessages)
       */
      function _startBatch() {
        ++_batch;
        _cometd._debug('Starting batch, depth', _batch);
      }
      function _flushBatch() {
        var messages = _messageQueue;
        _messageQueue = [];
        if (messages.length > 0) {
          _send(false, messages, false);
        }
      }
      /**
       * Ends the batch of messages to be sent in a single request,
       * optionally sending messages present in the message queue depending
       * on the given argument.
       * @see #_startBatch()
       */
      function _endBatch() {
        --_batch;
        _cometd._debug('Ending batch, depth', _batch);
        if (_batch < 0) {
          throw 'Calls to startBatch() and endBatch() are not paired';
        }
        if (_batch === 0 && !_isDisconnected() && !_internalBatch) {
          _flushBatch();
        }
      }
      /**
       * Sends the connect message
       */
      function _connect() {
        if (!_isDisconnected()) {
          var bayeuxMessage = {
            id: _nextMessageId(),
            channel: '/meta/connect',
            connectionType: _transport.getType()
          };
          // In case of reload or temporary loss of connection
          // we want the next successful connect to return immediately
          // instead of being held by the server, so that connect listeners
          // can be notified that the connection has been re-established
          if (!_connected) {
            bayeuxMessage.advice = { timeout: 0 };
          }
          _setStatus('connecting');
          _cometd._debug('Connect sent', bayeuxMessage);
          _send(false, [bayeuxMessage], true, 'connect');
          _setStatus('connected');
        }
      }
      function _delayedConnect(delay) {
        _setStatus('connecting');
        _delayedSend(function () {
          _connect();
        }, delay);
      }
      function _updateAdvice(newAdvice) {
        if (newAdvice) {
          _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);
          _cometd._debug('New advice', _advice);
        }
      }
      function _disconnect(abort) {
        _cancelDelayedSend();
        if (abort && _transport) {
          _transport.abort();
        }
        _clientId = null;
        _setStatus('disconnected');
        _batch = 0;
        _resetBackoff();
        _transport = null;
        _reestablish = false;
        _connected = false;
        // Fail any existing queued message
        if (_messageQueue.length > 0) {
          var messages = _messageQueue;
          _messageQueue = [];
          _handleFailure.call(_cometd, undefined, messages, { reason: 'Disconnected' });
        }
      }
      function _notifyTransportException(oldTransport, newTransport, failure) {
        var handler = _cometd.onTransportException;
        if (_isFunction(handler)) {
          _cometd._debug('Invoking transport exception handler', oldTransport, newTransport, failure);
          try {
            handler.call(_cometd, failure, oldTransport, newTransport);
          } catch (x) {
            _cometd._info('Exception during execution of transport exception handler', x);
          }
        }
      }
      /**
       * Sends the initial handshake message
       */
      function _handshake(handshakeProps, handshakeCallback) {
        if (_isFunction(handshakeProps)) {
          handshakeCallback = handshakeProps;
          handshakeProps = undefined;
        }
        _clientId = null;
        _clearSubscriptions();
        // Reset the transports if we're not retrying the handshake
        if (_isDisconnected()) {
          _transports.reset(true);
          _updateAdvice(_config.advice);
        }
        _batch = 0;
        // Mark the start of an internal batch.
        // This is needed because handshake and connect are async.
        // It may happen that the application calls init() then subscribe()
        // and the subscribe message is sent before the connect message, if
        // the subscribe message is not held until the connect message is sent.
        // So here we start a batch to hold temporarily any message until
        // the connection is fully established.
        _internalBatch = true;
        // Save the properties provided by the user, so that
        // we can reuse them during automatic re-handshake
        _handshakeProps = handshakeProps;
        _handshakeCallback = handshakeCallback;
        var version = '1.0';
        // Figure out the transports to send to the server
        var url = _cometd.getURL();
        var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);
        var bayeuxMessage = {
          id: _nextMessageId(),
          version: version,
          minimumVersion: version,
          channel: '/meta/handshake',
          supportedConnectionTypes: transportTypes,
          advice: {
            timeout: _advice.timeout,
            interval: _advice.interval
          }
        };
        // Do not allow the user to override important fields.
        var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);
        // Save the callback.
        _cometd._putCallback(message.id, handshakeCallback);
        // Pick up the first available transport as initial transport
        // since we don't know if the server supports it
        if (!_transport) {
          _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
          if (!_transport) {
            var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();
            _cometd._warn(failure);
            throw failure;
          }
        }
        _cometd._debug('Initial transport is', _transport.getType());
        // We started a batch to hold the application messages,
        // so here we must bypass it and send immediately.
        _setStatus('handshaking');
        _cometd._debug('Handshake sent', message);
        _send(false, [message], false, 'handshake');
      }
      function _delayedHandshake(delay) {
        _setStatus('handshaking');
        // We will call _handshake() which will reset _clientId, but we want to avoid
        // that between the end of this method and the call to _handshake() someone may
        // call publish() (or other methods that call _queueSend()).
        _internalBatch = true;
        _delayedSend(function () {
          _handshake(_handshakeProps, _handshakeCallback);
        }, delay);
      }
      function _notifyCallback(callback, message) {
        try {
          callback.call(_cometd, message);
        } catch (x) {
          var handler = _cometd.onCallbackException;
          if (_isFunction(handler)) {
            _cometd._debug('Invoking callback exception handler', x);
            try {
              handler.call(_cometd, x, message);
            } catch (xx) {
              _cometd._info('Exception during execution of callback exception handler', xx);
            }
          } else {
            _cometd._info('Exception during execution of message callback', x);
          }
        }
      }
      this._getCallback = function (messageId) {
        return _callbacks[messageId];
      };
      this._putCallback = function (messageId, callback) {
        var result = this._getCallback(messageId);
        if (_isFunction(callback)) {
          _callbacks[messageId] = callback;
        }
        return result;
      };
      function _handleCallback(message) {
        var callback = _cometd._getCallback([message.id]);
        if (_isFunction(callback)) {
          delete _callbacks[message.id];
          _notifyCallback(callback, message);
        }
      }
      function _handleRemoteCall(message) {
        var context = _remoteCalls[message.id];
        delete _remoteCalls[message.id];
        if (context) {
          _cometd._debug('Handling remote call response for', message, 'with context', context);
          // Clear the timeout, if present.
          var timeout = context.timeout;
          if (timeout) {
            Utils.clearTimeout(timeout);
          }
          var callback = context.callback;
          if (_isFunction(callback)) {
            _notifyCallback(callback, message);
            return true;
          }
        }
        return false;
      }
      this.onTransportFailure = function (message, failureInfo, failureHandler) {
        this._debug('Transport failure', failureInfo, 'for', message);
        var transports = this.getTransportRegistry();
        var url = this.getURL();
        var crossDomain = this._isCrossDomain(_splitURL(url)[2]);
        var version = '1.0';
        var transportTypes = transports.findTransportTypes(version, crossDomain, url);
        if (failureInfo.action === 'none') {
          if (message.channel === '/meta/handshake') {
            if (!failureInfo.transport) {
              var failure = 'Could not negotiate transport, client=[' + transportTypes + '], server=[' + message.supportedConnectionTypes + ']';
              this._warn(failure);
              _notifyTransportException(_transport.getType(), null, {
                reason: failure,
                connectionType: _transport.getType(),
                transport: _transport
              });
            }
          }
        } else {
          failureInfo.delay = this.getBackoffPeriod();
          // Different logic depending on whether we are handshaking or connecting.
          if (message.channel === '/meta/handshake') {
            if (!failureInfo.transport) {
              // The transport is invalid, try to negotiate again.
              var newTransport = transports.negotiateTransport(transportTypes, version, crossDomain, url);
              if (!newTransport) {
                this._warn('Could not negotiate transport, client=[' + transportTypes + ']');
                _notifyTransportException(_transport.getType(), null, message.failure);
                failureInfo.action = 'none';
              } else {
                this._debug('Transport', _transport.getType(), '->', newTransport.getType());
                _notifyTransportException(_transport.getType(), newTransport.getType(), message.failure);
                failureInfo.action = 'handshake';
                failureInfo.transport = newTransport;
              }
            }
            if (failureInfo.action !== 'none') {
              this.increaseBackoffPeriod();
            }
          } else {
            var now = new Date().getTime();
            if (_unconnectTime === 0) {
              _unconnectTime = now;
            }
            if (failureInfo.action === 'retry') {
              failureInfo.delay = this.increaseBackoffPeriod();
              // Check whether we may switch to handshaking.
              var maxInterval = _advice.maxInterval;
              if (maxInterval > 0) {
                var expiration = _advice.timeout + _advice.interval + maxInterval;
                var unconnected = now - _unconnectTime;
                if (unconnected + _backoff > expiration) {
                  failureInfo.action = 'handshake';
                }
              }
            }
            if (failureInfo.action === 'handshake') {
              failureInfo.delay = 0;
              transports.reset(false);
              this.resetBackoffPeriod();
            }
          }
        }
        failureHandler.call(_cometd, failureInfo);
      };
      function _handleTransportFailure(failureInfo) {
        _cometd._debug('Transport failure handling', failureInfo);
        if (failureInfo.transport) {
          _transport = failureInfo.transport;
        }
        if (failureInfo.url) {
          _transport.setURL(failureInfo.url);
        }
        var action = failureInfo.action;
        var delay = failureInfo.delay || 0;
        switch (action) {
        case 'handshake':
          _delayedHandshake(delay);
          break;
        case 'retry':
          _delayedConnect(delay);
          break;
        case 'none':
          _disconnect(true);
          break;
        default:
          throw 'Unknown action ' + action;
        }
      }
      function _failHandshake(message, failureInfo) {
        _handleCallback(message);
        _notifyListeners('/meta/handshake', message);
        _notifyListeners('/meta/unsuccessful', message);
        // The listeners may have disconnected.
        if (_isDisconnected()) {
          failureInfo.action = 'none';
        }
        _cometd.onTransportFailure.call(_cometd, message, failureInfo, _handleTransportFailure);
      }
      function _handshakeResponse(message) {
        var url = _cometd.getURL();
        if (message.successful) {
          var crossDomain = _cometd._isCrossDomain(_splitURL(url)[2]);
          var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, crossDomain, url);
          if (newTransport === null) {
            message.successful = false;
            _failHandshake(message, {
              cause: 'negotiation',
              action: 'none',
              transport: null
            });
            return;
          } else if (_transport !== newTransport) {
            _cometd._debug('Transport', _transport.getType(), '->', newTransport.getType());
            _transport = newTransport;
          }
          _clientId = message.clientId;
          // End the internal batch and allow held messages from the application
          // to go to the server (see _handshake() where we start the internal batch).
          _internalBatch = false;
          _flushBatch();
          // Here the new transport is in place, as well as the clientId, so
          // the listeners can perform a publish() if they want.
          // Notify the listeners before the connect below.
          message.reestablish = _reestablish;
          _reestablish = true;
          _handleCallback(message);
          _notifyListeners('/meta/handshake', message);
          _handshakeMessages = message['x-messages'] || 0;
          var action = _isDisconnected() ? 'none' : _advice.reconnect || 'retry';
          switch (action) {
          case 'retry':
            _resetBackoff();
            if (_handshakeMessages === 0) {
              _delayedConnect(0);
            } else {
              _cometd._debug('Processing', _handshakeMessages, 'handshake-delivered messages');
            }
            break;
          case 'none':
            _disconnect(true);
            break;
          default:
            throw 'Unrecognized advice action ' + action;
          }
        } else {
          _failHandshake(message, {
            cause: 'unsuccessful',
            action: _advice.reconnect || 'handshake',
            transport: _transport
          });
        }
      }
      function _handshakeFailure(message) {
        _failHandshake(message, {
          cause: 'failure',
          action: 'handshake',
          transport: null
        });
      }
      function _failConnect(message, failureInfo) {
        // Notify the listeners after the status change but before the next action.
        _notifyListeners('/meta/connect', message);
        _notifyListeners('/meta/unsuccessful', message);
        // The listeners may have disconnected.
        if (_isDisconnected()) {
          failureInfo.action = 'none';
        }
        _cometd.onTransportFailure.call(_cometd, message, failureInfo, _handleTransportFailure);
      }
      function _connectResponse(message) {
        _connected = message.successful;
        if (_connected) {
          _notifyListeners('/meta/connect', message);
          // Normally, the advice will say "reconnect: 'retry', interval: 0"
          // and the server will hold the request, so when a response returns
          // we immediately call the server again (long polling).
          // Listeners can call disconnect(), so check the state after they run.
          var action = _isDisconnected() ? 'none' : _advice.reconnect || 'retry';
          switch (action) {
          case 'retry':
            _resetBackoff();
            _delayedConnect(_backoff);
            break;
          case 'none':
            _disconnect(false);
            break;
          default:
            throw 'Unrecognized advice action ' + action;
          }
        } else {
          _failConnect(message, {
            cause: 'unsuccessful',
            action: _advice.reconnect || 'retry',
            transport: _transport
          });
        }
      }
      function _connectFailure(message) {
        _connected = false;
        _failConnect(message, {
          cause: 'failure',
          action: 'retry',
          transport: null
        });
      }
      function _failDisconnect(message) {
        _disconnect(true);
        _handleCallback(message);
        _notifyListeners('/meta/disconnect', message);
        _notifyListeners('/meta/unsuccessful', message);
      }
      function _disconnectResponse(message) {
        if (message.successful) {
          // Wait for the /meta/connect to arrive.
          _disconnect(false);
          _handleCallback(message);
          _notifyListeners('/meta/disconnect', message);
        } else {
          _failDisconnect(message);
        }
      }
      function _disconnectFailure(message) {
        _failDisconnect(message);
      }
      function _failSubscribe(message) {
        var subscriptions = _listeners[message.subscription];
        if (subscriptions) {
          for (var id in subscriptions) {
            if (subscriptions.hasOwnProperty(id)) {
              var subscription = subscriptions[id];
              if (subscription && !subscription.listener) {
                delete subscriptions[id];
                _cometd._debug('Removed failed subscription', subscription);
              }
            }
          }
        }
        _handleCallback(message);
        _notifyListeners('/meta/subscribe', message);
        _notifyListeners('/meta/unsuccessful', message);
      }
      function _subscribeResponse(message) {
        if (message.successful) {
          _handleCallback(message);
          _notifyListeners('/meta/subscribe', message);
        } else {
          _failSubscribe(message);
        }
      }
      function _subscribeFailure(message) {
        _failSubscribe(message);
      }
      function _failUnsubscribe(message) {
        _handleCallback(message);
        _notifyListeners('/meta/unsubscribe', message);
        _notifyListeners('/meta/unsuccessful', message);
      }
      function _unsubscribeResponse(message) {
        if (message.successful) {
          _handleCallback(message);
          _notifyListeners('/meta/unsubscribe', message);
        } else {
          _failUnsubscribe(message);
        }
      }
      function _unsubscribeFailure(message) {
        _failUnsubscribe(message);
      }
      function _failMessage(message) {
        if (!_handleRemoteCall(message)) {
          _handleCallback(message);
          _notifyListeners('/meta/publish', message);
          _notifyListeners('/meta/unsuccessful', message);
        }
      }
      function _messageResponse(message) {
        if (message.data !== undefined) {
          if (!_handleRemoteCall(message)) {
            _notifyListeners(message.channel, message);
            if (_handshakeMessages > 0) {
              --_handshakeMessages;
              if (_handshakeMessages === 0) {
                _cometd._debug('Processed last handshake-delivered message');
                _delayedConnect(0);
              }
            }
          }
        } else {
          if (message.successful === undefined) {
            _cometd._warn('Unknown Bayeux Message', message);
          } else {
            if (message.successful) {
              _handleCallback(message);
              _notifyListeners('/meta/publish', message);
            } else {
              _failMessage(message);
            }
          }
        }
      }
      function _messageFailure(failure) {
        _failMessage(failure);
      }
      function _receive(message) {
        _unconnectTime = 0;
        message = _applyIncomingExtensions(message);
        if (message === undefined || message === null) {
          return;
        }
        _updateAdvice(message.advice);
        var channel = message.channel;
        switch (channel) {
        case '/meta/handshake':
          _handshakeResponse(message);
          break;
        case '/meta/connect':
          _connectResponse(message);
          break;
        case '/meta/disconnect':
          _disconnectResponse(message);
          break;
        case '/meta/subscribe':
          _subscribeResponse(message);
          break;
        case '/meta/unsubscribe':
          _unsubscribeResponse(message);
          break;
        default:
          _messageResponse(message);
          break;
        }
      }
      /**
       * Receives a message.
       * This method is exposed as a public so that extensions may inject
       * messages simulating that they had been received.
       */
      this.receive = _receive;
      _handleMessages = function (rcvdMessages) {
        _cometd._debug('Received', rcvdMessages);
        for (var i = 0; i < rcvdMessages.length; ++i) {
          var message = rcvdMessages[i];
          _receive(message);
        }
      };
      _handleFailure = function (conduit, messages, failure) {
        _cometd._debug('handleFailure', conduit, messages, failure);
        failure.transport = conduit;
        for (var i = 0; i < messages.length; ++i) {
          var message = messages[i];
          var failureMessage = {
            id: message.id,
            successful: false,
            channel: message.channel,
            failure: failure
          };
          failure.message = message;
          switch (message.channel) {
          case '/meta/handshake':
            _handshakeFailure(failureMessage);
            break;
          case '/meta/connect':
            _connectFailure(failureMessage);
            break;
          case '/meta/disconnect':
            _disconnectFailure(failureMessage);
            break;
          case '/meta/subscribe':
            failureMessage.subscription = message.subscription;
            _subscribeFailure(failureMessage);
            break;
          case '/meta/unsubscribe':
            failureMessage.subscription = message.subscription;
            _unsubscribeFailure(failureMessage);
            break;
          default:
            _messageFailure(failureMessage);
            break;
          }
        }
      };
      function _hasSubscriptions(channel) {
        var subscriptions = _listeners[channel];
        if (subscriptions) {
          for (var id in subscriptions) {
            if (subscriptions.hasOwnProperty(id)) {
              if (subscriptions[id]) {
                return true;
              }
            }
          }
        }
        return false;
      }
      function _resolveScopedCallback(scope, callback) {
        var delegate = {
          scope: scope,
          method: callback
        };
        if (_isFunction(scope)) {
          delegate.scope = undefined;
          delegate.method = scope;
        } else {
          if (_isString(callback)) {
            if (!scope) {
              throw 'Invalid scope ' + scope;
            }
            delegate.method = scope[callback];
            if (!_isFunction(delegate.method)) {
              throw 'Invalid callback ' + callback + ' for scope ' + scope;
            }
          } else if (!_isFunction(callback)) {
            throw 'Invalid callback ' + callback;
          }
        }
        return delegate;
      }
      function _addListener(channel, scope, callback, isListener) {
        // The data structure is a map<channel, subscription[]>, where each subscription
        // holds the callback to be called and its scope.
        var delegate = _resolveScopedCallback(scope, callback);
        _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);
        var id = ++_listenerId;
        var subscription = {
          id: id,
          channel: channel,
          scope: delegate.scope,
          callback: delegate.method,
          listener: isListener
        };
        var subscriptions = _listeners[channel];
        if (!subscriptions) {
          subscriptions = {};
          _listeners[channel] = subscriptions;
        }
        subscriptions[id] = subscription;
        _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);
        return subscription;
      }
      //
      // PUBLIC API
      //
      /**
       * Registers the given transport under the given transport type.
       * The optional index parameter specifies the "priority" at which the
       * transport is registered (where 0 is the max priority).
       * If a transport with the same type is already registered, this function
       * does nothing and returns false.
       * @param type the transport type
       * @param transport the transport object
       * @param index the index at which this transport is to be registered
       * @return true if the transport has been registered, false otherwise
       * @see #unregisterTransport(type)
       */
      this.registerTransport = function (type, transport, index) {
        var result = _transports.add(type, transport, index);
        if (result) {
          this._debug('Registered transport', type);
          if (_isFunction(transport.registered)) {
            transport.registered(type, this);
          }
        }
        return result;
      };
      /**
       * Unregisters the transport with the given transport type.
       * @param type the transport type to unregister
       * @return the transport that has been unregistered,
       * or null if no transport was previously registered under the given transport type
       */
      this.unregisterTransport = function (type) {
        var transport = _transports.remove(type);
        if (transport !== null) {
          this._debug('Unregistered transport', type);
          if (_isFunction(transport.unregistered)) {
            transport.unregistered();
          }
        }
        return transport;
      };
      this.unregisterTransports = function () {
        _transports.clear();
      };
      /**
       * @return an array of all registered transport types
       */
      this.getTransportTypes = function () {
        return _transports.getTransportTypes();
      };
      this.findTransport = function (name) {
        return _transports.find(name);
      };
      /**
       * @returns the TransportRegistry object
       */
      this.getTransportRegistry = function () {
        return _transports;
      };
      /**
       * Configures the initial Bayeux communication with the Bayeux server.
       * Configuration is passed via an object that must contain a mandatory field <code>url</code>
       * of type string containing the URL of the Bayeux server.
       * @param configuration the configuration object
       */
      this.configure = function (configuration) {
        _configure.call(this, configuration);
      };
      /**
       * Configures and establishes the Bayeux communication with the Bayeux server
       * via a handshake and a subsequent connect.
       * @param configuration the configuration object
       * @param handshakeProps an object to be merged with the handshake message
       * @see #configure(configuration)
       * @see #handshake(handshakeProps)
       */
      this.init = function (configuration, handshakeProps) {
        this.configure(configuration);
        this.handshake(handshakeProps);
      };
      /**
       * Establishes the Bayeux communication with the Bayeux server
       * via a handshake and a subsequent connect.
       * @param handshakeProps an object to be merged with the handshake message
       * @param handshakeCallback a function to be invoked when the handshake is acknowledged
       */
      this.handshake = function (handshakeProps, handshakeCallback) {
        if (_status !== 'disconnected') {
          throw 'Illegal state: handshaken';
        }
        _handshake(handshakeProps, handshakeCallback);
      };
      /**
       * Disconnects from the Bayeux server.
       * It is possible to suggest to attempt a synchronous disconnect, but this feature
       * may only be available in certain transports (for example, long-polling may support
       * it, callback-polling certainly does not).
       * @param sync whether attempt to perform a synchronous disconnect
       * @param disconnectProps an object to be merged with the disconnect message
       * @param disconnectCallback a function to be invoked when the disconnect is acknowledged
       */
      this.disconnect = function (sync, disconnectProps, disconnectCallback) {
        if (_isDisconnected()) {
          return;
        }
        if (typeof sync !== 'boolean') {
          disconnectCallback = disconnectProps;
          disconnectProps = sync;
          sync = false;
        }
        if (_isFunction(disconnectProps)) {
          disconnectCallback = disconnectProps;
          disconnectProps = undefined;
        }
        var bayeuxMessage = {
          id: _nextMessageId(),
          channel: '/meta/disconnect'
        };
        // Do not allow the user to override important fields.
        var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);
        // Save the callback.
        _cometd._putCallback(message.id, disconnectCallback);
        _setStatus('disconnecting');
        _send(sync === true, [message], false, 'disconnect');
      };
      /**
       * Marks the start of a batch of application messages to be sent to the server
       * in a single request, obtaining a single response containing (possibly) many
       * application reply messages.
       * Messages are held in a queue and not sent until {@link #endBatch()} is called.
       * If startBatch() is called multiple times, then an equal number of endBatch()
       * calls must be made to close and send the batch of messages.
       * @see #endBatch()
       */
      this.startBatch = function () {
        _startBatch();
      };
      /**
       * Marks the end of a batch of application messages to be sent to the server
       * in a single request.
       * @see #startBatch()
       */
      this.endBatch = function () {
        _endBatch();
      };
      /**
       * Executes the given callback in the given scope, surrounded by a {@link #startBatch()}
       * and {@link #endBatch()} calls.
       * @param scope the scope of the callback, may be omitted
       * @param callback the callback to be executed within {@link #startBatch()} and {@link #endBatch()} calls
       */
      this.batch = function (scope, callback) {
        var delegate = _resolveScopedCallback(scope, callback);
        this.startBatch();
        try {
          delegate.method.call(delegate.scope);
          this.endBatch();
        } catch (x) {
          this._info('Exception during execution of batch', x);
          this.endBatch();
          throw x;
        }
      };
      /**
       * Adds a listener for bayeux messages, performing the given callback in the given scope
       * when a message for the given channel arrives.
       * @param channel the channel the listener is interested to
       * @param scope the scope of the callback, may be omitted
       * @param callback the callback to call when a message is sent to the channel
       * @returns the subscription handle to be passed to {@link #removeListener(object)}
       * @see #removeListener(subscription)
       */
      this.addListener = function (channel, scope, callback) {
        if (arguments.length < 2) {
          throw 'Illegal arguments number: required 2, got ' + arguments.length;
        }
        if (!_isString(channel)) {
          throw 'Illegal argument type: channel must be a string';
        }
        return _addListener(channel, scope, callback, true);
      };
      /**
       * Removes the subscription obtained with a call to {@link #addListener(string, object, function)}.
       * @param subscription the subscription to unsubscribe.
       * @see #addListener(channel, scope, callback)
       */
      this.removeListener = function (subscription) {
        // Beware of subscription.id == 0, which is falsy => cannot use !subscription.id
        if (!subscription || !subscription.channel || !('id' in subscription)) {
          throw 'Invalid argument: expected subscription, not ' + subscription;
        }
        _removeListener(subscription);
      };
      /**
       * Removes all listeners registered with {@link #addListener(channel, scope, callback)} or
       * {@link #subscribe(channel, scope, callback)}.
       */
      this.clearListeners = function () {
        _listeners = {};
      };
      /**
       * Subscribes to the given channel, performing the given callback in the given scope
       * when a message for the channel arrives.
       * @param channel the channel to subscribe to
       * @param scope the scope of the callback, may be omitted
       * @param callback the callback to call when a message is sent to the channel
       * @param subscribeProps an object to be merged with the subscribe message
       * @param subscribeCallback a function to be invoked when the subscription is acknowledged
       * @return the subscription handle to be passed to {@link #unsubscribe(object)}
       */
      this.subscribe = function (channel, scope, callback, subscribeProps, subscribeCallback) {
        if (arguments.length < 2) {
          throw 'Illegal arguments number: required 2, got ' + arguments.length;
        }
        if (!_isString(channel)) {
          throw 'Illegal argument type: channel must be a string';
        }
        if (_isDisconnected()) {
          throw 'Illegal state: disconnected';
        }
        // Normalize arguments
        if (_isFunction(scope)) {
          subscribeCallback = subscribeProps;
          subscribeProps = callback;
          callback = scope;
          scope = undefined;
        }
        if (_isFunction(subscribeProps)) {
          subscribeCallback = subscribeProps;
          subscribeProps = undefined;
        }
        // Only send the message to the server if this client has not yet subscribed to the channel
        var send = !_hasSubscriptions(channel);
        var subscription = _addListener(channel, scope, callback, false);
        if (send) {
          // Send the subscription message after the subscription registration to avoid
          // races where the server would send a message to the subscribers, but here
          // on the client the subscription has not been added yet to the data structures
          var bayeuxMessage = {
            id: _nextMessageId(),
            channel: '/meta/subscribe',
            subscription: channel
          };
          // Do not allow the user to override important fields.
          var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);
          // Save the callback.
          _cometd._putCallback(message.id, subscribeCallback);
          _queueSend(message);
        }
        return subscription;
      };
      /**
       * Unsubscribes the subscription obtained with a call to {@link #subscribe(string, object, function)}.
       * @param subscription the subscription to unsubscribe.
       * @param unsubscribeProps an object to be merged with the unsubscribe message
       * @param unsubscribeCallback a function to be invoked when the unsubscription is acknowledged
       */
      this.unsubscribe = function (subscription, unsubscribeProps, unsubscribeCallback) {
        if (arguments.length < 1) {
          throw 'Illegal arguments number: required 1, got ' + arguments.length;
        }
        if (_isDisconnected()) {
          throw 'Illegal state: disconnected';
        }
        if (_isFunction(unsubscribeProps)) {
          unsubscribeCallback = unsubscribeProps;
          unsubscribeProps = undefined;
        }
        // Remove the local listener before sending the message
        // This ensures that if the server fails, this client does not get notifications
        this.removeListener(subscription);
        var channel = subscription.channel;
        // Only send the message to the server if this client unsubscribes the last subscription
        if (!_hasSubscriptions(channel)) {
          var bayeuxMessage = {
            id: _nextMessageId(),
            channel: '/meta/unsubscribe',
            subscription: channel
          };
          // Do not allow the user to override important fields.
          var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);
          // Save the callback.
          _cometd._putCallback(message.id, unsubscribeCallback);
          _queueSend(message);
        }
      };
      this.resubscribe = function (subscription, subscribeProps) {
        _removeSubscription(subscription);
        if (subscription) {
          return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);
        }
        return undefined;
      };
      /**
       * Removes all subscriptions added via {@link #subscribe(channel, scope, callback, subscribeProps)},
       * but does not remove the listeners added via {@link addListener(channel, scope, callback)}.
       */
      this.clearSubscriptions = function () {
        _clearSubscriptions();
      };
      /**
       * Publishes a message on the given channel, containing the given content.
       * @param channel the channel to publish the message to
       * @param content the content of the message
       * @param publishProps an object to be merged with the publish message
       * @param publishCallback a function to be invoked when the publish is acknowledged by the server
       */
      this.publish = function (channel, content, publishProps, publishCallback) {
        if (arguments.length < 1) {
          throw 'Illegal arguments number: required 1, got ' + arguments.length;
        }
        if (!_isString(channel)) {
          throw 'Illegal argument type: channel must be a string';
        }
        if (/^\/meta\//.test(channel)) {
          throw 'Illegal argument: cannot publish to meta channels';
        }
        if (_isDisconnected()) {
          throw 'Illegal state: disconnected';
        }
        if (_isFunction(content)) {
          publishCallback = content;
          content = {};
          publishProps = undefined;
        } else if (_isFunction(publishProps)) {
          publishCallback = publishProps;
          publishProps = undefined;
        }
        var bayeuxMessage = {
          id: _nextMessageId(),
          channel: channel,
          data: content
        };
        // Do not allow the user to override important fields.
        var message = this._mixin(false, {}, publishProps, bayeuxMessage);
        // Save the callback.
        _cometd._putCallback(message.id, publishCallback);
        _queueSend(message);
      };
      /**
       * Publishes a message with binary data on the given channel.
       * The binary data chunk may be an ArrayBuffer, a DataView, a TypedArray
       * (such as Uint8Array) or a plain integer array.
       * The meta data object may contain additional application data such as
       * a file name, a mime type, etc.
       * @param channel the channel to publish the message to
       * @param data the binary data to publish
       * @param last whether the binary data chunk is the last
       * @param meta an object containing meta data associated to the binary chunk
       * @param callback a function to be invoked when the publish is acknowledged by the server
       */
      this.publishBinary = function (channel, data, last, meta, callback) {
        if (_isFunction(data)) {
          callback = data;
          data = new ArrayBuffer(0);
          last = true;
          meta = undefined;
        } else if (_isFunction(last)) {
          callback = last;
          last = true;
          meta = undefined;
        } else if (_isFunction(meta)) {
          callback = meta;
          meta = undefined;
        }
        var content = {
          meta: meta,
          data: data,
          last: last
        };
        var ext = { ext: { binary: {} } };
        this.publish(channel, content, ext, callback);
      };
      this.remoteCall = function (target, content, timeout, callProps, callback) {
        if (arguments.length < 1) {
          throw 'Illegal arguments number: required 1, got ' + arguments.length;
        }
        if (!_isString(target)) {
          throw 'Illegal argument type: target must be a string';
        }
        if (_isDisconnected()) {
          throw 'Illegal state: disconnected';
        }
        if (_isFunction(content)) {
          callback = content;
          content = {};
          timeout = _config.maxNetworkDelay;
          callProps = undefined;
        } else if (_isFunction(timeout)) {
          callback = timeout;
          timeout = _config.maxNetworkDelay;
          callProps = undefined;
        } else if (_isFunction(callProps)) {
          callback = callProps;
          callProps = undefined;
        }
        if (typeof timeout !== 'number') {
          throw 'Illegal argument type: timeout must be a number';
        }
        if (!target.match(/^\//)) {
          target = '/' + target;
        }
        var channel = '/service' + target;
        var bayeuxMessage = {
          id: _nextMessageId(),
          channel: channel,
          data: content
        };
        var message = this._mixin(false, {}, callProps, bayeuxMessage);
        var context = { callback: callback };
        if (timeout > 0) {
          context.timeout = Utils.setTimeout(_cometd, function () {
            _cometd._debug('Timing out remote call', message, 'after', timeout, 'ms');
            _failMessage({
              id: message.id,
              error: '406::timeout',
              successful: false,
              failure: {
                message: message,
                reason: 'Remote Call Timeout'
              }
            });
          }, timeout);
          _cometd._debug('Scheduled remote call timeout', message, 'in', timeout, 'ms');
        }
        _remoteCalls[message.id] = context;
        _queueSend(message);
      };
      this.remoteCallBinary = function (target, data, last, meta, timeout, callback) {
        if (_isFunction(data)) {
          callback = data;
          data = new ArrayBuffer(0);
          last = true;
          meta = undefined;
          timeout = _config.maxNetworkDelay;
        } else if (_isFunction(last)) {
          callback = last;
          last = true;
          meta = undefined;
          timeout = _config.maxNetworkDelay;
        } else if (_isFunction(meta)) {
          callback = meta;
          meta = undefined;
          timeout = _config.maxNetworkDelay;
        } else if (_isFunction(timeout)) {
          callback = timeout;
          timeout = _config.maxNetworkDelay;
        }
        var content = {
          meta: meta,
          data: data,
          last: last
        };
        var ext = { ext: { binary: {} } };
        this.remoteCall(target, content, timeout, ext, callback);
      };
      /**
       * Returns a string representing the status of the bayeux communication with the Bayeux server.
       */
      this.getStatus = function () {
        return _status;
      };
      /**
       * Returns whether this instance has been disconnected.
       */
      this.isDisconnected = _isDisconnected;
      /**
       * Sets the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.
       * Default value is 1 second, which means if there is a persistent failure the retries will happen
       * after 1 second, then after 2 seconds, then after 3 seconds, etc. So for example with 15 seconds of
       * elapsed time, there will be 5 retries (at 1, 3, 6, 10 and 15 seconds elapsed).
       * @param period the backoff period to set
       * @see #getBackoffIncrement()
       */
      this.setBackoffIncrement = function (period) {
        _config.backoffIncrement = period;
      };
      /**
       * Returns the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.
       * @see #setBackoffIncrement(period)
       */
      this.getBackoffIncrement = function () {
        return _config.backoffIncrement;
      };
      /**
       * Returns the backoff period to wait before retrying an unsuccessful or failed message.
       */
      this.getBackoffPeriod = function () {
        return _backoff;
      };
      /**
       * Increases the backoff period up to the maximum value configured.
       * @returns the backoff period after increment
       * @see getBackoffIncrement
       */
      this.increaseBackoffPeriod = function () {
        return _increaseBackoff();
      };
      /**
       * Resets the backoff period to zero.
       */
      this.resetBackoffPeriod = function () {
        _resetBackoff();
      };
      /**
       * Sets the log level for console logging.
       * Valid values are the strings 'error', 'warn', 'info' and 'debug', from
       * less verbose to more verbose.
       * @param level the log level string
       */
      this.setLogLevel = function (level) {
        _config.logLevel = level;
      };
      /**
           * Registers an extension whose callbacks are called for every incoming message
           * (that comes from the server to this client implementation) and for every
           * outgoing message (that originates from this client implementation for the
           * server).
           * The format of the extension object is the following:
           * <pre>
           * {
       *     incoming: function(message) { ... },
       *     outgoing: function(message) { ... }
       * }
           * </pre>
           * Both properties are optional, but if they are present they will be called
           * respectively for each incoming message and for each outgoing message.
           * @param name the name of the extension
           * @param extension the extension to register
           * @return true if the extension was registered, false otherwise
           * @see #unregisterExtension(name)
           */
      this.registerExtension = function (name, extension) {
        if (arguments.length < 2) {
          throw 'Illegal arguments number: required 2, got ' + arguments.length;
        }
        if (!_isString(name)) {
          throw 'Illegal argument type: extension name must be a string';
        }
        var existing = false;
        for (var i = 0; i < _extensions.length; ++i) {
          var existingExtension = _extensions[i];
          if (existingExtension.name === name) {
            existing = true;
            break;
          }
        }
        if (!existing) {
          _extensions.push({
            name: name,
            extension: extension
          });
          this._debug('Registered extension', name);
          // Callback for extensions
          if (_isFunction(extension.registered)) {
            extension.registered(name, this);
          }
          return true;
        } else {
          this._info('Could not register extension with name', name, 'since another extension with the same name already exists');
          return false;
        }
      };
      /**
       * Unregister an extension previously registered with
       * {@link #registerExtension(name, extension)}.
       * @param name the name of the extension to unregister.
       * @return true if the extension was unregistered, false otherwise
       */
      this.unregisterExtension = function (name) {
        if (!_isString(name)) {
          throw 'Illegal argument type: extension name must be a string';
        }
        var unregistered = false;
        for (var i = 0; i < _extensions.length; ++i) {
          var extension = _extensions[i];
          if (extension.name === name) {
            _extensions.splice(i, 1);
            unregistered = true;
            this._debug('Unregistered extension', name);
            // Callback for extensions
            var ext = extension.extension;
            if (_isFunction(ext.unregistered)) {
              ext.unregistered();
            }
            break;
          }
        }
        return unregistered;
      };
      /**
       * Find the extension registered with the given name.
       * @param name the name of the extension to find
       * @return the extension found or null if no extension with the given name has been registered
       */
      this.getExtension = function (name) {
        for (var i = 0; i < _extensions.length; ++i) {
          var extension = _extensions[i];
          if (extension.name === name) {
            return extension.extension;
          }
        }
        return null;
      };
      /**
       * Returns the name assigned to this CometD object, or the string 'default'
       * if no name has been explicitly passed as parameter to the constructor.
       */
      this.getName = function () {
        return _name;
      };
      /**
       * Returns the clientId assigned by the Bayeux server during handshake.
       */
      this.getClientId = function () {
        return _clientId;
      };
      /**
       * Returns the URL of the Bayeux server.
       */
      this.getURL = function () {
        if (_transport) {
          var url = _transport.getURL();
          if (url) {
            return url;
          }
          url = _config.urls[_transport.getType()];
          if (url) {
            return url;
          }
        }
        return _config.url;
      };
      this.getTransport = function () {
        return _transport;
      };
      this.getConfiguration = function () {
        return this._mixin(true, {}, _config);
      };
      this.getAdvice = function () {
        return this._mixin(true, {}, _advice);
      };
      // Initialize transports.
      if (window.WebSocket) {
        this.registerTransport('websocket', new WebSocketTransport());
      }
      this.registerTransport('long-polling', new LongPollingTransport());  // this.registerTransport('callback-polling', new CallbackPollingTransport());
    };
    var _z85EncodeTable = [
      '0',
      '1',
      '2',
      '3',
      '4',
      '5',
      '6',
      '7',
      '8',
      '9',
      'a',
      'b',
      'c',
      'd',
      'e',
      'f',
      'g',
      'h',
      'i',
      'j',
      'k',
      'l',
      'm',
      'n',
      'o',
      'p',
      'q',
      'r',
      's',
      't',
      'u',
      'v',
      'w',
      'x',
      'y',
      'z',
      'A',
      'B',
      'C',
      'D',
      'E',
      'F',
      'G',
      'H',
      'I',
      'J',
      'K',
      'L',
      'M',
      'N',
      'O',
      'P',
      'Q',
      'R',
      'S',
      'T',
      'U',
      'V',
      'W',
      'X',
      'Y',
      'Z',
      '.',
      '-',
      ':',
      '+',
      '=',
      '^',
      '!',
      '/',
      '*',
      '?',
      '&',
      '<',
      '>',
      '(',
      ')',
      '[',
      ']',
      '{',
      '}',
      '@',
      '%',
      '$',
      '#'
    ];
    var _z85DecodeTable = [
      0,
      68,
      0,
      84,
      83,
      82,
      72,
      0,
      75,
      76,
      70,
      65,
      0,
      63,
      62,
      69,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      64,
      0,
      73,
      66,
      74,
      71,
      81,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      77,
      0,
      78,
      67,
      0,
      0,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      79,
      0,
      80,
      0,
      0
    ];
    var Z85 = {
      encode: function (bytes) {
        var buffer = null;
        if (bytes instanceof ArrayBuffer) {
          buffer = bytes;
        } else if (bytes.buffer instanceof ArrayBuffer) {
          buffer = bytes.buffer;
        } else if (Array.isArray(bytes)) {
          buffer = new Uint8Array(bytes).buffer;
        }
        if (buffer == null) {
          throw 'Cannot Z85 encode ' + bytes;
        }
        var length = buffer.byteLength;
        var remainder = length % 4;
        var padding = 4 - (remainder === 0 ? 4 : remainder);
        var view = new DataView(buffer);
        var result = '';
        var value = 0;
        for (var i = 0; i < length + padding; ++i) {
          var isPadding = i >= length;
          value = value * 256 + (isPadding ? 0 : view.getUint8(i));
          if ((i + 1) % 4 === 0) {
            var divisor = 85 * 85 * 85 * 85;
            for (var j = 5; j > 0; --j) {
              if (!isPadding || j > padding) {
                var code = Math.floor(value / divisor) % 85;
                result += _z85EncodeTable[code];
              }
              divisor /= 85;
            }
            value = 0;
          }
        }
        return result;
      },
      decode: function (string) {
        var remainder = string.length % 5;
        var padding = 5 - (remainder === 0 ? 5 : remainder);
        for (var p = 0; p < padding; ++p) {
          string += _z85EncodeTable[_z85EncodeTable.length - 1];
        }
        var length = string.length;
        var buffer = new ArrayBuffer(length * 4 / 5 - padding);
        var view = new DataView(buffer);
        var value = 0;
        var charIdx = 0;
        var byteIdx = 0;
        for (var i = 0; i < length; ++i) {
          var code = string.charCodeAt(charIdx++) - 32;
          value = value * 85 + _z85DecodeTable[code];
          if (charIdx % 5 === 0) {
            var divisor = 256 * 256 * 256;
            while (divisor >= 1) {
              if (byteIdx < view.byteLength) {
                view.setUint8(byteIdx++, Math.floor(value / divisor) % 256);
              }
              divisor /= 256;
            }
            value = 0;
          }
        }
        return buffer;
      }
    };
    return {
      CometD: CometD,
      Transport: Transport,
      RequestTransport: RequestTransport,
      LongPollingTransport: LongPollingTransport,
      // CallbackPollingTransport: CallbackPollingTransport,
      WebSocketTransport: WebSocketTransport,
      Utils: Utils,
      Z85: Z85
    };
  }));
  dojox_main = function (dojo) {
    // module:
    //		dojox/main
    /*=====
    	return {
    		// summary:
    		//		The dojox package main module; dojox package is somewhat unusual in that the main module currently just provides an empty object.
    		//		Apps should require modules from the dojox packages directly, rather than loading this module.
    	};
    	=====*/
    return dojo.dojox;
  }(dojo__base_kernel);
  dojox = function (main) {
    return main;
  }(dojox_main);
  dojo__base_sniff = function (dojo, lang, has) {
    // module:
    //		dojo/_base/sniff
    /*=====
    	return {
    		// summary:
    		//		Deprecated.   New code should use dojo/sniff.
    		//		This module populates the dojo browser version sniffing properties like dojo.isIE.
    	};
    	=====*/
    if (!has('host-browser')) {
      return has;
    }
    // no idea what this is for, or if it's used
    dojo._name = 'browser';
    lang.mixin(dojo, {
      // isBrowser: Boolean
      //		True if the client is a web-browser
      isBrowser: true,
      // isFF: Number|undefined
      //		Version as a Number if client is FireFox. undefined otherwise. Corresponds to
      //		major detected FireFox version (1.5, 2, 3, etc.)
      isFF: has('ff'),
      // isIE: Number|undefined
      //		Version as a Number if client is MSIE(PC). undefined otherwise. Corresponds to
      //		major detected IE version (6, 7, 8, etc.)
      isIE: has('ie'),
      // isKhtml: Number|undefined
      //		Version as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major
      //		detected version.
      isKhtml: has('khtml'),
      // isWebKit: Number|undefined
      //		Version as a Number if client is a WebKit-derived browser (Konqueror,
      //		Safari, Chrome, etc.). undefined otherwise.
      isWebKit: has('webkit'),
      // isMozilla: Number|undefined
      //		Version as a Number if client is a Mozilla-based browser (Firefox,
      //		SeaMonkey). undefined otherwise. Corresponds to major detected version.
      isMozilla: has('mozilla'),
      // isMoz: Number|undefined
      //		Version as a Number if client is a Mozilla-based browser (Firefox,
      //		SeaMonkey). undefined otherwise. Corresponds to major detected version.
      isMoz: has('mozilla'),
      // isOpera: Number|undefined
      //		Version as a Number if client is Opera. undefined otherwise. Corresponds to
      //		major detected version.
      isOpera: has('opera'),
      // isSafari: Number|undefined
      //		Version as a Number if client is Safari or iPhone. undefined otherwise.
      isSafari: has('safari'),
      // isChrome: Number|undefined
      //		Version as a Number if client is Chrome browser. undefined otherwise.
      isChrome: has('chrome'),
      // isMac: Boolean
      //		True if the client runs on Mac
      isMac: has('mac'),
      // isIos: Number|undefined
      //		Version as a Number if client is iPhone, iPod, or iPad. undefined otherwise.
      isIos: has('ios'),
      // isAndroid: Number|undefined
      //		Version as a Number if client is android browser. undefined otherwise.
      isAndroid: has('android'),
      // isWii: Boolean
      //		True if client is Wii
      isWii: has('wii'),
      // isQuirks: Boolean
      //		Page is in quirks mode.
      isQuirks: has('quirks'),
      // isAir: Boolean
      //		True if client is Adobe Air
      isAir: has('air')
    });
    return has;
  }(dojo__base_kernel, dojo__base_lang, dojo_sniff);
  dojo_dom_form = function (lang, dom, ioq, json) {
    // module:
    //		dojo/dom-form
    function setValue(obj, name, value) {
      // summary:
      //		For the named property in object, set the value. If a value
      //		already exists and it is a string, convert the value to be an
      //		array of values.
      // Skip it if there is no value
      if (value === null) {
        return;
      }
      var val = obj[name];
      if (typeof val == 'string') {
        // inline'd type check
        obj[name] = [
          val,
          value
        ];
      } else if (lang.isArray(val)) {
        val.push(value);
      } else {
        obj[name] = value;
      }
    }
    var exclude = 'file|submit|image|reset|button';
    var form = {
      // summary:
      //		This module defines form-processing functions.
      fieldToObject: function fieldToObject(inputNode) {
        // summary:
        //		Serialize a form field to a JavaScript object.
        // description:
        //		Returns the value encoded in a form field as
        //		as a string or an array of strings. Disabled form elements
        //		and unchecked radio and checkboxes are skipped.	Multi-select
        //		elements are returned as an array of string values.
        // inputNode: DOMNode|String
        // returns: Object
        var ret = null;
        inputNode = dom.byId(inputNode);
        if (inputNode) {
          var _in = inputNode.name, type = (inputNode.type || '').toLowerCase();
          if (_in && type && !inputNode.disabled) {
            if (type == 'radio' || type == 'checkbox') {
              if (inputNode.checked) {
                ret = inputNode.value;
              }
            } else if (inputNode.multiple) {
              ret = [];
              var nodes = [inputNode.firstChild];
              while (nodes.length) {
                for (var node = nodes.pop(); node; node = node.nextSibling) {
                  if (node.nodeType == 1 && node.tagName.toLowerCase() == 'option') {
                    if (node.selected) {
                      ret.push(node.value);
                    }
                  } else {
                    if (node.nextSibling) {
                      nodes.push(node.nextSibling);
                    }
                    if (node.firstChild) {
                      nodes.push(node.firstChild);
                    }
                    break;
                  }
                }
              }
            } else {
              ret = inputNode.value;
            }
          }
        }
        return ret;  // Object
      },
      toObject: function formToObject(formNode) {
        // summary:
        //		Serialize a form node to a JavaScript object.
        // description:
        //		Returns the values encoded in an HTML form as
        //		string properties in an object which it then returns. Disabled form
        //		elements, buttons, and other non-value form elements are skipped.
        //		Multi-select elements are returned as an array of string values.
        // formNode: DOMNode|String
        // example:
        //		This form:
        //		|	<form id="test_form">
        //		|		<input type="text" name="blah" value="blah">
        //		|		<input type="text" name="no_value" value="blah" disabled>
        //		|		<input type="button" name="no_value2" value="blah">
        //		|		<select type="select" multiple name="multi" size="5">
        //		|			<option value="blah">blah</option>
        //		|			<option value="thud" selected>thud</option>
        //		|			<option value="thonk" selected>thonk</option>
        //		|		</select>
        //		|	</form>
        //
        //		yields this object structure as the result of a call to
        //		formToObject():
        //
        //		|	{
        //		|		blah: "blah",
        //		|		multi: [
        //		|			"thud",
        //		|			"thonk"
        //		|		]
        //		|	};
        var ret = {}, elems = dom.byId(formNode).elements;
        for (var i = 0, l = elems.length; i < l; ++i) {
          var item = elems[i], _in = item.name, type = (item.type || '').toLowerCase();
          if (_in && type && exclude.indexOf(type) < 0 && !item.disabled) {
            setValue(ret, _in, form.fieldToObject(item));
            if (type == 'image') {
              ret[_in + '.x'] = ret[_in + '.y'] = ret[_in].x = ret[_in].y = 0;
            }
          }
        }
        return ret;  // Object
      },
      toQuery: function formToQuery(formNode) {
        // summary:
        //		Returns a URL-encoded string representing the form passed as either a
        //		node or string ID identifying the form to serialize
        // formNode: DOMNode|String
        // returns: String
        return ioq.objectToQuery(form.toObject(formNode));  // String
      },
      toJson: function formToJson(formNode, prettyPrint) {
        // summary:
        //		Create a serialized JSON string from a form node or string
        //		ID identifying the form to serialize
        // formNode: DOMNode|String
        // prettyPrint: Boolean?
        // returns: String
        return json.stringify(form.toObject(formNode), null, prettyPrint ? 4 : 0);  // String
      }
    };
    return form;
  }(dojo__base_lang, dojo_dom, dojo_io_query, dojo_json);
  dojo_when = function (Deferred, Promise) {
    // module:
    //		dojo/when
    return function when(valueOrPromise, callback, errback, progback) {
      // summary:
      //		Transparently applies callbacks to values and/or promises.
      // description:
      //		Accepts promises but also transparently handles non-promises. If no
      //		callbacks are provided returns a promise, regardless of the initial
      //		value. Foreign promises are converted.
      //
      //		If callbacks are provided and the initial value is not a promise,
      //		the callback is executed immediately with no error handling. Returns
      //		a promise if the initial value is a promise, or the result of the
      //		callback otherwise.
      // valueOrPromise:
      //		Either a regular value or an object with a `then()` method that
      //		follows the Promises/A specification.
      // callback: Function?
      //		Callback to be invoked when the promise is resolved, or a non-promise
      //		is received.
      // errback: Function?
      //		Callback to be invoked when the promise is rejected.
      // progback: Function?
      //		Callback to be invoked when the promise emits a progress update.
      // returns: dojo/promise/Promise
      //		Promise, or if a callback is provided, the result of the callback.
      var receivedPromise = valueOrPromise && typeof valueOrPromise.then === 'function';
      var nativePromise = receivedPromise && valueOrPromise instanceof Promise;
      if (!receivedPromise) {
        if (arguments.length > 1) {
          return callback ? callback(valueOrPromise) : valueOrPromise;
        } else {
          return new Deferred().resolve(valueOrPromise);
        }
      } else if (!nativePromise) {
        var deferred = new Deferred(valueOrPromise.cancel);
        valueOrPromise.then(deferred.resolve, deferred.reject, deferred.progress);
        valueOrPromise = deferred.promise;
      }
      if (callback || errback || progback) {
        return valueOrPromise.then(callback, errback, progback);
      }
      return valueOrPromise;
    };
  }(dojo_Deferred, dojo_promise_Promise);
  dojo__base_Deferred = function (dojo, NewDeferred, Promise, CancelError, has, lang, when) {
    // module:
    //		dojo/_base/Deferred
    var mutator = function () {
    };
    var freeze = Object.freeze || function () {
    };
    // A deferred provides an API for creating and resolving a promise.
    var Deferred = dojo.Deferred = function (canceller) {
      // summary:
      //		Deprecated.   This module defines the legacy dojo/_base/Deferred API.
      //		New code should use dojo/Deferred instead.
      // description:
      //		The Deferred API is based on the concept of promises that provide a
      //		generic interface into the eventual completion of an asynchronous action.
      //		The motivation for promises fundamentally is about creating a
      //		separation of concerns that allows one to achieve the same type of
      //		call patterns and logical data flow in asynchronous code as can be
      //		achieved in synchronous code. Promises allows one
      //		to be able to call a function purely with arguments needed for
      //		execution, without conflating the call with concerns of whether it is
      //		sync or async. One shouldn't need to alter a call's arguments if the
      //		implementation switches from sync to async (or vice versa). By having
      //		async functions return promises, the concerns of making the call are
      //		separated from the concerns of asynchronous interaction (which are
      //		handled by the promise).
      //
      //		The Deferred is a type of promise that provides methods for fulfilling the
      //		promise with a successful result or an error. The most important method for
      //		working with Dojo's promises is the then() method, which follows the
      //		CommonJS proposed promise API. An example of using a Dojo promise:
      //
      //		|	var resultingPromise = someAsyncOperation.then(function(result){
      //		|		... handle result ...
      //		|	},
      //		|	function(error){
      //		|		... handle error ...
      //		|	});
      //
      //		The .then() call returns a new promise that represents the result of the
      //		execution of the callback. The callbacks will never affect the original promises value.
      //
      //		The Deferred instances also provide the following functions for backwards compatibility:
      //
      //		- addCallback(handler)
      //		- addErrback(handler)
      //		- callback(result)
      //		- errback(result)
      //
      //		Callbacks are allowed to return promises themselves, so
      //		you can build complicated sequences of events with ease.
      //
      //		The creator of the Deferred may specify a canceller.  The canceller
      //		is a function that will be called if Deferred.cancel is called
      //		before the Deferred fires. You can use this to implement clean
      //		aborting of an XMLHttpRequest, etc. Note that cancel will fire the
      //		deferred with a CancelledError (unless your canceller returns
      //		another kind of error), so the errbacks should be prepared to
      //		handle that error for cancellable Deferreds.
      // example:
      //	|	var deferred = new Deferred();
      //	|	setTimeout(function(){ deferred.callback({success: true}); }, 1000);
      //	|	return deferred;
      // example:
      //		Deferred objects are often used when making code asynchronous. It
      //		may be easiest to write functions in a synchronous manner and then
      //		split code using a deferred to trigger a response to a long-lived
      //		operation. For example, instead of register a callback function to
      //		denote when a rendering operation completes, the function can
      //		simply return a deferred:
      //
      //		|	// callback style:
      //		|	function renderLotsOfData(data, callback){
      //		|		var success = false
      //		|		try{
      //		|			for(var x in data){
      //		|				renderDataitem(data[x]);
      //		|			}
      //		|			success = true;
      //		|		}catch(e){ }
      //		|		if(callback){
      //		|			callback(success);
      //		|		}
      //		|	}
      //
      //		|	// using callback style
      //		|	renderLotsOfData(someDataObj, function(success){
      //		|		// handles success or failure
      //		|		if(!success){
      //		|			promptUserToRecover();
      //		|		}
      //		|	});
      //		|	// NOTE: no way to add another callback here!!
      // example:
      //		Using a Deferred doesn't simplify the sending code any, but it
      //		provides a standard interface for callers and senders alike,
      //		providing both with a simple way to service multiple callbacks for
      //		an operation and freeing both sides from worrying about details
      //		such as "did this get called already?". With Deferreds, new
      //		callbacks can be added at any time.
      //
      //		|	// Deferred style:
      //		|	function renderLotsOfData(data){
      //		|		var d = new Deferred();
      //		|		try{
      //		|			for(var x in data){
      //		|				renderDataitem(data[x]);
      //		|			}
      //		|			d.callback(true);
      //		|		}catch(e){
      //		|			d.errback(new Error("rendering failed"));
      //		|		}
      //		|		return d;
      //		|	}
      //
      //		|	// using Deferred style
      //		|	renderLotsOfData(someDataObj).then(null, function(){
      //		|		promptUserToRecover();
      //		|	});
      //		|	// NOTE: addErrback and addCallback both return the Deferred
      //		|	// again, so we could chain adding callbacks or save the
      //		|	// deferred for later should we need to be notified again.
      // example:
      //		In this example, renderLotsOfData is synchronous and so both
      //		versions are pretty artificial. Putting the data display on a
      //		timeout helps show why Deferreds rock:
      //
      //		|	// Deferred style and async func
      //		|	function renderLotsOfData(data){
      //		|		var d = new Deferred();
      //		|		setTimeout(function(){
      //		|			try{
      //		|				for(var x in data){
      //		|					renderDataitem(data[x]);
      //		|				}
      //		|				d.callback(true);
      //		|			}catch(e){
      //		|				d.errback(new Error("rendering failed"));
      //		|			}
      //		|		}, 100);
      //		|		return d;
      //		|	}
      //
      //		|	// using Deferred style
      //		|	renderLotsOfData(someDataObj).then(null, function(){
      //		|		promptUserToRecover();
      //		|	});
      //
      //		Note that the caller doesn't have to change his code at all to
      //		handle the asynchronous case.
      var result, finished, canceled, fired, isError, head, nextListener;
      var promise = this.promise = new Promise();
      function complete(value) {
        if (finished) {
          throw new Error('This deferred has already been resolved');
        }
        result = value;
        finished = true;
        notify();
      }
      function notify() {
        var mutated;
        while (!mutated && nextListener) {
          var listener = nextListener;
          nextListener = nextListener.next;
          if (mutated = listener.progress == mutator) {
            // assignment and check
            finished = false;
          }
          var func = isError ? listener.error : listener.resolved;
          if (has('config-useDeferredInstrumentation')) {
            if (isError && NewDeferred.instrumentRejected) {
              NewDeferred.instrumentRejected(result, !!func);
            }
          }
          if (func) {
            try {
              var newResult = func(result);
              if (newResult && typeof newResult.then === 'function') {
                newResult.then(lang.hitch(listener.deferred, 'resolve'), lang.hitch(listener.deferred, 'reject'), lang.hitch(listener.deferred, 'progress'));
                continue;
              }
              var unchanged = mutated && newResult === undefined;
              if (mutated && !unchanged) {
                isError = newResult instanceof Error;
              }
              listener.deferred[unchanged && isError ? 'reject' : 'resolve'](unchanged ? result : newResult);
            } catch (e) {
              listener.deferred.reject(e);
            }
          } else {
            if (isError) {
              listener.deferred.reject(result);
            } else {
              listener.deferred.resolve(result);
            }
          }
        }
      }
      this.isResolved = promise.isResolved = function () {
        // summary:
        //		Checks whether the deferred has been resolved.
        // returns: Boolean
        return fired == 0;
      };
      this.isRejected = promise.isRejected = function () {
        // summary:
        //		Checks whether the deferred has been rejected.
        // returns: Boolean
        return fired == 1;
      };
      this.isFulfilled = promise.isFulfilled = function () {
        // summary:
        //		Checks whether the deferred has been resolved or rejected.
        // returns: Boolean
        return fired >= 0;
      };
      this.isCanceled = promise.isCanceled = function () {
        // summary:
        //		Checks whether the deferred has been canceled.
        // returns: Boolean
        return canceled;
      };
      // calling resolve will resolve the promise
      this.resolve = this.callback = function (value) {
        // summary:
        //		Fulfills the Deferred instance successfully with the provide value
        this.fired = fired = 0;
        this.results = [
          value,
          null
        ];
        complete(value);
      };
      // calling error will indicate that the promise failed
      this.reject = this.errback = function (error) {
        // summary:
        //		Fulfills the Deferred instance as an error with the provided error
        isError = true;
        this.fired = fired = 1;
        if (has('config-useDeferredInstrumentation')) {
          if (NewDeferred.instrumentRejected) {
            NewDeferred.instrumentRejected(error, !!nextListener);
          }
        }
        complete(error);
        this.results = [
          null,
          error
        ];
      };
      // call progress to provide updates on the progress on the completion of the promise
      this.progress = function (update) {
        // summary:
        //		Send progress events to all listeners
        var listener = nextListener;
        while (listener) {
          var progress = listener.progress;
          progress && progress(update);
          listener = listener.next;
        }
      };
      this.addCallbacks = function (callback, errback) {
        // summary:
        //		Adds callback and error callback for this deferred instance.
        // callback: Function?
        //		The callback attached to this deferred object.
        // errback: Function?
        //		The error callback attached to this deferred object.
        // returns:
        //		Returns this deferred object.
        this.then(callback, errback, mutator);
        return this;  // Deferred
      };
      // provide the implementation of the promise
      promise.then = this.then = function (resolvedCallback, errorCallback, progressCallback) {
        // summary:
        //		Adds a fulfilledHandler, errorHandler, and progressHandler to be called for
        //		completion of a promise. The fulfilledHandler is called when the promise
        //		is fulfilled. The errorHandler is called when a promise fails. The
        //		progressHandler is called for progress events. All arguments are optional
        //		and non-function values are ignored. The progressHandler is not only an
        //		optional argument, but progress events are purely optional. Promise
        //		providers are not required to ever create progress events.
        //
        //		This function will return a new promise that is fulfilled when the given
        //		fulfilledHandler or errorHandler callback is finished. This allows promise
        //		operations to be chained together. The value returned from the callback
        //		handler is the fulfillment value for the returned promise. If the callback
        //		throws an error, the returned promise will be moved to failed state.
        //
        // returns:
        //		Returns a new promise that represents the result of the
        //		execution of the callback. The callbacks will never affect the original promises value.
        // example:
        //		An example of using a CommonJS compliant promise:
        //		|	asyncComputeTheAnswerToEverything().
        //		|		then(addTwo).
        //		|		then(printResult, onError);
        //		|	>44
        //
        var returnDeferred = progressCallback == mutator ? this : new Deferred(promise.cancel);
        var listener = {
          resolved: resolvedCallback,
          error: errorCallback,
          progress: progressCallback,
          deferred: returnDeferred
        };
        if (nextListener) {
          head = head.next = listener;
        } else {
          nextListener = head = listener;
        }
        if (finished) {
          notify();
        }
        return returnDeferred.promise;  // Promise
      };
      var deferred = this;
      promise.cancel = this.cancel = function () {
        // summary:
        //		Cancels the asynchronous operation
        if (!finished) {
          var error = canceller && canceller(deferred);
          if (!finished) {
            if (!(error instanceof Error)) {
              error = new CancelError(error);
            }
            error.log = false;
            deferred.reject(error);
          }
        }
        canceled = true;
      };
      freeze(promise);
    };
    lang.extend(Deferred, {
      addCallback: function (callback) {
        // summary:
        //		Adds successful callback for this deferred instance.
        // returns:
        //		Returns this deferred object.
        return this.addCallbacks(lang.hitch.apply(dojo, arguments));  // Deferred
      },
      addErrback: function (errback) {
        // summary:
        //		Adds error callback for this deferred instance.
        // returns:
        //		Returns this deferred object.
        return this.addCallbacks(null, lang.hitch.apply(dojo, arguments));  // Deferred
      },
      addBoth: function (callback) {
        // summary:
        //		Add handler as both successful callback and error callback for this deferred instance.
        // returns:
        //		Returns this deferred object.
        var enclosed = lang.hitch.apply(dojo, arguments);
        return this.addCallbacks(enclosed, enclosed);  // Deferred
      },
      fired: -1
    });
    Deferred.when = dojo.when = when;
    return Deferred;
  }(dojo__base_kernel, dojo_Deferred, dojo_promise_Promise, dojo_errors_CancelError, dojo_has, dojo__base_lang, dojo_when);
  dojo__base_json = function (dojo, json) {
    // module:
    //		dojo/_base/json
    /*=====
    return {
    	// summary:
    	//		This module defines the dojo JSON API.
    };
    =====*/
    dojo.fromJson = function (js) {
      // summary:
      //		Parses a JavaScript expression and returns a JavaScript value.
      // description:
      //		Throws for invalid JavaScript expressions. It does not use a strict JSON parser. It
      //		always delegates to eval(). The content passed to this method must therefore come
      //		from a trusted source.
      //		It is recommend that you use dojo/json's parse function for an
      //		implementation uses the (faster) native JSON parse when available.
      // js:
      //		a string literal of a JavaScript expression, for instance:
      //		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`
      return JSON.parse(js);  // Object PATCHED use JSON parse instean of eval
    };
    /*=====
    dojo._escapeString = function(){
    	// summary:
    	//		Adds escape sequences for non-visual characters, double quote and
    	//		backslash and surrounds with double quotes to form a valid string
    	//		literal.
    };
    =====*/
    dojo._escapeString = json.stringify;
    // just delegate to json.stringify
    dojo.toJsonIndentStr = '\t';
    dojo.toJson = function (it, prettyPrint) {
      // summary:
      //		Returns a [JSON](http://json.org) serialization of an object.
      // description:
      //		Returns a [JSON](http://json.org) serialization of an object.
      //		Note that this doesn't check for infinite recursion, so don't do that!
      //		It is recommend that you use dojo/json's stringify function for an lighter
      //		and faster implementation that matches the native JSON API and uses the
      //		native JSON serializer when available.
      // it:
      //		an object to be serialized. Objects may define their own
      //		serialization via a special "__json__" or "json" function
      //		property. If a specialized serializer has been defined, it will
      //		be used as a fallback.
      //		Note that in 1.6, toJson would serialize undefined, but this no longer supported
      //		since it is not supported by native JSON serializer.
      // prettyPrint:
      //		if true, we indent objects and arrays to make the output prettier.
      //		The variable `dojo.toJsonIndentStr` is used as the indent string --
      //		to use something other than the default (tab), change that variable
      //		before calling dojo.toJson().
      //		Note that if native JSON support is available, it will be used for serialization,
      //		and native implementations vary on the exact spacing used in pretty printing.
      // returns:
      //		A JSON string serialization of the passed-in object.
      // example:
      //		simple serialization of a trivial object
      //		|	var jsonStr = dojo.toJson({ howdy: "stranger!", isStrange: true });
      //		|	doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
      // example:
      //		a custom serializer for an objects of a particular class:
      //		|	dojo.declare("Furby", null, {
      //		|		furbies: "are strange",
      //		|		furbyCount: 10,
      //		|		__json__: function(){
      //		|		},
      //		|	});
      // use dojo/json
      return json.stringify(it, function (key, value) {
        if (value) {
          var tf = value.__json__ || value.json;
          if (typeof tf == 'function') {
            return tf.call(value);
          }
        }
        return value;
      }, prettyPrint && dojo.toJsonIndentStr);  // String
    };
    return dojo;
  }(dojo__base_kernel, dojo_json);
  dojo__base_xhr = function (dojo, has, require, ioq, dom, domForm, Deferred, config, json, lang, array, on, aspect, watch, _xhr, util) {
    // module:
    //		dojo/_base/xhr
    /*=====
    	dojo._xhrObj = function(){
    		// summary:
    		//		does the work of portably generating a new XMLHTTPRequest object.
    	};
    	=====*/
    dojo._xhrObj = _xhr._create;
    var cfg = dojo.config;
    // mix in io-query and dom-form
    dojo.objectToQuery = ioq.objectToQuery;
    dojo.queryToObject = ioq.queryToObject;
    dojo.fieldToObject = domForm.fieldToObject;
    dojo.formToObject = domForm.toObject;
    dojo.formToQuery = domForm.toQuery;
    dojo.formToJson = domForm.toJson;
    // need to block async callbacks from snatching this thread as the result
    // of an async callback might call another sync XHR, this hangs khtml forever
    // must checked by watchInFlight()
    dojo._blockAsync = false;
    // MOW: remove dojo._contentHandlers alias in 2.0
    var handlers = dojo._contentHandlers = dojo.contentHandlers = {
      // summary:
      //		A map of available XHR transport handle types. Name matches the
      //		`handleAs` attribute passed to XHR calls.
      // description:
      //		A map of available XHR transport handle types. Name matches the
      //		`handleAs` attribute passed to XHR calls. Each contentHandler is
      //		called, passing the xhr object for manipulation. The return value
      //		from the contentHandler will be passed to the `load` or `handle`
      //		functions defined in the original xhr call.
      // example:
      //		Creating a custom content-handler:
      //	|	xhr.contentHandlers.makeCaps = function(xhr){
      //	|		return xhr.responseText.toUpperCase();
      //	|	}
      //	|	// and later:
      //	|	dojo.xhrGet({
      //	|		url:"foo.txt",
      //	|		handleAs:"makeCaps",
      //	|		load: function(data){ /* data is a toUpper version of foo.txt */ }
      //	|	});
      'text': function (xhr) {
        // summary:
        //		A contentHandler which simply returns the plaintext response data
        return xhr.responseText;
      },
      'json': function (xhr) {
        // summary:
        //		A contentHandler which returns a JavaScript object created from the response data
        return json.fromJson(xhr.responseText || null);
      },
      'json-comment-filtered': function (xhr) {
        // summary:
        //		A contentHandler which expects comment-filtered JSON.
        // description:
        //		A contentHandler which expects comment-filtered JSON.
        //		the json-comment-filtered option was implemented to prevent
        //		"JavaScript Hijacking", but it is less secure than standard JSON. Use
        //		standard JSON instead. JSON prefixing can be used to subvert hijacking.
        //
        //		Will throw a notice suggesting to use application/json mimetype, as
        //		json-commenting can introduce security issues. To decrease the chances of hijacking,
        //		use the standard `json` contentHandler, and prefix your "JSON" with: {}&&
        //
        //		use djConfig.useCommentedJson = true to turn off the notice
        if (!config.useCommentedJson) {
          console.warn('Consider using the standard mimetype:application/json.' + ' json-commenting can introduce security issues. To' + ' decrease the chances of hijacking, use the standard the \'json\' handler and' + ' prefix your json with: {}&&\n' + 'Use djConfig.useCommentedJson=true to turn off this message.');
        }
        var value = xhr.responseText;
        var cStartIdx = value.indexOf('/*');
        var cEndIdx = value.lastIndexOf('*/');
        if (cStartIdx == -1 || cEndIdx == -1) {
          throw new Error('JSON was not comment filtered');
        }
        return json.fromJson(value.substring(cStartIdx + 2, cEndIdx));
      },
      'javascript': function (xhr) {
        // summary:
        //		A contentHandler which evaluates the response data, expecting it to be valid JavaScript
        // FIXME: try Moz and IE specific eval variants?
        return dojo.eval(xhr.responseText);
      },
      'xml': function (xhr) {
        // summary:
        //		A contentHandler returning an XML Document parsed from the response data
        var result = xhr.responseXML;
        if (result && has('dom-qsa2.1') && !result.querySelectorAll && has('dom-parser')) {
          // http://bugs.dojotoolkit.org/ticket/15631
          // IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation 
          // returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain 
          // the fuller-featured implementation and avoid bugs caused by the inconsistency
          result = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
        }
        if (has('ie')) {
          if (!result || !result.documentElement) {
            //WARNING: this branch used by the xml handling in dojo.io.iframe,
            //so be sure to test dojo.io.iframe if making changes below.
            var ms = function (n) {
              return 'MSXML' + n + '.DOMDocument';
            };
            var dp = [
              'Microsoft.XMLDOM',
              ms(6),
              ms(4),
              ms(3),
              ms(2)
            ];
            array.some(dp, function (p) {
              try {
                var dom = new ActiveXObject(p);
                dom.async = false;
                dom.loadXML(xhr.responseText);
                result = dom;
              } catch (e) {
                return false;
              }
              return true;
            });
          }
        }
        return result;  // DOMDocument
      },
      'json-comment-optional': function (xhr) {
        // summary:
        //		A contentHandler which checks the presence of comment-filtered JSON and
        //		alternates between the `json` and `json-comment-filtered` contentHandlers.
        if (xhr.responseText && /^[^{\[]*\/\*/.test(xhr.responseText)) {
          return handlers['json-comment-filtered'](xhr);
        } else {
          return handlers['json'](xhr);
        }
      }
    };
    /*=====
    
    	// kwargs function parameter definitions.   Assigning to dojo namespace rather than making them local variables
    	// because they are used by dojo/io modules too
    
    	dojo.__IoArgs = declare(null, {
    		// url: String
    		//		URL to server endpoint.
    		// content: Object?
    		//		Contains properties with string values. These
    		//		properties will be serialized as name1=value2 and
    		//		passed in the request.
    		// timeout: Integer?
    		//		Milliseconds to wait for the response. If this time
    		//		passes, the then error callbacks are called.
    		// form: DOMNode?
    		//		DOM node for a form. Used to extract the form values
    		//		and send to the server.
    		// preventCache: Boolean?
    		//		Default is false. If true, then a
    		//		"dojo.preventCache" parameter is sent in the request
    		//		with a value that changes with each request
    		//		(timestamp). Useful only with GET-type requests.
    		// handleAs: String?
    		//		Acceptable values depend on the type of IO
    		//		transport (see specific IO calls for more information).
    		// rawBody: String?
    		//		Sets the raw body for an HTTP request. If this is used, then the content
    		//		property is ignored. This is mostly useful for HTTP methods that have
    		//		a body to their requests, like PUT or POST. This property can be used instead
    		//		of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.
    		// ioPublish: Boolean?
    		//		Set this explicitly to false to prevent publishing of topics related to
    		//		IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
    		//		will be published via dojo/topic.publish() for different phases of an IO operation.
    		//		See dojo/main.__IoPublish for a list of topics that are published.
    
    		load: function(response, ioArgs){
    			// summary:
    			//		This function will be
    			//		called on a successful HTTP response code.
    	 		// ioArgs: dojo/main.__IoCallbackArgs
    			//		Provides additional information about the request.
    			// response: Object
    			//		The response in the format as defined with handleAs.
    		},
    
    		error: function(response, ioArgs){
    			// summary:
    			//		This function will
    			//		be called when the request fails due to a network or server error, the url
    			//		is invalid, etc. It will also be called if the load or handle callback throws an
    			//		exception, unless djConfig.debugAtAllCosts is true.	 This allows deployed applications
    			//		to continue to run even when a logic error happens in the callback, while making
    			//		it easier to troubleshoot while in debug mode.
    			// ioArgs: dojo/main.__IoCallbackArgs
    			//		Provides additional information about the request.
    			// response: Object
    			//		The response in the format as defined with handleAs.
    		},
    
    		handle: function(loadOrError, response, ioArgs){
    			// summary:
    	 		//		This function will
    	 		//		be called at the end of every request, whether or not an error occurs.
    			// loadOrError: String
    			//		Provides a string that tells you whether this function
    			//		was called because of success (load) or failure (error).
    			// response: Object
    			//		The response in the format as defined with handleAs.
    			// ioArgs: dojo/main.__IoCallbackArgs
    			//		Provides additional information about the request.
    		}
    	});
    
    	dojo.__IoCallbackArgs = declare(null, {
    		// args: Object
    		//		the original object argument to the IO call.
    		// xhr: XMLHttpRequest
    		//		For XMLHttpRequest calls only, the
    		//		XMLHttpRequest object that was used for the
    		//		request.
    		// url: String
    		//		The final URL used for the call. Many times it
    		//		will be different than the original args.url
    		//		value.
    		// query: String
    		//		For non-GET requests, the
    		//		name1=value1&name2=value2 parameters sent up in
    		//		the request.
    		// handleAs: String
    		//		The final indicator on how the response will be
    		//		handled.
    		// id: String
    		//		For dojo/io/script calls only, the internal
    		//		script ID used for the request.
    		// canDelete: Boolean
    		//		For dojo/io/script calls only, indicates
    		//		whether the script tag that represents the
    		//		request can be deleted after callbacks have
    		//		been called. Used internally to know when
    		//		cleanup can happen on JSONP-type requests.
    		// json: Object
    		//		For dojo/io/script calls only: holds the JSON
    		//		response for JSONP-type requests. Used
    		//		internally to hold on to the JSON responses.
    		//		You should not need to access it directly --
    		//		the same object should be passed to the success
    		//		callbacks directly.
    	});
    
    	dojo.__IoPublish = declare(null, {
    		// summary:
    		//		This is a list of IO topics that can be published
    		//		if djConfig.ioPublish is set to true. IO topics can be
    		//		published for any Input/Output, network operation. So,
    		//		dojo.xhr, dojo.io.script and dojo.io.iframe can all
    		//		trigger these topics to be published.
    		// start: String
    		//		"/dojo/io/start" is sent when there are no outstanding IO
    		//		requests, and a new IO request is started. No arguments
    		//		are passed with this topic.
    		// send: String
    		//		"/dojo/io/send" is sent whenever a new IO request is started.
    		//		It passes the dojo.Deferred for the request with the topic.
    		// load: String
    		//		"/dojo/io/load" is sent whenever an IO request has loaded
    		//		successfully. It passes the response and the dojo.Deferred
    		//		for the request with the topic.
    		// error: String
    		//		"/dojo/io/error" is sent whenever an IO request has errored.
    		//		It passes the error and the dojo.Deferred
    		//		for the request with the topic.
    		// done: String
    		//		"/dojo/io/done" is sent whenever an IO request has completed,
    		//		either by loading or by erroring. It passes the error and
    		//		the dojo.Deferred for the request with the topic.
    		// stop: String
    		//		"/dojo/io/stop" is sent when all outstanding IO requests have
    		//		finished. No arguments are passed with this topic.
    	});
    	=====*/
    dojo._ioSetArgs = function (args, canceller, okHandler, errHandler) {
      // summary:
      //		sets up the Deferred and ioArgs property on the Deferred so it
      //		can be used in an io call.
      // args:
      //		The args object passed into the public io call. Recognized properties on
      //		the args object are:
      // canceller:
      //		The canceller function used for the Deferred object. The function
      //		will receive one argument, the Deferred object that is related to the
      //		canceller.
      // okHandler:
      //		The first OK callback to be registered with Deferred. It has the opportunity
      //		to transform the OK response. It will receive one argument -- the Deferred
      //		object returned from this function.
      // errHandler:
      //		The first error callback to be registered with Deferred. It has the opportunity
      //		to do cleanup on an error. It will receive two arguments: error (the
      //		Error object) and dfd, the Deferred object returned from this function.
      var ioArgs = {
        args: args,
        url: args.url
      };
      //Get values from form if requested.
      var formObject = null;
      if (args.form) {
        var form = dom.byId(args.form);
        //IE requires going through getAttributeNode instead of just getAttribute in some form cases,
        //so use it for all. See #2844
        var actnNode = form.getAttributeNode('action');
        ioArgs.url = ioArgs.url || (actnNode ? actnNode.value : null);
        formObject = domForm.toObject(form);
      }
      // set up the query params
      var miArgs = [{}];
      if (formObject) {
        // potentially over-ride url-provided params w/ form values
        miArgs.push(formObject);
      }
      if (args.content) {
        // stuff in content over-rides what's set by form
        miArgs.push(args.content);
      }
      if (args.preventCache) {
        miArgs.push({ 'dojo.preventCache': new Date().valueOf() });
      }
      ioArgs.query = ioq.objectToQuery(lang.mixin.apply(null, miArgs));
      // .. and the real work of getting the deferred in order, etc.
      ioArgs.handleAs = args.handleAs || 'text';
      var d = new Deferred(function (dfd) {
        dfd.canceled = true;
        canceller && canceller(dfd);
        var err = dfd.ioArgs.error;
        if (!err) {
          err = new Error('request cancelled');
          err.dojoType = 'cancel';
          dfd.ioArgs.error = err;
        }
        return err;
      });
      d.addCallback(okHandler);
      //Support specifying load, error and handle callback functions from the args.
      //For those callbacks, the "this" object will be the args object.
      //The callbacks will get the deferred result value as the
      //first argument and the ioArgs object as the second argument.
      var ld = args.load;
      if (ld && lang.isFunction(ld)) {
        d.addCallback(function (value) {
          return ld.call(args, value, ioArgs);
        });
      }
      var err = args.error;
      if (err && lang.isFunction(err)) {
        d.addErrback(function (value) {
          return err.call(args, value, ioArgs);
        });
      }
      var handle = args.handle;
      if (handle && lang.isFunction(handle)) {
        d.addBoth(function (value) {
          return handle.call(args, value, ioArgs);
        });
      }
      // Attach error handler last (not including topic publishing)
      // to catch any errors that may have been generated from load
      // or handle functions.
      d.addErrback(function (error) {
        return errHandler(error, d);
      });
      //Plug in topic publishing, if dojo.publish is loaded.
      if (cfg.ioPublish && dojo.publish && ioArgs.args.ioPublish !== false) {
        d.addCallbacks(function (res) {
          dojo.publish('/dojo/io/load', [
            d,
            res
          ]);
          return res;
        }, function (res) {
          dojo.publish('/dojo/io/error', [
            d,
            res
          ]);
          return res;
        });
        d.addBoth(function (res) {
          dojo.publish('/dojo/io/done', [
            d,
            res
          ]);
          return res;
        });
      }
      d.ioArgs = ioArgs;
      // FIXME: need to wire up the xhr object's abort method to something
      // analogous in the Deferred
      return d;
    };
    var _deferredOk = function (dfd) {
      // summary:
      //		okHandler function for dojo._ioSetArgs call.
      var ret = handlers[dfd.ioArgs.handleAs](dfd.ioArgs.xhr);
      return ret === undefined ? null : ret;
    };
    var _deferError = function (error, dfd) {
      // summary:
      //		errHandler function for dojo._ioSetArgs call.
      if (!dfd.ioArgs.args.failOk) {
        console.error(error);
      }
      return error;
    };
    //Use a separate count for knowing if we are starting/stopping io calls.
    var _checkPubCount = function (dfd) {
      if (_pubCount <= 0) {
        _pubCount = 0;
        if (cfg.ioPublish && dojo.publish && (!dfd || dfd && dfd.ioArgs.args.ioPublish !== false)) {
          dojo.publish('/dojo/io/stop');
        }
      }
    };
    var _pubCount = 0;
    aspect.after(watch, '_onAction', function () {
      _pubCount -= 1;
    });
    aspect.after(watch, '_onInFlight', _checkPubCount);
    dojo._ioCancelAll = watch.cancelAll;
    /*=====
    	dojo._ioCancelAll = function(){
    		// summary:
    		//		Cancels all pending IO requests, regardless of IO type
    		//		(xhr, script, iframe).
    	};
    	=====*/
    dojo._ioNotifyStart = function (dfd) {
      // summary:
      //		If dojo.publish is available, publish topics
      //		about the start of a request queue and/or the
      //		the beginning of request.
      //
      //		Used by IO transports. An IO transport should
      //		call this method before making the network connection.
      if (cfg.ioPublish && dojo.publish && dfd.ioArgs.args.ioPublish !== false) {
        if (!_pubCount) {
          dojo.publish('/dojo/io/start');
        }
        _pubCount += 1;
        dojo.publish('/dojo/io/send', [dfd]);
      }
    };
    dojo._ioWatch = function (dfd, validCheck, ioCheck, resHandle) {
      // summary:
      //		Watches the io request represented by dfd to see if it completes.
      // dfd: Deferred
      //		The Deferred object to watch.
      // validCheck: Function
      //		Function used to check if the IO request is still valid. Gets the dfd
      //		object as its only argument.
      // ioCheck: Function
      //		Function used to check if basic IO call worked. Gets the dfd
      //		object as its only argument.
      // resHandle: Function
      //		Function used to process response. Gets the dfd
      //		object as its only argument.
      var args = dfd.ioArgs.options = dfd.ioArgs.args;
      lang.mixin(dfd, {
        response: dfd.ioArgs,
        isValid: function (response) {
          return validCheck(dfd);
        },
        isReady: function (response) {
          return ioCheck(dfd);
        },
        handleResponse: function (response) {
          return resHandle(dfd);
        }
      });
      watch(dfd);
      _checkPubCount(dfd);
    };
    var _defaultContentType = 'application/x-www-form-urlencoded';
    dojo._ioAddQueryToUrl = function (ioArgs) {
      // summary:
      //		Adds query params discovered by the io deferred construction to the URL.
      //		Only use this for operations which are fundamentally GET-type operations.
      if (ioArgs.query.length) {
        ioArgs.url += (ioArgs.url.indexOf('?') == -1 ? '?' : '&') + ioArgs.query;
        ioArgs.query = null;
      }
    };
    /*=====
    	dojo.__XhrArgs = declare(dojo.__IoArgs, {
    		// summary:
    		//		In addition to the properties listed for the dojo._IoArgs type,
    		//		the following properties are allowed for dojo.xhr* methods.
    		// handleAs: String?
    		//		Acceptable values are: text (default), json, json-comment-optional,
    		//		json-comment-filtered, javascript, xml. See `dojo/_base/xhr.contentHandlers`
    	 	// sync: Boolean?
    		//		false is default. Indicates whether the request should
    		//		be a synchronous (blocking) request.
    		// headers: Object?
    		//		Additional HTTP headers to send in the request.
    		// failOk: Boolean?
    		//		false is default. Indicates whether a request should be
    		//		allowed to fail (and therefore no console error message in
    		//		the event of a failure)
    		// contentType: String|Boolean
    		//		"application/x-www-form-urlencoded" is default. Set to false to
    		//		prevent a Content-Type header from being sent, or to a string
    		//		to send a different Content-Type.
    	 });
    	=====*/
    dojo.xhr = function (method, args, hasBody) {
      // summary:
      //		Deprecated.   Use dojo/request instead.
      // description:
      //		Sends an HTTP request with the given method.
      //		See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
      //		for those HTTP methods. There are also methods for "raw" PUT and POST methods
      //		via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.
      // method:
      //		HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.
      // hasBody:
      //		If the request has an HTTP body, then pass true for hasBody.
      var rDfd;
      //Make the Deferred object for this xhr request.
      var dfd = dojo._ioSetArgs(args, function (dfd) {
        rDfd && rDfd.cancel();
      }, _deferredOk, _deferError);
      var ioArgs = dfd.ioArgs;
      //Allow for specifying the HTTP body completely.
      if ('postData' in args) {
        ioArgs.query = args.postData;
      } else if ('putData' in args) {
        ioArgs.query = args.putData;
      } else if ('rawBody' in args) {
        ioArgs.query = args.rawBody;
      } else if (arguments.length > 2 && !hasBody || 'POST|PUT'.indexOf(method.toUpperCase()) === -1) {
        //Check for hasBody being passed. If no hasBody,
        //then only append query string if not a POST or PUT request.
        dojo._ioAddQueryToUrl(ioArgs);
      }
      var options = {
        method: method,
        handleAs: 'text',
        timeout: args.timeout,
        withCredentials: args.withCredentials,
        ioArgs: ioArgs
      };
      if (typeof args.headers !== 'undefined') {
        options.headers = args.headers;
      }
      if (typeof args.contentType !== 'undefined') {
        if (!options.headers) {
          options.headers = {};
        }
        options.headers['Content-Type'] = args.contentType;
      }
      if (typeof ioArgs.query !== 'undefined') {
        options.data = ioArgs.query;
      }
      if (typeof args.sync !== 'undefined') {
        options.sync = args.sync;
      }
      dojo._ioNotifyStart(dfd);
      try {
        rDfd = _xhr(ioArgs.url, options, true);
      } catch (e) {
        dfd.cancel();
        return dfd;
      }
      // sync ioArgs
      dfd.ioArgs.xhr = rDfd.response.xhr;
      rDfd.then(function () {
        dfd.resolve(dfd);
      }).otherwise(function (error) {
        ioArgs.error = error;
        if (error.response) {
          error.status = error.response.status;
          error.responseText = error.response.text;
          error.xhr = error.response.xhr;
        }
        dfd.reject(error);
      });
      return dfd;  // dojo/_base/Deferred
    };
    dojo.xhrGet = function (args) {
      // summary:
      //		Sends an HTTP GET request to the server.
      return dojo.xhr('GET', args);  // dojo/_base/Deferred
    };
    dojo.rawXhrPost = dojo.xhrPost = function (args) {
      // summary:
      //		Sends an HTTP POST request to the server. In addition to the properties
      //		listed for the dojo.__XhrArgs type, the following property is allowed:
      // postData:
      //		String. Send raw data in the body of the POST request.
      return dojo.xhr('POST', args, true);  // dojo/_base/Deferred
    };
    dojo.rawXhrPut = dojo.xhrPut = function (args) {
      // summary:
      //		Sends an HTTP PUT request to the server. In addition to the properties
      //		listed for the dojo.__XhrArgs type, the following property is allowed:
      // putData:
      //		String. Send raw data in the body of the PUT request.
      return dojo.xhr('PUT', args, true);  // dojo/_base/Deferred
    };
    dojo.xhrDelete = function (args) {
      // summary:
      //		Sends an HTTP DELETE request to the server.
      return dojo.xhr('DELETE', args);  // dojo/_base/Deferred
    };
    /*
    	dojo.wrapForm = function(formNode){
    		// summary:
    		//		A replacement for FormBind, but not implemented yet.
    
    		// FIXME: need to think harder about what extensions to this we might
    		// want. What should we allow folks to do w/ this? What events to
    		// set/send?
    		throw new Error("dojo.wrapForm not yet implemented");
    	}
    	*/
    dojo._isDocumentOk = function (x) {
      return util.checkStatus(x.status);
    };
    dojo._getText = function (url) {
      var result;
      dojo.xhrGet({
        url: url,
        sync: true,
        load: function (text) {
          result = text;
        }
      });
      return result;
    };
    // Add aliases for static functions to dojo.xhr since dojo.xhr is what's returned from this module
    lang.mixin(dojo.xhr, {
      _xhrObj: dojo._xhrObj,
      fieldToObject: domForm.fieldToObject,
      formToObject: domForm.toObject,
      objectToQuery: ioq.objectToQuery,
      formToQuery: domForm.toQuery,
      formToJson: domForm.toJson,
      queryToObject: ioq.queryToObject,
      contentHandlers: handlers,
      _ioSetArgs: dojo._ioSetArgs,
      _ioCancelAll: dojo._ioCancelAll,
      _ioNotifyStart: dojo._ioNotifyStart,
      _ioWatch: dojo._ioWatch,
      _ioAddQueryToUrl: dojo._ioAddQueryToUrl,
      _isDocumentOk: dojo._isDocumentOk,
      _getText: dojo._getText,
      get: dojo.xhrGet,
      post: dojo.xhrPost,
      put: dojo.xhrPut,
      del: dojo.xhrDelete
    });
    return dojo.xhr;
  }(dojo__base_kernel, dojo__base_sniff, {}, dojo_io_query, dojo_dom, dojo_dom_form, dojo__base_Deferred, dojo__base_config, dojo__base_json, dojo__base_lang, dojo__base_array, dojo_on, dojo_aspect, dojo_request_watch, dojo_request_xhr, dojo_request_util);
  dojo_request_script = function (watch, util, kernel, array, lang, on, dom, has, win) {
    has.add('script-readystatechange', function (global, document) {
      var script = document.createElement('script');
      return typeof script['onreadystatechange'] !== 'undefined' && (typeof global['opera'] === 'undefined' || global['opera'].toString() !== '[object Opera]');
    });
    var mid = 'rqst_cobr' + ~~(Math.random() * 10000000),
      //module.id.replace(/[\/\.\-]/g, '_'), //PATCHED TO SUPPORT AMD CLEAN
      counter = 0, loadEvent = has('script-readystatechange') ? 'readystatechange' : 'load', readyRegExp = /complete|loaded/, callbacks = kernel.global[mid + '_callbacks'] = {}, deadScripts = [];
    function attach(id, url, frameDoc) {
      var doc = frameDoc || win.doc, element = doc.createElement('script');
      element.type = 'text/javascript';
      element.src = url;
      element.id = id;
      element.async = true;
      element.charset = 'utf-8';
      return doc.getElementsByTagName('head')[0].appendChild(element);
    }
    function remove(id, frameDoc, cleanup) {
      var node = dom.byId(id, frameDoc);
      node.parentNode.removeChild(node);
      // domConstruct.destroy
      if (callbacks[id]) {
        if (cleanup) {
          // set callback to a function that deletes itself so requests that
          // are in-flight don't error out when returning and also
          // clean up after themselves
          callbacks[id] = function () {
            delete callbacks[id];
          };
        } else {
          delete callbacks[id];
        }
      }
    }
    function _addDeadScript(dfd) {
      // Be sure to check ioArgs because it can dynamically change in the dojox/io plugins.
      // See http://bugs.dojotoolkit.org/ticket/15890.
      var options = dfd.response.options, frameDoc = options.ioArgs ? options.ioArgs.frameDoc : options.frameDoc;
      deadScripts.push({
        id: dfd.id,
        frameDoc: frameDoc
      });
      if (options.ioArgs) {
        options.ioArgs.frameDoc = null;
      }
      options.frameDoc = null;
    }
    function canceler(dfd, response) {
      if (dfd.canDelete) {
        //For timeouts and cancels, remove the script element immediately to
        //avoid a response from it coming back later and causing trouble.
        script._remove(dfd.id, response.options.frameDoc, true);
      }
    }
    function isValid(response) {
      //Do script cleanup here. We wait for one inflight pass
      //to make sure we don't get any weird things by trying to remove a script
      //tag that is part of the call chain (IE 6 has been known to
      //crash in that case).
      if (deadScripts && deadScripts.length) {
        array.forEach(deadScripts, function (_script) {
          script._remove(_script.id, _script.frameDoc);
          _script.frameDoc = null;
        });
        deadScripts = [];
      }
      return response.options.jsonp ? !response.data : true;
    }
    function isReadyScript(response) {
      return !!this.scriptLoaded;
    }
    function isReadyCheckString(response) {
      var checkString = response.options.checkString;
      return checkString && eval('typeof(' + checkString + ') !== "undefined"');
    }
    function handleResponse(response, error) {
      if (this.canDelete) {
        _addDeadScript(this);
      }
      if (error) {
        this.reject(error);
      } else {
        this.resolve(response);
      }
    }
    function script(url, options, returnDeferred) {
      var response = util.parseArgs(url, util.deepCopy({}, options));
      url = response.url;
      options = response.options;
      var dfd = util.deferred(response, canceler, isValid, options.jsonp ? null : options.checkString ? isReadyCheckString : isReadyScript, handleResponse);
      lang.mixin(dfd, {
        id: mid + counter++,
        canDelete: false
      });
      if (options.jsonp) {
        var queryParameter = new RegExp('[?&]' + options.jsonp + '=');
        if (!queryParameter.test(url)) {
          url += (~url.indexOf('?') ? '&' : '?') + options.jsonp + '=' + (options.frameDoc ? 'parent.' : '') + mid + '_callbacks.' + dfd.id;
        }
        dfd.canDelete = true;
        callbacks[dfd.id] = function (json) {
          response.data = json;
          dfd.handleResponse(response);
        };
      }
      if (util.notify) {
        util.notify.emit('send', response, dfd.promise.cancel);
      }
      if (!options.canAttach || options.canAttach(dfd)) {
        var node = script._attach(dfd.id, url, options.frameDoc);
        if (!options.jsonp && !options.checkString) {
          var handle = on(node, loadEvent, function (evt) {
            if (evt.type === 'load' || readyRegExp.test(node.readyState)) {
              handle.remove();
              dfd.scriptLoaded = evt;
            }
          });
        }
      }
      watch(dfd);
      return returnDeferred ? dfd : dfd.promise;
    }
    script.get = script;
    /*=====
    	script = function(url, options){
    		// summary:
    		//		Sends a request using a script element with the given URL and options.
    		// url: String
    		//		URL to request
    		// options: dojo/request/script.__Options?
    		//		Options for the request.
    		// returns: dojo/request.__Promise
    	};
    	script.__BaseOptions = declare(request.__BaseOptions, {
    		// jsonp: String?
    		//		The URL parameter name that indicates the JSONP callback string.
    		//		For instance, when using Yahoo JSONP calls it is normally,
    		//		jsonp: "callback". For AOL JSONP calls it is normally
    		//		jsonp: "c".
    		// checkString: String?
    		//		A string of JavaScript that when evaluated like so:
    		//		"typeof(" + checkString + ") != 'undefined'"
    		//		being true means that the script fetched has been loaded.
    		//		Do not use this if doing a JSONP type of call (use `jsonp` instead).
    		// frameDoc: Document?
    		//		The Document object of a child iframe. If this is passed in, the script
    		//		will be attached to that document. This can be helpful in some comet long-polling
    		//		scenarios with Firefox and Opera.
    	});
    	script.__MethodOptions = declare(null, {
    		// method: String?
    		//		This option is ignored. All requests using this transport are
    		//		GET requests.
    	});
    	script.__Options = declare([script.__BaseOptions, script.__MethodOptions]);
    
    	script.get = function(url, options){
    		// summary:
    		//		Send an HTTP GET request using a script element with the given URL and options.
    		// url: String
    		//		URL to request
    		// options: dojo/request/script.__BaseOptions?
    		//		Options for the request.
    		// returns: dojo/request.__Promise
    	};
    	=====*/
    // TODO: Remove in 2.0
    script._attach = attach;
    script._remove = remove;
    script._callbacksProperty = mid + '_callbacks';
    return script;
  }(dojo_request_watch, dojo_request_util, dojo__base_kernel, dojo__base_array, dojo__base_lang, dojo_on, dojo_dom, dojo_has, dojo__base_window);
  dojox_cometd = function (cometdModule, JSON, dojox, dojoXHR, dojoSCRIPT) {
    function LongPollingTransport() {
      var _super = new cometdModule.LongPollingTransport();
      var that = cometdModule.Transport.derive(_super);
      that.xhrSend = function (packet) {
        var deferred = dojoXHR.post({
          url: packet.url,
          sync: packet.sync === true,
          contentType: 'application/json;charset=UTF-8',
          headers: packet.headers,
          postData: packet.body,
          withCredentials: true,
          handleAs: 'json',
          load: packet.onSuccess,
          error: function (error) {
            packet.onError(error.message, deferred ? deferred.ioArgs.error : error);
          }
        });
        return deferred.ioArgs.xhr;
      };
      return that;
    }
    // function CallbackPollingTransport() {
    //     var _super = new cometdModule.CallbackPollingTransport();
    //     var that = cometdModule.Transport.derive(_super);
    //
    //     that.jsonpSend = function(packet) {
    //         dojoSCRIPT.get(packet.url, {
    //             jsonp: 'jsonp',
    //             query: {
    //                 // In callback-polling, the content must be sent via the 'message' parameter
    //                 message: packet.body
    //             },
    //             sync: packet.sync === true
    //         }).then(packet.onSuccess, function(error) {
    //             // Actually never called by Dojo, perhaps a Dojo bug.
    //             packet.onError(error);
    //         });
    //         return undefined;
    //     };
    //
    //     return that;
    // }
    dojox.CometD = function (name) {
      var cometd = new cometdModule.CometD(name);
      cometd.unregisterTransports();
      // Registration order is important.
      if (window.WebSocket) {
        cometd.registerTransport('websocket', new cometdModule.WebSocketTransport());
      }
      cometd.registerTransport('long-polling', new LongPollingTransport());
      // cometd.registerTransport('callback-polling', new CallbackPollingTransport()); PATCHED
      return cometd;
    };
    // The default cometd instance
    var cometd = new dojox.CometD();
    dojox.cometd = cometd;
    return cometd;
  }(org_cometd, dojo_json, dojox, dojo__base_xhr, dojo_request_script);
  dojo_domReady = function () {
    var isTop, testDiv, scrollIntervalId, isBrowser = typeof window !== 'undefined' && window.document, isPageLoaded = !isBrowser, doc = isBrowser ? document : null, readyCalls = [];
    function runCallbacks(callbacks) {
      var i;
      for (i = 0; i < callbacks.length; i += 1) {
        callbacks[i](doc);
      }
    }
    function callReady() {
      var callbacks = readyCalls;
      if (isPageLoaded) {
        //Call the DOM ready callbacks
        if (callbacks.length) {
          readyCalls = [];
          runCallbacks(callbacks);
        }
      }
    }
    /**
     * Sets the page as loaded.
     */
    function pageLoaded() {
      if (!isPageLoaded) {
        isPageLoaded = true;
        if (scrollIntervalId) {
          clearInterval(scrollIntervalId);
        }
        callReady();
      }
    }
    if (isBrowser) {
      if (document.addEventListener) {
        //Standards. Hooray! Assumption here that if standards based,
        //it knows about DOMContentLoaded.
        document.addEventListener('DOMContentLoaded', pageLoaded, false);
        window.addEventListener('load', pageLoaded, false);
      } else if (window.attachEvent) {
        window.attachEvent('onload', pageLoaded);
        testDiv = document.createElement('div');
        try {
          isTop = window.frameElement === null;
        } catch (e) {
        }
        //DOMContentLoaded approximation that uses a doScroll, as found by
        //Diego Perini: http://javascript.nwbox.com/IEContentLoaded/,
        //but modified by other contributors, including jdalton
        if (testDiv.doScroll && isTop && window.external) {
          scrollIntervalId = setInterval(function () {
            try {
              testDiv.doScroll();
              pageLoaded();
            } catch (e) {
            }
          }, 30);
        }
      }
      //Check if document already complete, and if so, just trigger page load
      //listeners. Latest webkit browsers also use "interactive", and
      //will fire the onDOMContentLoaded before "interactive" but not after
      //entering "interactive" or "complete". More details:
      //http://dev.w3.org/html5/spec/the-end.html#the-end
      //http://stackoverflow.com/questions/3665561/document-readystate-of-interactive-vs-ondomcontentloaded
      //Hmm, this is more complicated on further use, see "firing too early"
      //bug: https://github.com/requirejs/domReady/issues/1
      //so removing the || document.readyState === "interactive" test.
      //There is still a window.onload binding that should get fired if
      //DOMContentLoaded is missed.
      //PATCH START
      var noInteractive = doc.documentElement.doScroll, loaded = (noInteractive ? /^loaded|^c/ : /^loaded|^i|^c/).test(document.readyState);
      if (loaded) {
        pageLoaded();
      }  //PATCH END
    }
    /** START OF PUBLIC API **/
    /**
     * Registers a callback for DOM ready. If DOM is already ready, the
     * callback is called immediately.
     * @param {Function} callback
     */
    function domReady(callback) {
      if (isPageLoaded) {
        callback(doc);
      } else {
        readyCalls.push(callback);
      }
      return domReady;
    }
    domReady.version = '2.0.1';
    /**
     * Loader Plugin API method
     */
    domReady.load = function (name, req, onLoad, config) {
      if (config.isBuild) {
        onLoad(null);
      } else {
        domReady(onLoad);
      }
    };
    /** END OF PUBLIC API **/
    return domReady;
  }();
  synchronite_proxyless_lib_lpSecureStorageAMD = function () {
    var win = window;
    /**
     * This taglet brings an iFrame to the page and then sets information inside.
     * It uses indexedDB, local storage, secure cookie or session storage (depends on browser limitations)
     * It limits the retrieval of data to the domain from which the data was set (and any other locations passed in on the set action)
     * and all liveperson domains. All keys are made up of key + siteId to ensure uniqueness per site
     * This only works in IE8 and up in Standards mode
     * @type {*}
     */
    if (win.lpTag && win.lpTag.taglets) {
      if (win.lpTag.taglets.lpSecureStorage) {
        return win.lpTag.taglets.lpSecureStorage;
      }
    } else {
      win.lpTag = win.lpTag || {};
      win.lpTag.taglets = win.lpTag.taglets || {};
    }
    lpTag.taglets.lpSecureStorage = lpTag.taglets.lpSecureStorage || function lpSecureStorage(window) {
      var name = 'lpSecureStorage', version = '2.0.4', sessionStorageStaticDomain = 'STATICSESSIONSTORAGE', windowLoaded = false, windowLoadPendingRequests = [], loadPendingFrames = [], frames = {}, pendingDomains = {}, pendingRequests = {}, domainErrors = {}, validResponseDomains = {}, requestQueue = {}, idCounter = 0, debugMode = false, frameMaxLoadTime = 7000, requestMaxResponseTime = 5000, errorCheckTimeout = 1000, faultToleranceLevel = 10, logLevel = {
          ERROR: 'ERROR',
          DEBUG: 'DEBUG',
          INFO: 'INFO'
        }, requestTypes = {
          SET: 'set',
          GET: 'get',
          REMOVE: 'remove'
        }, storageTypes = {
          LOCALSTORAGE: 'localStorage',
          SESSIONSTORAGE: 'sessionStorage',
          INDEXEDDB: 'indexedDB',
          COOKIE: 'secureSessionCookie',
          STATICSESSIONSTORAGE: sessionStorageStaticDomain
        }, errorTypes = { STORAGE: 'storage_error' }, chosenStorages = {}, chosenStoragesHandlers = {}, CHOSEN_STORAGE_KEY = 'SecureStorageClient/storageType', CROSS_DOMAIN_FEATURE = 'Common.LiveEngage_2_CrossDomainStorage', errorTimeoutId, sessionStorageMethodsObj, requestInProgress = {
          set: function (state, domain) {
            if (domain) {
              this[domain] = state;
            }
          },
          get: function (domain) {
            if (domain) {
              return this[domain];
            }
          }
        };
      /**
       * Binds to the window message or hash change event
       * depending on the protocol
       */
      bindEvent(window, 'message', _handleMessageFromFrame);
      _determineLoadState();
      function init() {
      }
      /**
       * Public get storage type method for a specified frame url
       * The entire chosenStorage object is returned when no url supplied
       * @param url - frame url to get storage of
       */
      function getStorageType(url) {
        if (url && chosenStorages[url]) {
          return chosenStorages[url];
        }
        return chosenStorages;
      }
      /**
       * Public get value method
       * Clears any value passed in on the request to prevent errors
       * @param request
       */
      function getValue(request) {
        if (request && request.value) {
          request.value = null;
          delete request.value;
        }
        request.type = requestTypes.GET;
        _makeRequest(request);
      }
      /**
       * Public set value method
       * @param request
       */
      function setValue(request) {
        if (request && request.expires === -1) {
          removeValue(request);
        } else {
          request.type = requestTypes.SET;
          _makeRequest(request);
        }
      }
      /**
       * Public remove value method
       * @param request
       */
      function removeValue(request) {
        if (request) {
          request.expires = -1;
        }
        request.type = requestTypes.REMOVE;
        _makeRequest(request);
      }
      /**
       * Public configure gets an object with :
       * url - the secure storager url
       * site - the siteid it needs
       * debug - a flag if debug should be enabled
       * initialStorageType - the type of the setorage to be initialized (if supplied)
       * force - force the selected storage
       * asyncStorageMaxRetry - number of retries to choose async storage type
       * @param configuration
       */
      function configure(configuration) {
        if (configuration && configuration.debug === true) {
          debugMode = true;
        }
        for (var key in configuration) {
          if (typeof configuration[key] === 'object' && configuration.hasOwnProperty(key) && configuration[key].site) {
            //noinspection JSUnresolvedVariable
            if (configuration[key].url && configuration[key].url.indexOf('http') === 0) {
              _debug('Configuring url ' + configuration[key].url);
              _attachFrame(configuration[key].url, configuration[key].site, configuration[key], configuration[key].chosenStorageHandler);
            } else if (configuration[key].url === sessionStorageStaticDomain) {
              _configureSessionStorage(configuration[key]);
            }
          }
        }
      }
      /**
       * Makes a single request
       * @param request
       * @private
       */
      function _makeRequest(request) {
        var forceSession = request.domain === sessionStorageStaticDomain;
        if (forceSession) {
          _makeSessionStorageRequest(request);
        } else {
          var domain = _getDomain(request.domain);
          //Get the domain, since this is localStorage different urls don't matter
          if (!requestInProgress.get(domain)) {
            makeIFrameStorageRequest(request, domain);
          } else {
            _addRequestToDomainQueue(request, domain);
          }
        }
      }
      /**
       * Creates the session storage constant object if the underlying libraries exist
       * Returns it's state if session storage works
       * @returns {*}
       * @private
       */
      function _isStorageEnabled() {
        if (lpTag.storageMethods && !sessionStorageMethodsObj) {
          sessionStorageMethodsObj = lpTag.storageMethods;
        }
        if (sessionStorageMethodsObj) {
          return sessionStorageMethodsObj.isSessionStorageEnabled();
        } else {
          return false;
        }
      }
      /**
       * Makes a session storage request locally
       * @param request
       * @private
       */
      function _makeSessionStorageRequest(request) {
        var key, result;
        if (_isStorageEnabled()) {
          key = '' + request.site + request.key;
          switch (request.type) {
          case requestTypes.GET:
            _runCallback(request.success, _getSessionData(key, request), request.key);
            break;
          case requestTypes.SET:
            _setSessionData(key, request);
            _runCallback(request.success, request.value, request.key);
            break;
          case requestTypes.REMOVE:
            result = { 'error': 'Object not found.' };
            if (_removeSessionData(key, request)) {
              result = void 0;
            }
            _runCallback(request.success, result, request.key);
            break;
          }
        } else {
          _runCallback(request.success, {
            error: 'SessionStorage is not active',
            code: 500
          }, request.key);
        }
      }
      /**
       * Extracts the value as it appears in the session storage
       * @param key
       * @returns {*}
       * @private
       */
      function _getRawSessionData(key) {
        var result = sessionStorageMethodsObj.getSessionData(key);
        try {
          result = result === '' ? '' : JSON.parse(result);
        } catch (exc) {
        }
        return result !== '' ? result : null;
      }
      /**
       * Extracts the data as it appears in the SecureStorage convention
       * @param key
       * @param request
       * @returns {*}
       * @private
       */
      function _getSessionData(key, request) {
        var result = _getRawSessionData(key);
        if (request.appName && result !== null && typeof result === 'object') {
          result = result[request.appName];
        }
        return result !== '' ? result : null;
      }
      /**
       * Sets a value in the Secure Storage convention
       * @param key
       * @param request
       * @returns {*}
       * @private
       */
      function _setSessionData(key, request) {
        var data = _getRawSessionData(key);
        if (data === null) {
          data = {};
        }
        if (typeof data === 'object') {
          data[request.appName] = request.value;
          return sessionStorageMethodsObj.setSessionData(key, _stringify(data));
        } else {
          return false;
        }
      }
      /**
       * Removes data from the session storage
       * @param key
       * @param request
       * @returns {*}
       * @private
       */
      function _removeSessionData(key, request) {
        var foundKeyAndAppName = false, keyHasOtherProps = false, data = _getRawSessionData(key);
        if (data !== null && typeof data === 'object' && data.hasOwnProperty(request.appName)) {
          data[request.appName] = null;
          delete data[request.appName];
          for (var dataKey in data) {
            if (data.hasOwnProperty(dataKey)) {
              keyHasOtherProps = true;
              break;
            }
          }
          foundKeyAndAppName = true;
        }
        if (foundKeyAndAppName && keyHasOtherProps) {
          //We're updating the data structure
          return sessionStorageMethodsObj.setSessionData(key, _stringify(data));
        } else if (foundKeyAndAppName) {
          //We found data and it's the last bit
          return sessionStorageMethodsObj.removeSessionData(key);
        } else {
          //Nothing to do, no data found
          return false;
        }
      }
      /**
       * Creates a postmessage cross iFrame request
       * @param request
       */
      function makeIFrameStorageRequest(request, domain) {
        //noinspection JSUnresolvedVariable
        if (request && (request.success || request.error) && request.key && request.appName && request.domain && request.site) {
          delete request.type;
          if (!windowLoaded) {
            windowLoadPendingRequests.push(function () {
              _makeRequest(request);
            });
          } else {
            if (frames[domain]) {
              //We have valid storage to service requests or no storage was yet chosen and this request will configure it
              if (!chosenStorages[domain] || chosenStorages[domain] && !chosenStorages[domain].error) {
                _addToPendingQueue(request);
                _sendPostMessageQuery(request);
                _debug('Made request for key: ' + request.key + ' appName: ' + request.appName);
              } else {
                _runCallback(request.error || request.success, null, request.key);
                _debug('No Storage Selected, Blocked request for key: ' + request.key + ' appName: ' + request.appName);
              }
            } else {
              //noinspection JSUnresolvedVariable
              _attachFrame(request.domain, request.site, request.initialStorageType, request.chosenStorageHandler);
              pendingDomains[domain].push(request);
            }
          }
        }
      }
      /**
       * Writes a request to a specific domain queue to be called
       * These requests have not begun
       * @param request
       * @param domain
       * @private
       */
      function _addRequestToDomainQueue(request, domain) {
        requestQueue[domain] = typeof requestQueue[domain] === 'undefined' ? [] : requestQueue[domain];
        requestQueue[domain].push(request);
      }
      /**
       * Checks our pending request queue for requests
       * that have not returned within a reasonable time frame
       * @private
       */
      function _checkForErrors() {
        var now = new Date().getTime(), activeRequests = false, diff;
        if (errorTimeoutId) {
          clearTimeout(errorTimeoutId);
          errorTimeoutId = null;
        }
        for (var id in pendingRequests) {
          if (pendingRequests.hasOwnProperty(id)) {
            diff = 0;
            diff = now - pendingRequests[id].startTime;
            if (diff >= requestMaxResponseTime) {
              _error('iFrame not responding in time to requests, domain: ' + pendingRequests[id].domain);
              _dispatchResult(id, pendingRequests[id].key, null, true);
            } else {
              activeRequests = true;
            }
          }
        }
        _setErrorTimeout(activeRequests);
      }
      /**
       * Sets the next time we check for errors
       * @param enable
       * @private
       */
      function _setErrorTimeout(enable) {
        if (enable && !errorTimeoutId) {
          errorTimeoutId = setTimeout(_checkForErrors, errorCheckTimeout);
        }
      }
      /**
       *
       * @param domain
       * @param error
       * @private
       */
      function _manageErrorState(domain, error) {
        if (error) {
          if (typeof domainErrors[domain] === 'undefined') {
            domainErrors[domain] = 1;
          } else {
            domainErrors[domain] = domainErrors[domain] + 1;
          }
        } else {
          domainErrors[domain] = 0;
        }
        _debug('Domain ' + domain + ' error count: ' + domainErrors[domain], '_manageErrorState');
        if (domainErrors[domain] > faultToleranceLevel) {
          _frameLoadError(requestQueue[domain], domain, 'iFrame not responding in time to requests');
        }
      }
      /**
       * Removes the iFrame from the DOM
       * and cleans up the internal object
       * @param domain
       */
      function _removeIFrame(domain) {
        if (frames[domain] && frames[domain].parentNode) {
          frames[domain].parentNode.removeChild(frames[domain]);
          frames[domain] = null;
          delete frames[domain];
          domainErrors[domain] = 0;
          _error('Removed iFrame for domain', '_removeIFrame');
        }
      }
      /**
       * Sets the window load status to be ASAP after page has begun to download
       * when the body opens
       */
      function _determineLoadState() {
        if (!document.body) {
          setTimeout(_determineLoadState, 0);
        } else {
          _loaded();
        }
      }
      /**
       * Listens for incoming messages fro the IFrame
       * @param msg
       */
      function _handleMessageFromFrame(msg) {
        if (msg && msg.data && validResponseDomains[msg.origin]) {
          _runListeners(msg.data, msg.origin);
        }
      }
      /**
       * Deletes requests after they've been completed
       * @param id
       */
      function _deletePendingRequest(id) {
        pendingRequests[id] = null;
        delete pendingRequests[id];
      }
      /**
       * Runs all listeners to this request
       * @param data
       * @param origin
       */
      function _runListeners(data, origin) {
        var id, key, responseData, res = _parseResponse(data);
        if (res) {
          id = res.id;
          key = res.key;
          if (CHOSEN_STORAGE_KEY === key) {
            _handleStorageSelection(res, origin);
          } else {
            responseData = typeof res.value !== 'undefined' ? res.value : res.error;
            _dispatchResult(id, res.key, responseData, !!res.error);
            _debug('Got result for key: ' + res.key + ' appName: ' + res.appName);
          }
        }
      }
      /**
       * Handles setting selected storage and notifying any listeners
       * @param res
       * @param origin
       * @private
       */
      function _handleStorageSelection(res, origin) {
        // In case the message key represents a storage type selection message
        // I'll set the chosenStorage for that origin for later use
        chosenStorages[origin] = res.value;
        _debug('Got storage type: ' + res.value + ' for origin: ' + origin + ' appName: ' + res.appName);
        // Invoke supplied handler for chosenStorage if any
        if (chosenStoragesHandlers[origin]) {
          _runCallback(chosenStoragesHandlers[origin], res.value);
        }
      }
      /**
       * Function for running callbacks and cleaning the queue
       * @param id
       * @param key
       * @param data
       * @param error
       * @private
       */
      function _dispatchResult(id, key, data, error) {
        var listener = _getListener(id), domain;
        if (listener) {
          domain = _getDomain(listener.domain);
          _runResponses(listener, data, key, error);
        }
        if (id) {
          _deletePendingRequest(id);
        }
        requestInProgress.set(false, domain);
        _manageErrorState(domain, error);
        if (requestQueue[domain] && requestQueue[domain].length > 0) {
          _makeRequest(requestQueue[domain].shift());
        }
      }
      /**
       * Returns a list of listeners for this data
       * @param id - the id of the specific request made
       * @return {Array} - returns an array of callbacks to trigger
       */
      function _getListener(id) {
        if (id && pendingRequests[id]) {
          return pendingRequests[id];
        }
      }
      /**
       * Runs all the requests pending for that key
       */
      function _runResponses(listener, responseData, key, error) {
        if (error) {
          _runCallback(listener.error, responseData, key);
        } else {
          _runCallback(listener.success, responseData, key);
        }
      }
      /**
       * Parses the response that we got for the event
       * @param res
       * @return {String}
       */
      function _parseResponse(res) {
        try {
          res = decodeURIComponent(res);
          res = JSON.parse(res);
        } catch (exc) {
        }
        return res;
      }
      /**
       * This function was added because of incompatibility between the JSON.stringify and Prototype.js library
       * When a costumer uses Prototype.js library, It overrides the Array.prototype.toJSON function the the native JSON
       * uses. This causes arrays to be double quoted and Shark to fail on those SDEs.
       * The function accepts a value and and uses the native JSON.stringify
       * Can throw an exception (same as JSON.stringify).
       */
      function _stringify(value) {
        var stringified, toJSONPrototype;
        if (typeof Array.prototype.toJSON === 'function') {
          toJSONPrototype = Array.prototype.toJSON;
          delete Array.prototype.toJSON;
          try {
            stringified = JSON.stringify(value);
          } catch (e) {
            Array.prototype.toJSON = toJSONPrototype;
            throw e;
          }
          Array.prototype.toJSON = toJSONPrototype;
        } else {
          stringified = JSON.stringify(value);
        }
        return stringified;
      }
      /**
       * Runs a callback function
       * @param func
       * @param data
       * @param key
       */
      function _runCallback(func, data, key) {
        if (typeof func === 'function') {
          try {
            func(data, key);
          } catch (exc) {
          }
        }
      }
      /**
       * Binds a DOM event to an object
       * @param elem
       * @param eventName
       * @param callback
       */
      function bindEvent(elem, eventName, callback) {
        if (window.addEventListener) {
          elem.addEventListener(eventName, callback, false);
        } else {
          elem.attachEvent('on' + eventName, callback);
        }
      }
      /**
       * Configures session storage with the same conventions as
       * attaching an iFrame
       * @param configuration
       * @private
       */
      function _configureSessionStorage(configuration) {
        var result = { value: 'NONE' };
        chosenStoragesHandlers[sessionStorageStaticDomain] = configuration.chosenStorageHandler;
        if (_isStorageEnabled()) {
          frames[sessionStorageStaticDomain] = true;
          result = { value: storageTypes.STATICSESSIONSTORAGE };
        }
        _handleStorageSelection(result, sessionStorageStaticDomain);
      }
      /**
       * Attaches the iFrame to the DOM
       * and sets it to load
       * @param url - the iFrame location
       * @param site - the first siteId to request this iFrame
       * @param configuration - the frame configuration
       * @param chosenStorageHandler - the handler function for when a storage type is chosen
       * @returns {*}
       * @private
       */
      function _attachFrame(url, site, configuration, chosenStorageHandler) {
        var frame, domain = _getDomain(url);
        if (!frames[domain] && !pendingDomains[domain]) {
          _debug('Attaching iFrame: ' + url + ' domain: ' + domain);
          frame = createIFrame();
          validResponseDomains[domain] = true;
          frame.setAttribute('src', _buildCurrentDomainOnUrl(url, site, configuration));
          pendingDomains[domain] = [];
          if (chosenStorageHandler) {
            chosenStoragesHandlers[domain] = chosenStorageHandler;
          }
          if (!windowLoaded) {
            loadPendingFrames.push(_createBindAndAppend(domain, frame));
          } else {
            _createBindAndAppend(domain, frame)();
          }
        }
        return frame;
      }
      /**
       * Creates an iFrame with all the needed properties
       * for display and accessibility compliance
       * @returns {HTMLElement}
       */
      function createIFrame() {
        var frame = document.createElement('iframe'), style = frame.style, id = 'lpSS_' + Math.floor(Math.random() * 90000000000), props = {
            //Hide iFrame from screen-readers
            'tabIndex': '-1',
            'aria-hidden': 'true',
            'role': 'presentation',
            'title': 'Intentionally blank',
            'name': id,
            'id': id
          };
        style.width = '0px';
        style.height = '0px';
        style.position = 'absolute';
        style.top = '-1000px';
        style.left = '-1000px';
        for (var key in props) {
          if (props.hasOwnProperty(key)) {
            frame.setAttribute(key, props[key]);
          }
        }
        return frame;
      }
      /**
       * Adds the iFrame to the DOM, adds a timeout listener and
       * binds to it's load event
       * @param domain
       * @param frame
       * @returns function
       * @private
       */
      function _createBindAndAppend(domain, frame) {
        return function _bindAndAppend() {
          var loadTimeout = setTimeout(function () {
            _frameLoadError(pendingDomains[domain], domain, 'unable to load iFrame for key');
          }, frameMaxLoadTime);
          bindEvent(frame, 'load', function () {
            _runPendingForDomain(frame, domain, loadTimeout);
          });
          document.body.appendChild(frame);
        };
      }
      /**
       * In case we have an issue loading the iFrame
       * @param requestsArray
       * @param domain
       * @param error
       * @private
       */
      function _frameLoadError(requestsArray, domain, error) {
        while (requestsArray.length > 0) {
          var request = requestsArray.shift();
          if (request.error) {
            setTimeout(_getAsyncCallback(request.error, error || {
              error: error,
              key: request.key
            }, request.key), 0);
          }
        }
        _removeIFrame(domain);
      }
      /**
       * Runs the callback async
       * @param func
       * @param data
       * @param key
       * @returns {Function}
       */
      function _getAsyncCallback(func, data, key) {
        return function () {
          _runCallback(func, data, key);
        };
      }
      /**
       * Register pointer to frame
       * Runs all pending requests for a specific iFrame
       * @param frame
       * @param domain
       * @param loadTimeout
       * @private
       */
      function _runPendingForDomain(frame, domain, loadTimeout) {
        if (loadTimeout) {
          clearTimeout(loadTimeout);
        }
        frames[domain] = frame;
        _debug('Frame loaded ' + domain + ' running pending request for frame');
        if (pendingDomains[domain]) {
          while (pendingDomains[domain].length > 0) {
            _makeRequest(pendingDomains[domain].shift());
          }
          pendingDomains[domain] = null;
          delete pendingDomains[domain];
        }
      }
      /**
       * Sets the current domain so we know where we're hosted
       * @param storagePath
       * @param site
       * @param configuration
       * @return {*}
       */
      function _buildCurrentDomainOnUrl(storagePath, site, configuration) {
        var port, env, storageFileName, url;
        if (storagePath && typeof storagePath === 'string') {
          env = _getEnv();
          storageFileName = _getStorageFileName(configuration);
          storagePath = _getStoragePath(storagePath);
          port = 0 < location.port.length ? ':' + location.port : '';
          url = storagePath + '/' + storageFileName + '?loc=' + encodeURIComponent(location.protocol + '//' + location.hostname + port) + '&site=' + encodeURIComponent(site) + (configuration.initialStorageType ? '&ist=' + encodeURIComponent(configuration.initialStorageType) : '') + (configuration.force ? '&force=' + 1 : '') + (env ? '&env=' + encodeURIComponent(env) : '') + (_isCrossDomainEnabled() ? '&isCrossDomain=true' : '');
        }
        return url;
      }
      function _getStoragePath(storageUrl) {
        var last = storageUrl.lastIndexOf('/'), query, result;
        if (last > 8) {
          result = storageUrl.substr(0, last);
        } else {
          query = storageUrl.indexOf('?');
          if (query > 0) {
            result = storageUrl.substr(0, query);
          }
        }
        return result;
      }
      function _getStorageFileName(configuration) {
        var fileName = 'storage.min.html';
        //Backward compatibility -Last version of secure storage
        if (debugMode) {
          fileName = 'storage.html';
        } else if (configuration.env) {
          //TODO - sync with coBrowse about storage version
          fileName = 'storage.secure.min.html';
        }
        return fileName;
      }
      /**
       * Gets the domain including protocol
       * @param url
       */
      function _getDomain(url) {
        //noinspection JSCheckFunctionSignatures
        var domainRegEx = new RegExp(/(http{1}s{0,1}?:\/\/){0,1}([^\/\?]+)(\/?)/gi), matches = domainRegEx.exec(url), domain = null;
        if (matches && matches.length >= 3 && matches[2] !== '') {
          domain = matches[1] + matches[2].toLowerCase();  // 0 - full match 1- HTTPS 2- domain
        }
        return domain;
      }
      /**
       * Builds an object we can use to run a post message query with
       * @param request
       */
      function _buildPostMessageQuery(request) {
        var postMessageRequest = {};
        postMessageRequest.id = request.id;
        postMessageRequest.key = request.key;
        postMessageRequest.site = request.site;
        postMessageRequest.appName = request.appName || '*';
        if (!isNaN(request.expires)) {
          postMessageRequest.expires = request.expires;
        }
        if (typeof request.value !== 'undefined') {
          postMessageRequest.value = request.value;
          //TODO - remove once coBrowse supports the new structured secure storage
          postMessageRequest.locations = _addDefaultLocation(request.locations);
        }
        return postMessageRequest;
      }
      /**
       * The locations where this data will be retrievable
       * @param locations
       * @deprecated - locations won't be available when cross-domain feature
       */
      function _addDefaultLocation(locations) {
        if (locations) {
          locations = locations.constructor === Array ? locations : [locations];
        } else {
          locations = [];
        }
        locations.push(document.location.hostname);
        return locations;
      }
      /**
       * Sends a post message query if possible
       * @param request
       */
      function _sendPostMessageQuery(request) {
        var query, domain = _getDomain(request.domain);
        if (frames[domain]) {
          request.startTime = new Date().getTime();
          query = _buildPostMessageQuery(request);
          requestInProgress.set(true, domain);
          _postTheMessage(query, domain);
          _setErrorTimeout(true);
        }
      }
      /**
       * Posts the message to the child iFrame
       * @param request
       * @param domain
       */
      function _postTheMessage(request, domain) {
        if (frames[domain]) {
          frames[domain].contentWindow.postMessage(_prepareRequestData(request), domain);
        }
      }
      /**
       * Stringifies and encodes a message before sending it
       * @param data
       */
      function _prepareRequestData(data) {
        try {
          data = _stringify(data);
          data = encodeURIComponent(data);
        } catch (exc) {
        }
        return data;
      }
      /**
       * Notifies of load and handles all request prior to
       * the body element existing
       */
      function _loaded() {
        windowLoaded = true;
        while (loadPendingFrames.length > 0) {
          try {
            loadPendingFrames.shift()();
          } catch (exc) {
          }
        }
        while (windowLoadPendingRequests.length > 0) {
          try {
            windowLoadPendingRequests.shift()();
          } catch (exc) {
          }
        }
      }
      /**
       * Creates a string Id
       * @returns {string}
       */
      function _createRandomKey() {
        idCounter++;
        if (idCounter > 20000) {
          idCounter = 0;
        }
        return 'k' + idCounter + new Date().getTime() + parseInt(Math.random() * 100, 10);
      }
      /**
       * Adds an item to our queue
       * @param request
       * @param key
       */
      function _addToPendingQueue(request, key) {
        request.id = key ? key : _createRandomKey();
        if (typeof request.value !== 'undefined') {
          request.type = 'set';
        }
        pendingRequests[request.id] = request;
      }
      function _isCrossDomainEnabled() {
        return lpTag.features && typeof lpTag.features.getFeature === 'function' && lpTag.features.getFeature(CROSS_DOMAIN_FEATURE);
      }
      function _getEnv() {
        return typeof lpTag.getEnv === 'function' && lpTag.getEnv();
      }
      /**
       * Log function
       * @param msg - the text information
       * @param lvl - INFO or ERROR
       */
      function _log(msg, lvl) {
        if (window.lpTag && lpTag.log) {
          lpTag.log(msg, lvl, name);
        }
      }
      /**
       * Shorthand for errors
       * @private
       */
      function _error(msg) {
        _log(msg, logLevel.ERROR);
      }
      /**
       * Shorthand for debug
       * @private
       */
      function _debug(msg) {
        _log(msg, logLevel.DEBUG);
      }
      /**
       * Shorthand for info
       * @private
       */
      function _info(msg) {
        _log(msg, logLevel.INFO);
      }
      return {
        storageTypes: storageTypes,
        getStorageType: getStorageType,
        getValue: getValue,
        setValue: setValue,
        removeValue: removeValue,
        configure: configure,
        sessionStorageStaticDomain: sessionStorageStaticDomain,
        errorTypes: errorTypes,
        v: version,
        name: name,
        init: init,
        inspect: function () {
          var configuredFrames = {};
          for (var key in frames) {
            if (frames.hasOwnProperty(key)) {
              // The configured frame consists of the
              // frame url and storageType (if known)
              configuredFrames[key] = {
                url: key,
                storageType: chosenStorages[key]
              };
            }
          }
          return {
            name: name,
            version: version,
            configuredFrames: configuredFrames
          };
        }
      };
    }(window);
    return win.lpTag.taglets.lpSecureStorage;
  }();
  dojo__base_url = function (dojo) {
    // module:
    //		dojo/url
    var ore = new RegExp('^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$'), ire = new RegExp('^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$'), _Url = function () {
        var n = null, _a = arguments, uri = [_a[0]];
        // resolve uri components relative to each other
        for (var i = 1; i < _a.length; i++) {
          if (!_a[i]) {
            continue;
          }
          // Safari doesn't support this.constructor so we have to be explicit
          // FIXME: Tracked (and fixed) in Webkit bug 3537.
          //		http://bugs.webkit.org/show_bug.cgi?id=3537
          var relobj = new _Url(_a[i] + ''), uriobj = new _Url(uri[0] + '');
          if (relobj.path == '' && !relobj.scheme && !relobj.authority && !relobj.query) {
            if (relobj.fragment != n) {
              uriobj.fragment = relobj.fragment;
            }
            relobj = uriobj;
          } else if (!relobj.scheme) {
            relobj.scheme = uriobj.scheme;
            if (!relobj.authority) {
              relobj.authority = uriobj.authority;
              if (relobj.path.charAt(0) != '/') {
                var path = uriobj.path.substring(0, uriobj.path.lastIndexOf('/') + 1) + relobj.path;
                var segs = path.split('/');
                for (var j = 0; j < segs.length; j++) {
                  if (segs[j] == '.') {
                    // flatten "./" references
                    if (j == segs.length - 1) {
                      segs[j] = '';
                    } else {
                      segs.splice(j, 1);
                      j--;
                    }
                  } else if (j > 0 && !(j == 1 && segs[0] == '') && segs[j] == '..' && segs[j - 1] != '..') {
                    // flatten "../" references
                    if (j == segs.length - 1) {
                      segs.splice(j, 1);
                      segs[j - 1] = '';
                    } else {
                      segs.splice(j - 1, 2);
                      j -= 2;
                    }
                  }
                }
                relobj.path = segs.join('/');
              }
            }
          }
          uri = [];
          if (relobj.scheme) {
            uri.push(relobj.scheme, ':');
          }
          if (relobj.authority) {
            uri.push('//', relobj.authority);
          }
          uri.push(relobj.path);
          if (relobj.query) {
            uri.push('?', relobj.query);
          }
          if (relobj.fragment) {
            uri.push('#', relobj.fragment);
          }
        }
        this.uri = uri.join('');
        // break the uri into its main components
        var r = this.uri.match(ore);
        this.scheme = r[2] || (r[1] ? '' : n);
        this.authority = r[4] || (r[3] ? '' : n);
        this.path = r[5];
        // can never be undefined
        this.query = r[7] || (r[6] ? '' : n);
        this.fragment = r[9] || (r[8] ? '' : n);
        if (this.authority != n) {
          //PATCHED: fix for usbank. url looked like this: https://onlinebanking---usbank---com.synchronite.de:/USB/
          // The character ":" without a port number caused an exception, so ":" will be removed
          if (this.authority.indexOf(':', this.authority.length - 1) !== -1) {
            this.authority = this.authority.substring(0, this.authority.length - 1);
          }
          //PATCH END
          // server based naming authority
          r = this.authority.match(ire);
          this.user = r[3] || n;
          this.password = r[4] || n;
          this.host = r[6] || r[7];
          // ipv6 || ipv4
          this.port = r[9] || n;
        }
      };
    _Url.prototype.toString = function () {
      return this.uri;
    };
    return dojo._Url = _Url;
  }(dojo__base_kernel);
  synchronite_libs_sizzle = function (window, undefined) {
    var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate,
      // Local document vars
      setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains,
      // Instance-specific data
      expando = 'sizzle' + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function (a, b) {
        if (a === b) {
          hasDuplicate = true;
        }
        return 0;
      },
      // Instance methods
      hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, pushNative = arr.push, push = arr.push, slice = arr.slice,
      // Use a stripped-down indexOf as it's faster than native
      // https://jsperf.com/thor-indexof-vs-for/5
      indexOf = function (list, elem) {
        var i = 0, len = list.length;
        for (; i < len; i++) {
          if (list[i] === elem) {
            return i;
          }
        }
        return -1;
      }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|' + 'ismap|loop|multiple|open|readonly|required|scoped',
      // Regular expressions
      // http://www.w3.org/TR/css3-selectors/#whitespace
      whitespace = '[\\x20\\t\\r\\n\\f]',
      // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
      identifier = '(?:\\\\[\\da-fA-F]{1,6}' + whitespace + '?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+',
      // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
      attributes = '\\[' + whitespace + '*(' + identifier + ')(?:' + whitespace + // Operator (capture 2)
      '*([*^$|!~]?=)' + whitespace + // "Attribute values must be CSS identifiers [capture 5]
      // or strings [capture 3 or capture 4]"
      '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' + identifier + '))|)' + whitespace + '*\\]', pseudos = ':(' + identifier + ')(?:\\((' + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
      // 1. quoted (capture 3; capture 4 or capture 5)
      '(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|' + // 2. simple (capture 6)
      '((?:\\\\.|[^\\\\()[\\]]|' + attributes + ')*)|' + // 3. anything else (capture 2)
      '.*' + ')\\)|)',
      // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
      rwhitespace = new RegExp(whitespace + '+', 'g'), rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rdescend = new RegExp(whitespace + '|>'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
        'ID': new RegExp('^#(' + identifier + ')'),
        'CLASS': new RegExp('^\\.(' + identifier + ')'),
        'TAG': new RegExp('^(' + identifier + '|[*])'),
        'ATTR': new RegExp('^' + attributes),
        'PSEUDO': new RegExp('^' + pseudos),
        'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
        'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
        // For use in libraries implementing .is()
        // We use this for POS matching in `select`
        'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
      }, rhtml = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/,
      // Easily-parseable/retrievable ID or TAG or CLASS selectors
      rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/,
      // CSS escapes
      // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
      runescape = new RegExp('\\\\[\\da-fA-F]{1,6}' + whitespace + '?|\\\\([^\\r\\n\\f])', 'g'), funescape = function (escape, nonHex) {
        var high = '0x' + escape.slice(1) - 65536;
        return nonHex ? // Strip the backslash prefix from a non-hex escape sequence
        nonHex : // Replace a hexadecimal escape sequence with the encoded Unicode code point
        // Support: IE <=11+
        // For values outside the Basic Multilingual Plane (BMP), manually construct a
        // surrogate pair
        high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
      },
      // CSS string/identifier serialization
      // https://drafts.csswg.org/cssom/#common-serializing-idioms
      rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function (ch, asCodePoint) {
        if (asCodePoint) {
          // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
          if (ch === '\0') {
            return '\uFFFD';
          }
          // Control characters and (dependent upon position) numbers get escaped as code points
          return ch.slice(0, -1) + '\\' + ch.charCodeAt(ch.length - 1).toString(16) + ' ';
        }
        // Other potentially-special ASCII characters get backslash-escaped
        return '\\' + ch;
      },
      // Used for iframes
      // See setDocument()
      // Removing the function wrapper causes a "Permission Denied"
      // error in IE
      unloadHandler = function () {
        setDocument();
      }, inDisabledFieldset = addCombinator(function (elem) {
        return elem.disabled === true && elem.nodeName.toLowerCase() === 'fieldset';
      }, {
        dir: 'parentNode',
        next: 'legend'
      });
    // Optimize for push.apply( _, NodeList )
    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
      // Support: Android<4.0
      // Detect silently failing push.apply
      // eslint-disable-next-line no-unused-expressions
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ? function (target, els) {
          pushNative.apply(target, slice.call(els));
        } : function (target, els) {
          var j = target.length, i = 0;
          while (target[j++] = els[i++]) {
          }
          target.length = j - 1;
        }
      };
    }
    function Sizzle(selector, context, results, seed) {
      var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument,
        // nodeType defaults to 9, since context defaults to document
        nodeType = context ? context.nodeType : 9;
      results = results || [];
      // Return early from calls with invalid selector or context
      if (typeof selector !== 'string' || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      }
      // Try to shortcut find operations (as opposed to filters) in HTML documents
      if (!seed) {
        setDocument(context);
        context = context || document;
        if (documentIsHTML) {
          // If the selector is sufficiently simple, try using a "get*By*" DOM method
          // (excepting DocumentFragment context, where the methods don't exist)
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            // ID selector
            if (m = match[1]) {
              // Document context
              if (nodeType === 9) {
                if (elem = context.getElementById(m)) {
                  // Support: IE, Opera, Webkit
                  // TODO: identify versions
                  // getElementById can match elements by name instead of ID
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                }  // Element context
              } else {
                // Support: IE, Opera, Webkit
                // TODO: identify versions
                // getElementById can match elements by name instead of ID
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              }  // Type selector
            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;  // Class selector
            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }
          // Take advantage of querySelectorAll
          if (support.qsa && !nonnativeSelectorCache[selector + ' '] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && (nodeType !== 1 || context.nodeName.toLowerCase() !== 'object')) {
            newSelector = selector;
            newContext = context;
            // qSA considers elements outside a scoping root when evaluating child or
            // descendant combinators, which is not what we want.
            // In such cases, we work around the behavior by prefixing every selector in the
            // list with an ID selector referencing the scope context.
            // The technique has to be used as well when a leading combinator is used
            // as such selectors are not recognized by querySelectorAll.
            // Thanks to Andrew Dupont for this technique.
            if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
              // Expand context for sibling selectors
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
              // We can use :scope instead of the ID hack if the browser
              // supports it & if we're not changing the context.
              if (newContext !== context || !support.scope) {
                // Capture the context ID, setting it first if necessary
                if (nid = context.getAttribute('id')) {
                  nid = nid.replace(rcssescape, fcssescape);
                } else {
                  context.setAttribute('id', nid = expando);
                }
              }
              // Prefix every selector in the list
              groups = tokenize(selector);
              i = groups.length;
              while (i--) {
                groups[i] = (nid ? '#' + nid : ':scope') + ' ' + toSelector(groups[i]);
              }
              newSelector = groups.join(',');
            }
            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {
              nonnativeSelectorCache(selector, true);
            } finally {
              if (nid === expando) {
                context.removeAttribute('id');
              }
            }
          }
        }
      }
      // All others
      return select(selector.replace(rtrim, '$1'), context, results, seed);
    }
    /**
     * Create key-value caches of limited size
     * @returns {function(string, object)} Returns the Object data after storing it on itself with
     *    property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *    deleting the oldest entry
     */
    function createCache() {
      var keys = [];
      function cache(key, value) {
        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
        if (keys.push(key + ' ') > Expr.cacheLength) {
          // Only keep the most recent entries
          delete cache[keys.shift()];
        }
        return cache[key + ' '] = value;
      }
      return cache;
    }
    /**
     * Mark a function for special use by Sizzle
     * @param {Function} fn The function to mark
     */
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    /**
     * Support testing using an element
     * @param {Function} fn Passed the created element and returns a boolean result
     */
    function assert(fn) {
      var el = document.createElement('fieldset');
      try {
        return !!fn(el);
      } catch (e) {
        return false;
      } finally {
        // Remove from its parent by default
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        }
        // release memory in IE
        el = null;
      }
    }
    /**
     * Adds the same handler for all of the specified attrs
     * @param {String} attrs Pipe-separated list of attributes
     * @param {Function} handler The method that will be applied
     */
    function addHandle(attrs, handler) {
      var arr = attrs.split('|'), i = arr.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    /**
     * Checks document order of two siblings
     * @param {Element} a
     * @param {Element} b
     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
     */
    function siblingCheck(a, b) {
      var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
      // Use IE sourceIndex if available on both nodes
      if (diff) {
        return diff;
      }
      // Check if b follows a
      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    /**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */
    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === 'input' && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */
    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === 'input' || name === 'button') && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for :enabled/:disabled
     * @param {Boolean} disabled true for :disabled; false for :enabled
     */
    function createDisabledPseudo(disabled) {
      // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
      return function (elem) {
        // Only certain elements can match :enabled or :disabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
        if ('form' in elem) {
          // Check for inherited disabledness on relevant non-disabled elements:
          // * listed form-associated elements in a disabled fieldset
          //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
          // * option elements in a disabled optgroup
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
          // All such elements have a "form" property.
          if (elem.parentNode && elem.disabled === false) {
            // Option elements defer to a parent optgroup if present
            if ('label' in elem) {
              if ('label' in elem.parentNode) {
                return elem.parentNode.disabled === disabled;
              } else {
                return elem.disabled === disabled;
              }
            }
            // Support: IE 6 - 11
            // Use the isDisabled shortcut property to check for disabled fieldset ancestors
            return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
            /* jshint -W018 */
            elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
          }
          return elem.disabled === disabled;  // Try to winnow out elements that can't be disabled before trusting the disabled property.
                                              // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                                              // even exist on them, let alone have a boolean value.
        } else if ('label' in elem) {
          return elem.disabled === disabled;
        }
        // Remaining elements are neither :enabled nor :disabled
        return false;
      };
    }
    /**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */
    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
          // Match elements found at the specified indexes
          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    /**
     * Checks a node for validity as a Sizzle context
     * @param {Element|Object=} context
     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
     */
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== 'undefined' && context;
    }
    // Expose support vars for convenience
    support = Sizzle.support = {};
    /**
     * Detects XML nodes
     * @param {Element|Object} elem An element or a document
     * @returns {Boolean} True iff elem is a non-HTML XML node
     */
    isXML = Sizzle.isXML = function (elem) {
      var namespace = elem.namespaceURI, docElem = (elem.ownerDocument || elem).documentElement;
      // Support: IE <=8
      // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
      // https://bugs.jquery.com/ticket/4833
      return !rhtml.test(namespace || docElem && docElem.nodeName || 'HTML');
    };
    /**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [doc] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */
    setDocument = Sizzle.setDocument = function (node) {
      var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
      // Return early if doc is invalid or already selected
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      // Update global variables
      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document);
      // Support: IE 9 - 11+, Edge 12 - 18+
      // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
        // Support: IE 11, Edge
        if (subWindow.addEventListener) {
          subWindow.addEventListener('unload', unloadHandler, false);  // Support: IE 9 - 10 only
        } else if (subWindow.attachEvent) {
          subWindow.attachEvent('onunload', unloadHandler);
        }
      }
      // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
      // Safari 4 - 5 only, Opera <=11.6 - 12.x only
      // IE/Edge & older browsers don't support the :scope pseudo-class.
      // Support: Safari 6.0 only
      // Safari 6.0 supports :scope but it's an alias of :root there.
      support.scope = assert(function (el) {
        docElem.appendChild(el).appendChild(document.createElement('div'));
        return typeof el.querySelectorAll !== 'undefined' && !el.querySelectorAll(':scope fieldset div').length;
      });
      /* Attributes
      ---------------------------------------------------------------------- */
      // Support: IE<8
      // Verify that getAttribute really returns attributes and not properties
      // (excepting IE8 booleans)
      support.attributes = assert(function (el) {
        el.className = 'i';
        return !el.getAttribute('className');
      });
      /* getElement(s)By*
      ---------------------------------------------------------------------- */
      // Check if getElementsByTagName("*") returns only elements
      support.getElementsByTagName = assert(function (el) {
        el.appendChild(document.createComment(''));
        return !el.getElementsByTagName('*').length;
      });
      // Support: IE<9
      support.getElementsByClassName = rnative.test(document.getElementsByClassName);
      // Support: IE<10
      // Check if getElementById returns elements by name
      // The broken getElementById methods don't pick up programmatically-set names,
      // so use a roundabout getElementsByName test
      support.getById = assert(function (el) {
        docElem.appendChild(el).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      });
      // ID filter and find
      if (support.getById) {
        Expr.filter['ID'] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute('id') === attrId;
          };
        };
        Expr.find['ID'] = function (id, context) {
          if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
            var elem = context.getElementById(id);
            return elem ? [elem] : [];
          }
        };
      } else {
        Expr.filter['ID'] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node = typeof elem.getAttributeNode !== 'undefined' && elem.getAttributeNode('id');
            return node && node.value === attrId;
          };
        };
        // Support: IE 6 - 7 only
        // getElementById is not reliable as a find shortcut
        Expr.find['ID'] = function (id, context) {
          if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
            var node, i, elems, elem = context.getElementById(id);
            if (elem) {
              // Verify the id attribute
              node = elem.getAttributeNode('id');
              if (node && node.value === id) {
                return [elem];
              }
              // Fall back on getElementsByName
              elems = context.getElementsByName(id);
              i = 0;
              while (elem = elems[i++]) {
                node = elem.getAttributeNode('id');
                if (node && node.value === id) {
                  return [elem];
                }
              }
            }
            return [];
          }
        };
      }
      // Tag
      Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
        if (typeof context.getElementsByTagName !== 'undefined') {
          return context.getElementsByTagName(tag);  // DocumentFragment nodes don't have gEBTN
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function (tag, context) {
        var elem, tmp = [], i = 0,
          // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
          results = context.getElementsByTagName(tag);
        // Filter out possible comments
        if (tag === '*') {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      // Class
      Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
        if (typeof context.getElementsByClassName !== 'undefined' && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      /* QSA/matchesSelector
      ---------------------------------------------------------------------- */
      // QSA and matchesSelector support
      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
      rbuggyMatches = [];
      // qSa(:focus) reports false when true (Chrome 21)
      // We allow this because of a bug in IE8/9 that throws an error
      // whenever `document.activeElement` is accessed on an iframe
      // So, we allow :focus to pass through QSA all the time to avoid the IE error
      // See https://bugs.jquery.com/ticket/13378
      rbuggyQSA = [];
      if (support.qsa = rnative.test(document.querySelectorAll)) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function (el) {
          // Select is set to empty string on purpose
          // This is to test IE's treatment of not explicitly
          // setting a boolean content attribute,
          // since its presence should be enough
          // https://bugs.jquery.com/ticket/12359
          docElem.appendChild(el).innerHTML = '<a id=\'' + expando + '\'></a>' + '<select id=\'' + expando + '-\r\\\' msallowcapture=\'\'>' + '<option selected=\'\'></option></select>';
          // Support: IE8, Opera 11-12.16
          // Nothing should be selected when empty strings follow ^= or $= or *=
          // The test attribute must be unknown in Opera but "safe" for WinRT
          // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
          if (el.querySelectorAll('[msallowcapture^=\'\']').length) {
            rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
          }
          // Support: IE8
          // Boolean attributes and "value" are not treated correctly
          if (!el.querySelectorAll('[selected]').length) {
            rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
          }
          // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
          if (!el.querySelectorAll('[id~=' + expando + '-]').length) {
            rbuggyQSA.push('~=');
          }
          // Webkit/Opera - :checked should return selected option elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          // IE8 throws error here and will not see later tests
          if (!el.querySelectorAll(':checked').length) {
            rbuggyQSA.push(':checked');
          }
          // Support: Safari 8+, iOS 8+
          // https://bugs.webkit.org/show_bug.cgi?id=136851
          // In-page `selector#id sibling-combinator selector` fails
          if (!el.querySelectorAll('a#' + expando + '+*').length) {
            rbuggyQSA.push('.#.+[+~]');
          }
        });
        assert(function (el) {
          el.innerHTML = '<a href=\'\' disabled=\'disabled\'></a>' + '<select disabled=\'disabled\'><option/></select>';
          // Support: Windows 8 Native Apps
          // The type and name attributes are restricted during .innerHTML assignment
          var input = document.createElement('input');
          input.setAttribute('type', 'hidden');
          el.appendChild(input).setAttribute('name', 'D');
          // Support: IE8
          // Enforce case-sensitivity of name attribute
          if (el.querySelectorAll('[name=d]').length) {
            rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');
          }
          // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
          // IE8 throws error here and will not see later tests
          if (el.querySelectorAll(':enabled').length !== 2) {
            rbuggyQSA.push(':enabled', ':disabled');
          }
          // Support: IE9-11+
          // IE's :disabled selector does not pick up the children of disabled fieldsets
          docElem.appendChild(el).disabled = true;
          if (el.querySelectorAll(':disabled').length !== 2) {
            rbuggyQSA.push(':enabled', ':disabled');
          }
          // Support: Firefox <=3.6 - 5 only
          // Old Firefox doesn't throw on a badly-escaped identifier.
          el.querySelectorAll('\\\f');
          rbuggyQSA.push('[\\r\\n\\f]');
          // Support: Opera 10 - 11 only
          // Opera 10-11 does not throw on post-comma invalid pseudos
          el.querySelectorAll('*,:x');
          rbuggyQSA.push(',.*:');
        });
      }
      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert(function (el) {
          // Check to see if it's possible to do matchesSelector
          // on a disconnected node (IE 9)
          support.disconnectedMatch = matches.call(el, '*');
          // This should fail with an exception
          // Gecko does not error, returns false instead
          matches.call(el, '[s!=\'\']:x');
          rbuggyMatches.push('!=', pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
      /* Contains
      ---------------------------------------------------------------------- */
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      // Element contains another
      // Purposefully self-exclusive
      // As in, an element does not contain itself
      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function (a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      /* Sorting
      ---------------------------------------------------------------------- */
      // Document order sorting
      sortOrder = hasCompare ? function (a, b) {
        // Flag for duplicate removal
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        // Sort on method existence if only one input has compareDocumentPosition
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        // Calculate position if both inputs belong to the same document
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
        1;
        // Disconnected nodes
        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
          // Choose the first element that is related to our preferred document
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
            return 1;
          }
          // Maintain original order
          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function (a, b) {
        // Exit early if the nodes are identical
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
        // Parentless nodes are either documents or disconnected
        if (!aup || !bup) {
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          /* eslint-disable eqeqeq */
          return a == document ? -1 : b == document ? 1 : /* eslint-enable eqeqeq */
          aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;  // If the nodes are siblings, we can do a quick check
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        // Otherwise we need full lists of their ancestors for comparison
        cur = a;
        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }
        cur = b;
        while (cur = cur.parentNode) {
          bp.unshift(cur);
        }
        // Walk down the tree looking for a discrepancy
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? // Do a sibling check if the nodes have a common ancestor
        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        /* eslint-disable eqeqeq */
        ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 : /* eslint-enable eqeqeq */
        0;
      };
      return document;
    };
    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function (elem, expr) {
      setDocument(elem);
      if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + ' '] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          // IE 9's matchesSelector returns false on disconnected nodes
          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
            // fragment in IE 9
            elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {
          nonnativeSelectorCache(expr, true);
        }
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function (context, elem) {
      // Set document vars if needed
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if ((context.ownerDocument || context) != document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function (elem, name) {
      // Set document vars if needed
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if ((elem.ownerDocument || elem) != document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()],
        // Don't get fooled by Object.prototype properties (jQuery #13807)
        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };
    Sizzle.escape = function (sel) {
      return (sel + '').replace(rcssescape, fcssescape);
    };
    Sizzle.error = function (msg) {
      throw new Error('Syntax error, unrecognized expression: ' + msg);
    };
    /**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */
    Sizzle.uniqueSort = function (results) {
      var elem, duplicates = [], j = 0, i = 0;
      // Unless we *know* we can detect duplicates, assume their presence
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      // Clear input after sorting to release objects
      // See https://github.com/jquery/sizzle/pull/225
      sortInput = null;
      return results;
    };
    /**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */
    getText = Sizzle.getText = function (elem) {
      var node, ret = '', i = 0, nodeType = elem.nodeType;
      if (!nodeType) {
        // If no nodeType, this is expected to be an array
        while (node = elem[i++]) {
          // Do not traverse comment nodes
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (jQuery #11153)
        if (typeof elem.textContent === 'string') {
          return elem.textContent;
        } else {
          // Traverse its children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      // Do not include comment or processing instruction nodes
      return ret;
    };
    Expr = Sizzle.selectors = {
      // Can be adjusted by the user
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        '>': {
          dir: 'parentNode',
          first: true
        },
        ' ': { dir: 'parentNode' },
        '+': {
          dir: 'previousSibling',
          first: true
        },
        '~': { dir: 'previousSibling' }
      },
      preFilter: {
        'ATTR': function (match) {
          match[1] = match[1].replace(runescape, funescape);
          // Move the given value to match[3] whether quoted or unquoted
          match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);
          if (match[2] === '~=') {
            match[3] = ' ' + match[3] + ' ';
          }
          return match.slice(0, 4);
        },
        'CHILD': function (match) {
          /* matches from matchExpr["CHILD"]
              1 type (only|nth|...)
              2 what (child|of-type)
              3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
              4 xn-component of xn+y argument ([+-]?\d*n|)
              5 sign of xn-component
              6 x of xn-component
              7 sign of y-component
              8 y of y-component
          */
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === 'nth') {
            // nth-* requires argument
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            // numeric x and y parameters for Expr.filter.CHILD
            // remember that false/true cast respectively to 0/1
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
            match[5] = +(match[7] + match[8] || match[3] === 'odd');  // other types prohibit arguments
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        'PSEUDO': function (match) {
          var excess, unquoted = !match[6] && match[2];
          if (matchExpr['CHILD'].test(match[0])) {
            return null;
          }
          // Accept quoted arguments as-is
          if (match[3]) {
            match[2] = match[4] || match[5] || '';  // Strip excess characters from unquoted arguments
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
            // excess is a negative index
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          // Return only captures needed by the pseudo filter method (type and argument)
          return match.slice(0, 3);
        }
      },
      filter: {
        'TAG': function (nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === '*' ? function () {
            return true;
          } : function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        'CLASS': function (className) {
          var pattern = classCache[className + ' '];
          return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
            return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== 'undefined' && elem.getAttribute('class') || '');
          });
        },
        'ATTR': function (name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === '!=';
            }
            if (!operator) {
              return true;
            }
            result += '';
            /* eslint-disable max-len */
            return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;  /* eslint-enable max-len */
          };
        },
        'CHILD': function (type, what, _argument, first, last) {
          var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
          function (elem) {
            return !!elem.parentNode;
          } : function (elem, _context, xml) {
            var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
            if (parent) {
              // :(first|last|only)-(child|of-type)
              if (simple) {
                while (dir) {
                  node = elem;
                  while (node = node[dir]) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  // Reverse direction for :only-* (if we haven't yet done so)
                  start = dir = type === 'only' && !start && 'nextSibling';
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              // non-xml :nth-child(...) stores cache data on `parent`
              if (forward && useCache) {
                // Seek `elem` from a previously-cached index
                // ...in a gzip-friendly way
                node = parent;
                outerCache = node[expando] || (node[expando] = {});
                // Support: IE <9 only
                // Defend against cloned attroperties (jQuery gh-1709)
                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  // When found, cache indexes on `parent` and break
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [
                      dirruns,
                      nodeIndex,
                      diff
                    ];
                    break;
                  }
                }
              } else {
                // Use previously-cached element index if available
                if (useCache) {
                  // ...in a gzip-friendly way
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {});
                  // Support: IE <9 only
                  // Defend against cloned attroperties (jQuery gh-1709)
                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                }
                // xml :nth-child(...)
                // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                if (diff === false) {
                  // Use the same loop as above to seek `elem` from the start
                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      // Cache the index of each encountered element
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {});
                        // Support: IE <9 only
                        // Defend against cloned attroperties (jQuery gh-1709)
                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [
                          dirruns,
                          diff
                        ];
                      }
                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              }
              // Incorporate the offset, then check against cycle size
              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        'PSEUDO': function (pseudo, argument) {
          // pseudo-class names are case-insensitive
          // http://www.w3.org/TR/selectors/#pseudo-classes
          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
          // Remember that setFilters inherits from pseudos
          var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
          // The user may use createPseudo to indicate that
          // arguments are needed to create the filter function
          // just as Sizzle does
          if (fn[expando]) {
            return fn(argument);
          }
          // But maintain support for old signatures
          if (fn.length > 1) {
            args = [
              pseudo,
              pseudo,
              '',
              argument
            ];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx, matched = fn(seed, argument), i = matched.length;
              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        // Potentially complex pseudos
        'not': markFunction(function (selector) {
          // Trim the selector passed to compile
          // to avoid treating leading and trailing
          // spaces as combinators
          var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
          return matcher[expando] ? markFunction(function (seed, matches, _context, xml) {
            var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
            // Match elements unmatched by `matcher`
            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, _context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            // Don't keep the element (issue #299)
            input[0] = null;
            return !results.pop();
          };
        }),
        'has': markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        'contains': markFunction(function (text) {
          text = text.replace(runescape, funescape);
          return function (elem) {
            return (elem.textContent || getText(elem)).indexOf(text) > -1;
          };
        }),
        // "Whether an element is represented by a :lang() selector
        // is based solely on the element's language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by "-".
        // The matching of C against the element's language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name."
        // http://www.w3.org/TR/selectors/#lang-pseudo
        'lang': markFunction(function (lang) {
          // lang value must be a valid identifier
          if (!ridentifier.test(lang || '')) {
            Sizzle.error('unsupported lang: ' + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;
            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        // Miscellaneous
        'target': function (elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        'root': function (elem) {
          return elem === docElem;
        },
        'focus': function (elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        // Boolean properties
        'enabled': createDisabledPseudo(false),
        'disabled': createDisabledPseudo(true),
        'checked': function (elem) {
          // In CSS3, :checked should return both checked and selected elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
        },
        'selected': function (elem) {
          // Accessing this property makes selected-by-default
          // options in Safari work properly
          if (elem.parentNode) {
            // eslint-disable-next-line no-unused-expressions
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        // Contents
        'empty': function (elem) {
          // http://www.w3.org/TR/selectors/#empty-pseudo
          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
          //   but not by others (comment: 8; processing instruction: 7; etc.)
          // nodeType < 6 works because attributes (2) do not appear as children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        'parent': function (elem) {
          return !Expr.pseudos['empty'](elem);
        },
        // Element/input types
        'header': function (elem) {
          return rheader.test(elem.nodeName);
        },
        'input': function (elem) {
          return rinputs.test(elem.nodeName);
        },
        'button': function (elem) {
          var name = elem.nodeName.toLowerCase();
          return name === 'input' && elem.type === 'button' || name === 'button';
        },
        'text': function (elem) {
          var attr;
          return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
        },
        // Position-in-collection
        'first': createPositionalPseudo(function () {
          return [0];
        }),
        'last': createPositionalPseudo(function (_matchIndexes, length) {
          return [length - 1];
        }),
        'even': createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'odd': createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument > length ? length : argument;
          for (; --i >= 0;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    //Expr.pseudos["nth"] = Expr.pseudos["eq"];
    // Add button/input type pseudos
    for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
      }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
        submit: true,
        reset: true
      }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    // Easy API for creating new setFilters
    function setFilters() {
    }
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle.tokenize = function (selector, parseOnly) {
      var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        // Comma and first run
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            // Don't consume trailing commas as valid
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push(tokens = []);
        }
        matched = false;
        // Combinators
        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            // Cast descendant combinators to space
            type: match[0].replace(rtrim, ' ')
          });
          soFar = soFar.slice(matched.length);
        }
        // Filters
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      // Return the length of the invalid excess
      // if we're just parsing
      // Otherwise, throw an error or return tokens
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
      tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0, len = tokens.length, selector = '';
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === 'parentNode', doneName = done++;
      return combinator.first ? // Check against closest ancestor/preceding element
      function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
        return false;
      } : // Check against all ancestor/preceding elements
      function (elem, context, xml) {
        var oldCache, uniqueCache, outerCache, newCache = [
            dirruns,
            doneName
          ];
        // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              // Support: IE <9 only
              // Defend against cloned attroperties (jQuery gh-1709)
              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
              if (skip && skip === elem.nodeName.toLowerCase()) {
                elem = elem[dir] || elem;
              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                // Assign to newCache so results back-propagate to previous elements
                return newCache[2] = oldCache[2];
              } else {
                // Reuse newcache so results back-propagate to previous elements
                uniqueCache[key] = newCache;
                // A match means we're done; a fail means we have to keep checking
                if (newCache[2] = matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0, len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function (seed, results, context, xml) {
        var temp, i, elem, preMap = [], postMap = [], preexisting = results.length,
          // Get initial elements from seed or context
          elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []),
          // Prefilter to get matcher input, preserving a map for seed-results synchronization
          matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
          postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
          [] : // ...otherwise use results directly
          results : matcherIn;
        // Find primary matches
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        // Apply postFilter
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          // Un-match failing elements by moving them back to matcherIn
          i = temp.length;
          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              // Get the final matcherOut by condensing this intermediate into postFinder contexts
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if (elem = matcherOut[i]) {
                  // Restore matcherIn since elem is not yet a final match
                  temp.push(matcherIn[i] = elem);
                }
              }
              postFinder(null, matcherOut = [], temp, xml);
            }
            // Move matched elements from seed to results to keep them synchronized
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }  // Add elements to results, through postFinder if defined
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0,
        // The foundational matcher ensures that elements are reachable from top-level context(s)
        matchContext = addCombinator(function (elem) {
          return elem === checkContext;
        }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
          return indexOf(checkContext, elem) > -1;
        }, implicitRelative, true), matchers = [function (elem, context, xml) {
            var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            // Avoid hanging onto element (issue #299)
            checkContext = null;
            return ret;
          }];
      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          // Return special upon seeing a positional matcher
          if (matcher[expando]) {
            // Find the next relative operator (if any) for proper handling
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(// If the preceding token was a descendant combinator, insert an implicit any-element `*`
            tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
          var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext,
            // We must always have either seed elements or outermost context
            elems = seed || byElement && Expr.find['TAG']('*', outermost),
            // Use integer dirruns iff this is the outermost matcher
            dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
          if (outermost) {
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            outermostContext = context == document || context || outermost;
          }
          // Add elements passing elementMatchers directly to results
          // Support: IE<9, Safari
          // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
          for (; i !== len && (elem = elems[i]) != null; i++) {
            if (byElement && elem) {
              j = 0;
              // Support: IE 11+, Edge 17 - 18+
              // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
              // two documents; shallow comparisons work.
              // eslint-disable-next-line eqeqeq
              if (!context && elem.ownerDocument != document) {
                setDocument(elem);
                xml = !documentIsHTML;
              }
              while (matcher = elementMatchers[j++]) {
                if (matcher(elem, context || document, xml)) {
                  results.push(elem);
                  break;
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
              }
            }
            // Track unmatched elements for set filters
            if (bySet) {
              // They will have gone through all possible matchers
              if (elem = !matcher && elem) {
                matchedCount--;
              }
              // Lengthen the array for every element, matched or not
              if (seed) {
                unmatched.push(elem);
              }
            }
          }
          // `i` is now the count of elements visited above, and adding it to `matchedCount`
          // makes the latter nonnegative.
          matchedCount += i;
          // Apply set filters to unmatched elements
          // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
          // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
          // no element matchers and no seed.
          // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
          // case, which will result in a "00" `matchedCount` that differs from `i` but is also
          // numerically zero.
          if (bySet && i !== matchedCount) {
            j = 0;
            while (matcher = setMatchers[j++]) {
              matcher(unmatched, setMatched, context, xml);
            }
            if (seed) {
              // Reintegrate element matches to eliminate the need for sorting
              if (matchedCount > 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              }
              // Discard index placeholder values to get only actual matches
              setMatched = condense(setMatched);
            }
            // Add matches to results
            push.apply(results, setMatched);
            // Seedless set matches succeeding multiple successful matchers stipulate sorting
            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              Sizzle.uniqueSort(results);
            }
          }
          // Override manipulation of globals by nested matchers
          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }
          return unmatched;
        };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function (selector, match) {
      var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
      if (!cached) {
        // Generate a function of recursive functions that can be used to check each element
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        // Cache the compiled function
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        // Save selector and tokenization
        cached.selector = selector;
      }
      return cached;
    };
    /**
     * A low-level selection function that works with Sizzle's compiled
     *  selector functions
     * @param {String|Function} selector A selector or a pre-compiled
     *  selector function built with Sizzle.compile
     * @param {Element} context
     * @param {Array} [results]
     * @param {Array} [seed] A set of elements to match against
     */
    select = Sizzle.select = function (selector, context, results, seed) {
      var i, tokens, token, type, find, compiled = typeof selector === 'function' && selector, match = !seed && tokenize(selector = compiled.selector || selector);
      results = results || [];
      // Try to minimize operations if there is only one selector in the list and no seed
      // (the latter of which guarantees us context)
      if (match.length === 1) {
        // Reduce context if the leading compound selector is an ID
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;  // Precompiled matchers will still verify ancestry, so step up a level
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        // Fetch a seed set for right-to-left matching
        i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          // Abort if we hit a combinator
          if (Expr.relative[type = token.type]) {
            break;
          }
          if (find = Expr.find[type]) {
            // Search, expanding context for leading sibling combinators
            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
              // If seed is empty or no tokens remain, we can return early
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      // Compile and execute a filtering function if one is not provided
      // Provide `match` to avoid retokenization if we modified the selector above
      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    };
    // One-time assignments
    // Sort stability
    support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
    // Support: Chrome 14-35+
    // Always assume duplicates if they aren't passed to the comparison function
    support.detectDuplicates = !!hasDuplicate;
    // Initialize against the default document
    setDocument();
    // The document can be missing during requirejs.optimize()
    if (!document) {
      console.log('Document could not be found when initializing sizzle.');
      return Sizzle;
    }
    // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    // Detached nodes confoundingly follow *each other*
    support.sortDetached = assert(function (el) {
      // Should return 1, but returns 4 (following)
      return el.compareDocumentPosition(document.createElement('fieldset')) & 1;
    });
    // Support: IE<8
    // Prevent attribute/property "interpolation"
    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
    if (!assert(function (el) {
        el.innerHTML = '<a href=\'#\'></a>';
        return el.firstChild.getAttribute('href') === '#';
      })) {
      addHandle('type|href|height|width', function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
        }
      });
    }
    // Support: IE<9
    // Use defaultValue in place of getAttribute("value")
    if (!support.attributes || !assert(function (el) {
        el.innerHTML = '<input/>';
        el.firstChild.setAttribute('value', '');
        return el.firstChild.getAttribute('value') === '';
      })) {
      addHandle('value', function (elem, _name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === 'input') {
          return elem.defaultValue;
        }
      });
    }
    // Support: IE<9
    // Use getAttributeNode to fetch booleans when getAttribute lies
    if (!assert(function (el) {
        return el.getAttribute('disabled') == null;
      })) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;
        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }
    return Sizzle;
  }(typeof window != 'undefined' ? window : this);
  synchronite__base_query = function (queryEngine, baseArray, strings) {
    // NOTE: We should use native css3 queries wherever possible because nth-of-type
    // is buggy in IE8+. It seems that acme does not correctly support nth-of-type.
    //
    // WARN: AFTER DOJO UPDATE TO 1.9 WE NEED TO PATCH IN LITE.JS (Otherwise simple id queries fail)
    // var found = dojo.byId ? dojo.byId(match[2], doc) : doc.getElementById(match[2]);
    // str2array taken from dojo/dom-class.js
    var spaces = /\s+/, a1 = [''];
    var str2array = function (s) {
      if (typeof s === 'string' || s instanceof String) {
        if (s && !spaces.test(s)) {
          a1[0] = s;
          return a1;
        }
        var a = s.split(spaces);
        if (a.length && !a[0]) {
          a.shift();
        }
        if (a.length && !a[a.length - 1]) {
          a.pop();
        }
        return a;
      }
      // assumed to be an array
      if (!s) {
        return [];
      }
      return baseArray.filter(s, function (x) {
        return x;
      });
    };
    var _contains = function (arr, item) {
      return baseArray.indexOf(arr, item) >= 0;
    };
    var ignoreIds = synchroniteConfig.ignoreIds;
    var useClasses = synchroniteConfig.useClasses;
    var strClass = 'class';
    var _useClass = function (node) {
      // returns: classname that can be used in a selector or false
      // WARN: There seems to be no way of determining classes that have been present
      //       in the original markup. If there was we could further optimize the code
      //       below to detect behavioral html classes (such as .hover) and avoid using
      //       these in css selectors.
      //
      //       -> see testcase: http://jsfiddle.net/UdgrL/1/
      var htmlAttrClassesStr, htmlAttrClasses, l, i;
      if (typeof node.getAttribute === 'undefined') {
        return;
      }
      // Get array of classes  or quit if there are no classes assigned to node
      htmlAttrClassesStr = node.getAttribute(strClass);
      if (htmlAttrClassesStr) {
        htmlAttrClasses = str2array(htmlAttrClassesStr);
      } else {
        return;
      }
      if (useClasses && useClasses.length > 0) {
        //var useHeuristic = (useClasses[0] === "*");
        // Check if we found any classnames, that we know from configuration are safe to
        // be used. e.g. classnames that do not change on MouseEvents such as hover,
        // mouseover or node activation (click)
        l = useClasses.length;
        for (i = 0; i < l; i++) {
          if (_contains(htmlAttrClasses, useClasses[i])) {
            return useClasses[i];
          }
        }
      }
      // Use heuristic approach to determine classnames that can be used.
      l = htmlAttrClasses.length;
      var cls;
      for (i = 0; i < l; i++) {
        cls = htmlAttrClasses[i];
        // selected (results-select2) needed for https://www.sparkasse-musterstadt.de/privatkunden/bauen_wohnen/index.php?n=/privatkunden/bauen_wohnen/
        if (!/hover|focus|active|selected|highlight|over/i.test(cls)) {
          return cls;
        }
      }
      return false;
    };
    var _idIsUnique = function (parent, doc) {
      var id = escapeQuery(parent.id);
      var list = queryEngine('#' + id, doc);
      return list.length === 1 && list[0] === parent;
    };
    var _canUseId = function (node) {
      if (node && node.id && typeof node.id === 'string') {
        if (ignoreIds && ignoreIds.length > 0 && baseArray.indexOf(ignoreIds, node.id) >= 0) {
          return false;
        }
        if (/hover|focus|active|selected|highlight|over|\r\n|\n|\r/i.test(node.id)) {
          return false;
        }
        if (typeof synchroniteConfig != 'undefined' && synchroniteConfig.detectRandomIds) {
          if (/([\d]{4,})/i.test(node.id)) {
            return false;
          }
        }
        return node.id;
      }
      return false;
    };
    //////////////////////////////////////////
    // PRIVATE FUNCTIONS AND VARIABLES
    //////////////////////////////////////////
    var getText = function (elem) {
        //Get text content of node
        var i, node, nodeType = elem.nodeType, ret = '', rReturn = /\r\n/g;
        if (nodeType) {
          if (nodeType === 1) {
            // Use textContent || innerText for elements
            if (typeof elem.textContent === 'string') {
              return elem.textContent;
            } else if (typeof elem.innerText === 'string') {
              // Replace IE's carriage returns
              return elem.innerText.replace(rReturn, '');
            } else {
              // Traverse it's children
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                ret += getText(elem);
              }
            }
          } else if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
        } else {
          // If no nodeType, this is expected to be an array
          for (i = 0; i < elem[i].length; i++) {
            // Do not traverse comment nodes
            node = elem[i];
            if (node.nodeType !== 8) {
              ret += getText(node);
            }
          }
        }
        return ret;
      }, isUnique = function (part, selector, root) {
        return queryEngine(_selectorSoFar(part, selector), root).length === 1;
      }, synchronizedFrameId = strings.SYNCHRONIZED_WINDOW, synchronizedWindow = function () {
        // WARNING:
        // When using window.frames["name"]:
        //  - Chrome returns the iframe element
        //  - Firefox returns the window object
        // window.frames[strings.SYNCHRONIZED_WINDOW] only works in FF, when the synchronized page does
        // not set a window.name itself. This is the case for cosmosdirekt
        // (window.name="cosmos") so the main frame is not found.
        //
        // --> To avoid this problem we search for the iframe element in the main document
        //     instead.
        //                if (foundWindow) {
        //                    return foundWindow;
        //                }
        var foundWindow;
        try {
          foundWindow = findWindowByFrameName(window, synchronizedFrameId, true);
        } catch (e) {
          console.warn('Unable to get displayContent frame. Trying different method.');
        }
        if (!foundWindow) {
          var iframes = queryEngine('#' + synchronizedFrameId, document);
          if (iframes.length > 0) {
            foundWindow = iframes[0].contentWindow;
            console.warn('Returning window, but may be inaccessible.');
          }
        }
        return foundWindow || window;
      }, nthOfType = function (node) {
        var tagName = node.tagName;
        // the value of n is "1-indexed", meaning that the counting starts at 1
        var count = 1;
        if (tagName) {
          for (var sib = node.previousSibling; sib; sib = sib.previousSibling) {
            // get nth child
            if (sib.nodeType === 1 && sib.tagName === tagName) {
              // nodeyType == 1 => Elementknoten
              count++;
            }
          }
        }
        return count;
      }, _getFrameSelector = function (frame) {
        var frameSelector = null;
        if (frame) {
          if (frame.name) {
            frameSelector = frame.tagName.toLowerCase() + '[name=\'' + frame.name + '\']';
          } else if (frame.id) {
            frameSelector = frame.tagName.toLowerCase() + '#' + escapeQuery(frame.id);
          } else {
            frameSelector = identifyByRelatedNodes(frame);  //"frameset:nth-child(" + 0 + ")"; //frame
          }
        }
        return frameSelector;
      }, escapeQuery = function (s) {
        if (typeof s === 'string' && /(:|\w\.|~|\+| |\[|\]|\$|\/|@|\||\(|\)|{|}|%|=|&|;|#)/gi.test(s)) {
          // no need to escape ~ in dojo 1.7.1 with acme selector engine
          // USE IN FUTURE: https://github.com/mathiasbynens/cssesc
          //
          // FIXED: dojoQuery confuses colons in ids with pseudo
          // selectors, so they need to be escaped.
          // http://bugs.dojotoolkit.org/changeset/11210/dojo
          // FIXED: We need to escape spaces, too. (found on sparkasse-koelnbonn.de)
          //        see: http://stackoverflow.com/questions/596314/jquery-ids-with-spaces
          // FIXED: We need to escape square brackets, too (found in oxid demo shop)
          s = s.replace(/(:|\.|~|\+| |\[|\]|\$|\/|@|\||\(|\)|{|}|%|=|&|;|#)/gi, function ($0, character, idx) {
            // special case for # or . check if there is a character before a dot or #. If not, don't escape
            if (character === '.' && (idx === 0 || /\s/i.test(s.charAt(idx - 1)))) {
              return character;
            }
            if (character === '#' && (idx === 0 || /\s/i.test(s.charAt(idx - 1)))) {
              return character;
            }
            return '\\' + character;
          });
        }
        return s;
      }, _addPart = function (part, selector) {
        if (selector.length > 0) {
          selector.unshift(' > ');
        }
        selector.unshift(part.join(''));
      }, _selectorSoFar = function (part, selector) {
        var completeSelector = part.join('');
        if (selector.length > 0) {
          completeSelector += ' > ' + selector.join('');
        }
        return completeSelector;
      }, identifyByRelatedNodes = function (el, ctx) {
        var nth;
        var selector = [];
        var part = [];
        var list, eq;
        var nodeName;
        var id;
        var valAttr;
        var checkIfUnique;
        var doc = ctx || el.ownerDocument;
        //    win = doc.parentWindow || doc.defaultView;
        //var sid;
        var parent = el;
        while (parent && !isShadowRoot(parent)) {
          part = [];
          nodeName = parent.nodeName.toLowerCase();
          checkIfUnique = false;
          if (_canUseId(parent) && _idIsUnique(parent, doc)) {
            // This did not work with selectorEngine=acme and dojoQuery("#QR~QID651~4", frameDoc);
            // FIXED: http://bugs.dojotoolkit.org/ticket/15319
            id = escapeQuery(parent.id);
            list = queryEngine('#' + id, doc);
            if (list.length === 1 && list[0] === parent) {
              part.push('#' + id);
            }
            return _selectorSoFar(part, selector);
          } else if (/^(html|head|body|document|#document)$/i.test(nodeName)) {
            // there can only be one of these tags, so do not use id
            // or name, as those might vary (home of the brave)
            part.push(nodeName);
            // end when top of document is reached
            return _selectorSoFar(part, selector);
          } else if (nodeName.indexOf(':') !== -1) {
            //miele isa:content
            return _selectorSoFar(part, selector);
          } else if (parent.name && parent.getAttribute('name')) {
            // FIXED: We must use getAttribute, because a form with a child carrying
            //        a name="name" attribute will result in getting the child object
            //        instead of the forms name property.
            // if name is unique then use name as identifier since generated ids might
            // be different in same page (see SAP SYCOR B2B Webshop)
            part.push(nodeName);
            part.push('[name=\'' + parent.getAttribute('name') + '\']');
            if (parent.type && /checkbox|radio/i.test(parent.type)) {
              if (isUnique(part, selector, doc)) {
                return _selectorSoFar(part, selector);
              } else {
                //FIXED: only get the real attribute of the tag.
                //       properties can't be used for queries.
                valAttr = parent.getAttribute && parent.getAttribute('value');
                if (valAttr) {
                  part.push('[value=\'' + valAttr + '\']');
                }
              }
            }
            checkIfUnique = true;
          } else if (nodeName === 'option') {
            // option tags be uniquely identified as children of
            // a select node by their value
            part.push(nodeName);
            //FIXED: only get the real attribute of the tag.
            //       properties can't be used for queries.
            valAttr = parent.getAttribute && parent.getAttribute('value');
            if (valAttr) {
              part.push('[value=\'' + valAttr + '\']');
            } else {
              // needed for: <select><option>A</option><option>B</option><option>C</option></select>
              nth = nthOfType(parent);
              // also add if nth==1, because there might be more children of type
              part.push(':nth-of-type(' + nth + ')');
            }
            checkIfUnique = true;
          } else if (nodeName === 'label' && parent.getAttribute('for')) {
            part.push(nodeName);
            part.push('[for=\'' + parent.getAttribute('for') + '\']');
            checkIfUnique = true;
          } else if (nodeName === 'optgroup') {
            part.push(nodeName);
            if (parent.label) {
              part.push('[label=\'' + parent.label + '\']');
            }
            // Assume unique
            return _selectorSoFar(part, selector);  //} else if (nodeName === "img" && parent.src) {
                                                    //    // use img src if unique
                                                    //    // FIXED: Must get the actual attribute not the resolved img.src property
                                                    //    // FIXME: Maybe we should escape the srcAttribute
                                                    //    part.push(nodeName);
                                                    //
                                                    //    var srcAttribute = parent.getAttribute("src");
                                                    //    part.push("[src='" + escapeQuery(srcAttribute) + "']");
                                                    //
                                                    //    checkIfUnique = true;
          } else if (nodeName === 'a' && (parent.title || parent.rel)) {
            // use anchor title if unique
            part.push(nodeName);
            if (parent.title) {
              part.push('[title=\'' + parent.title + '\']');
            }
            if (parent.rel) {
              part.push('[rel=\'' + parent.rel + '\']');
            }
            checkIfUnique = true;
          } else {
            part.push(nodeName);
            var clsName = _useClass(parent);
            if (clsName) {
              part.push('.' + clsName);
              // Optimization: Also check before calculating nth-child.
              if (isUnique(part, selector, doc)) {
                return _selectorSoFar(part, selector);
              }
              checkIfUnique = true;
            }
            nth = nthOfType(parent);
            // also add if nth==1, because there might be more children of type
            part.push(':nth-of-type(' + nth + ')');
          }
          if (selector.length > 4) {
            // optimization test
            checkIfUnique = true;
          }
          if (checkIfUnique && isUnique(part, selector, doc) || parent.parentNode && isShadowRoot(parent.parentNode)) {
            return _selectorSoFar(part, selector);
          } else {
            _addPart(part, selector);
          }
          parent = parent.parentNode;
        }
        //}
        return selector;
      }, findWindowByFrameName = function (startWindow, frameName, noDeepSearch) {
        // summary: This method searches for a frame inside startWindow that is specified
        //          by the given name.
        //
        // description: This method traveres the window.frames array by numbers which is more
        //              reliable than using direct name access. As the name of the frame will
        //              not be found, when the corresponding window.name is changed.
        // noDeepSearch: Search on startWindow level only and do not go deeper into each sub frame.
        if (startWindow.name === frameName) {
          return startWindow;
        }
        var tempFrame;
        var windowFrames = startWindow.frames;
        var frameOrWindow;
        var frame, win;
        //Start searching for the specified frame
        for (var i = 0; i < windowFrames.length; i++) {
          try {
            // Get frame and window objects
            // WARNING:
            // When using window.frames["name"]:
            //  - Chrome returns the iframe element
            //  - Firefox returns the window object
            frameOrWindow = windowFrames[i];
            if (frameOrWindow.contentWindow) {
              frame = frameOrWindow;
              win = frameOrWindow.contentWindow;
            } else {
              frame = frameOrWindow.frameElement;
              win = frameOrWindow;
            }
            if (win.name === frameName || frame && frame.name === frameName) {
              return win;
            } else if (!noDeepSearch) {
              tempFrame = findWindowByFrameName(win, frameName);
              if (tempFrame) {
                return tempFrame;
              }
            }
          } catch (e) {
            if (frameName != 'displayContent') {
              console.warn('Frame not accessible.');
            }
          }
        }
        //If we get here then no frame was found...
        return null;
      };
    var closestAttr = function (node, attr) {
      while (node && node.nodeType === 1) {
        if (node.getAttribute(attr)) {
          return node;
        } else {
          node = node.parentNode;
        }
      }
      return false;
    };
    var closestProp = function (node, attr) {
      while (node && node.nodeType === 1) {
        if (node[attr]) {
          // changed from attribute
          return node;
        } else {
          node = node.parentNode;
        }
      }
      return false;
    };
    var isShadowRoot = function (node) {
      return node.toString() === '[object ShadowRoot]';
    };
    ///////////////////////////////////////////
    // PUBLIC METHODS AND PROPERTIES
    ///////////////////////////////////////////
    var synchQuery = {
      closestAttr: closestAttr,
      closestEventMonitor: function (node, type) {
        var monitorId;
        if (/click|mousedown|mouseup/i.test(type)) {
          monitorId = strings.PROP_CLICK_MONITORED;
        } else if (/keydown|keypress/i.test(type)) {
          monitorId = strings.PROP_KEY_MONITORED;
        } else if (/change/.test(type)) {
          monitorId = strings.PROP_CHANGE_MONITORED;
        } else {
          return false;
        }
        return closestProp(node, monitorId);
      },
      synchronizedWindow: synchronizedWindow,
      closestParent: function (node, selector, deep) {
        //		Returns closest parent that matches query, including current node in this
        //		dojo/NodeList if it matches the query.
        var cur;
        do {
          for (cur = node; cur; cur = cur.parentNode) {
            if (// Don't pass non-elements to Sizzle
              cur.nodeType === 1 && queryEngine.matchesSelector(cur, selector)) {
              return cur;
            }
          }
          if (deep) {
            var nodeDoc = node.ownerDocument || node;
            var win = nodeDoc.defaultView || nodeDoc.parentWindow;
            if (win.frameElement) {
              node = win.frameElement;
            } else {
              return null;
            }
          }
        } while (deep);
        return null;
      },
      getWindowFromFrameName: function (frameName) {
        var win;
        // undefined frameName
        if (!frameName || frameName === 'undefined') {
          return synchronizedWindow();
        }
        // 0. Case: Close a popup that is open in the main window
        if (frameName === 'presenterWindow') {
          return window;
        }
        // 1. Case: Search for synchronization frame in main window (synchronizedWindow()).
        if (frameName === strings.SYNCHRONIZED_WINDOW) {
          return synchronizedWindow();
        }
        // 2. Case: Search for first level sub windows/frames of displayContent
        win = findWindowByFrameName(synchronizedWindow(), frameName, true);
        if (win) {
          return win;
        }
        // 3. Case: Subframe in popup window
        win = findWindowByFrameName(window, frameName, true);
        if (win) {
          return win;
        }
        // 4. Case: Locate nested subframe and search deep in all sub frames
        return findWindowByFrameName(synchronizedWindow(), frameName);
      },
      getTargetWindowName: function (node) {
        // Warning: formTag.action fails to retrieve the attribute when the form has an input
        //          child node with name='target'
        var targetName = node.getAttribute('target');
        if (!targetName) {
          var sourceDoc = node.ownerDocument;
          var sourceWindow = sourceDoc.defaultView || sourceDoc.parentWindow;
          return synchQuery.getFrameNameFromWindow(sourceWindow);
        }
        if (targetName === '_self' || targetName === '_top' || targetName === '_parent' || targetName === '_blank') {
          var targetFrame = this.getTargetWindow(node);
          return synchQuery.getFrameNameFromWindow(targetFrame);
        } else {
          return targetName;
        }
      },
      getTargetWindow: function (nodeOrTargetString, optionalSourceWin) {
        var targetFrame, sourceWin, sourceDoc;
        if (typeof nodeOrTargetString === 'string') {
          targetFrame = nodeOrTargetString;
          sourceWin = optionalSourceWin;
        } else {
          // Warning: formTag.action fails to retrieve the attribute when the form has an input
          //          child node with name='target'
          targetFrame = nodeOrTargetString.getAttribute('target');
          sourceDoc = nodeOrTargetString.ownerDocument;
          sourceWin = sourceDoc.defaultView || sourceDoc.parentWindow;
        }
        if (!targetFrame) {
          return sourceWin;
        }
        if (targetFrame === '_self') {
          return sourceWin;
        } else if (targetFrame === '_parent' || targetFrame === '_top') {
          //relative target
          var targetWin = sourceWin[targetFrame.substring(1)];
          if (targetWin === synchronizedWindow()) {
            return targetWin;
          } else if (sourceWin === synchronizedWindow()) {
            return sourceWin;
          } else if (targetWin === synchronizedWindow().parent) {
            return sourceWin;
          } else {
            return targetWin;
          }
        } else if (targetFrame === '_blank') {
          return synchronizedWindow();
        } else {
          return synchQuery.getWindowFromFrameName(targetFrame);
        }
      },
      getFrameNameFromWindow: function (frameWin) {
        if (frameWin.name) {
          return frameWin.name.split('|')[0];
        } else if (frameWin.frameElement && frameWin.frameElement.name) {
          return frameWin.frameElement.name;
        } else {
          // Assuming " + frameWin.location.href + " is the synchronized window."
          return strings.SYNCHRONIZED_WINDOW;
        }
      },
      getRelativeIdentifier: function (source, target) {
        if (source === target) {
          return '_self';
        } else if (source.parent === target) {
          return '_parent';
        } else {
          return strings.SYNCHRONIZED_WINDOW;
        }
      },
      getFrameSelector: function (frameWin) {
        var frameSelector = [];
        if (frameWin === synchronizedWindow()) {
          return null;
        }
        var tmpFrameWin = frameWin;
        while (tmpFrameWin && tmpFrameWin !== tmpFrameWin.parent && tmpFrameWin !== synchronizedWindow() && tmpFrameWin !== window) {
          var frame = tmpFrameWin.frameElement;
          frameSelector.push(_getFrameSelector(frame));
          tmpFrameWin = tmpFrameWin.parent;
        }
        if (frameSelector.length > 0) {
          return frameSelector;
        }
        return null;
      },
      getShadowSelector: function (node) {
        var shadowSelector = [];
        for (; node; node = node.parentNode) {
          if (isShadowRoot(node)) {
            shadowSelector.push(identifyByRelatedNodes(node.host));
            node = node.host;
          }
        }
        if (shadowSelector.length > 0) {
          return shadowSelector;
        }
        return null;
      },
      getNodeSelectorFromEvent: function (evt) {
        var target = evt.target;
        if (target.shadow || target.shadowRoot) {
          return synchQuery.getNodeSelector(evt.composedPath()[0]);
        } else {
          return synchQuery.getNodeSelector(target);
        }
      },
      getNodeSelector: function (el) {
        var windowName = null, frameSelector = [], elementSelector = null, frameDoc, frameWin, shadow;
        //First determine target frame
        frameDoc = el.ownerDocument;
        if (!frameDoc) {
          return null;
        }
        frameWin = frameDoc.parentWindow || frameDoc.defaultView;
        // Setting the document now prevents "Permission denied" error in IE9
        queryEngine.setDocument(frameDoc);
        try {
          if (frameWin.name) {
            windowName = frameWin.name.split('|')[0];
          }
          frameSelector = this.getFrameSelector(frameWin);
        } catch (e) {
          console.debug('getCssSelector: Window might have been unloaded already.');
        }
        shadow = this.getShadowSelector(el);
        //Second determine target element
        var nodeName = el.nodeName;
        if (/^(html|head|body|document|#document)$/i.test(nodeName)) {
          // there can only be one of these tags, so do not use id
          // or name, as those might vary (home of the brave)
          elementSelector = nodeName;
        } else if (shadow) {
          elementSelector = identifyByRelatedNodes(el, el.getRootNode());
        } else {
          elementSelector = identifyByRelatedNodes(el);
        }
        //do not include null values to keep network size small
        var selector = {};
        if (elementSelector) {
          selector.element = elementSelector;
        }
        if (frameSelector && frameSelector.length > 0) {
          selector.frame = frameSelector;
        }
        if (windowName) {
          selector.windowName = windowName;
        }
        if (shadow) {
          selector.shadow = shadow;
        }
        return selector;
      },
      /**
       * Returns the window based on frame selector.
       * @param _frameSelector
       * @returns window or undefined
       */
      queryFrame: function (_frameSelector, failOk) {
        var rootWin = synchronizedWindow();
        if (!_frameSelector || _frameSelector === strings.SYNCHRONIZED_WINDOW) {
          return rootWin;
        }
        var changedDoc = false;
        // Setting the document now prevents "Permission denied" error in IE9
        queryEngine.setDocument(rootWin.document);
        var frameSelector = typeof _frameSelector === 'string' ? [_frameSelector] : _frameSelector;
        for (var i = frameSelector.length - 1; i >= 0; i--) {
          var nl = queryEngine(frameSelector[i], rootWin.document);
          //MIELE FIXUP
          if (nl.length === 0) {
            i--;
            if (i > 0) {
              nl = queryEngine(frameSelector[i], rootWin.document);
            }
          }
          if (nl.length === 0) {
            i++;
            if (changedDoc) {
              console.warn('Unable to locate frame: ' + frameSelector[0]);
              if (failOk) {
                return;
              } else {
                break;
              }
              break;
            } else {
              changedDoc = true;
              rootWin = window;
              i++;
              continue;
            }
          }
          rootWin = nl[0].contentWindow;
        }
        return rootWin;
      },
      queryShadowHost: function (_shadowHostSelector, frame) {
        frame = frame || synchronizedWindow();
        var shadowHost = frame;
        var shadowHostSelector = typeof _shadowHostSelector === 'string' ? [_shadowHostSelector] : _shadowHostSelector;
        for (var i = shadowHostSelector.length - 1; i >= 0; i--) {
          var nl = queryEngine(shadowHostSelector[i], shadowHost);
          if (nl.length) {
            shadowHost = nl[0].shadowRoot;
          }
        }
        return shadowHost;
      },
      escapeQuery: escapeQuery,
      isProtected: function (node) {
        return node && (node.type === 'password' || node.getAttribute && (node.getAttribute('data-protected') || node.getAttribute('sync-disabled')));
      },
      getImageForMap: function (mapNode) {
        var img;
        if (mapNode.name) {
          img = queryEngine('img[usemap=#' + mapNode.name + ']', mapNode.ownerDocument);
          if (img.length > 0) {
            return img[0];
          }
        }
        return null;
      },
      queryElement: function (selector) {
        var elementSelector = selector.element;
        var frameSelector = selector.frame;
        var frameName = selector.frameName;
        var windowName = selector.windowName;
        var shadow = selector.shadow;
        var nodeList, frameDoc = null;
        if (frameName) {
          var frame = this.getWindowFromFrameName(frameName);
          frameDoc = frame.document;
        } else if (frameSelector) {
          var frameWin = synchQuery.queryFrame(frameSelector);
          if (frameWin) {
            frameDoc = frameWin.document;
          }
        } else if (windowName) {
          frameDoc = this.getWindowFromFrameName(windowName);
          //window[windowName].document;
          if (frameDoc) {
            frameDoc = frameDoc.document;
          } else {
            console.warn('Unable to find window: ' + windowName + ' using default instead');
            frameDoc = synchronizedWindow().document;
          }
        } else {
          frameDoc = synchronizedWindow().document;
        }
        var shadowRoot;
        if (shadow) {
          shadowRoot = this.queryShadowHost(shadow, frameDoc);
          nodeList = queryEngine(elementSelector, shadowRoot);
        } else {
          nodeList = queryEngine(elementSelector, frameDoc);
        }
        if (nodeList && nodeList.length > 0) {
          if (nodeList.length === 1) {
            // Found
            return nodeList[0];
          }
          // Multiple possible elements
          console.warn('queryElement: Multiple possible elements for ' + elementSelector + ' List: ' + nodeList);
          return nodeList[0];
        }
        console.warn('queryElement: Unable to locate element with selector ' + elementSelector);
        return null;
      }
    };
    return synchQuery;
  }(synchronite_libs_sizzle, dojo__base_array, synchronite_constants_strings);
  synchronite__base_url = function (dojoLang, dojoString, array, DojoUrl, synchQuery, strings) {
    var contextWindow = window;
    var PROXIFICATION_DOT_REPLACEMENT = '---', DATA_MAIL_VOID_URL = /^\s*(\/\/|data|mailto):/i,
      // jshint ignore:line
      DATA_MAIL_VOID_JS_URL = /^\s*(\/\/|data|mailto|javascript):/i, JS_URL = /^\s*javascript:/i,
      // jshint ignore:line
      synchParams = [
        strings.PUBLISH,
        strings.TARGET_FRAME,
        strings.TARGET_PROTOCOL,
        strings.CACHE_KEY
      ], findDotReplacementRegex = new RegExp(PROXIFICATION_DOT_REPLACEMENT, 'ig'), X_FORWARDED_PORT = 'xforwardedport', X_FORWARDED_PROTOCOL = 'xforwardedproto';
    // jshint ignore:line
    ////////////////////////////////////
    // PRIVATE VARIABLES & FUNCTIONS
    ////////////////////////////////////
    var unproxifyHost = function (hostname, protocol) {
      // hostname
      var unproxiedHost = hostname.replace('.' + synchroniteConfig.proxyHost, '');
      // protocol
      if (/https/i.test(protocol)) {
        // also matches "https:"
        findDotReplacementRegex.lastIndex = 0;
        unproxiedHost = unproxiedHost.replace(findDotReplacementRegex, '.');
      }
      return unproxiedHost;
    };
    function isCrossDomainSrc(frame) {
      var srcProperty = frame.src;
      var frameSrc = frame.src;
      if (frameSrc && frameSrc.length && frameSrc.length > 5 && frameSrc.indexOf('http') >= 0) {
        var presenterProtocol;
        try {
          presenterProtocol = contextWindow.location.protocol;
        } catch (e) {
          return true;
        }
        if (frameSrc.indexOf(presenterProtocol) == -1) {
          //http https protocols do not match.
          console.warn('Found xss frame: ' + frame.src);
          return true;
        }
      }
      return !synchUrl.isProxified(srcProperty) || srcProperty === 'about:blank' || srcProperty === '';
    }
    var unproxifyPort = function (proxiedURL) {
      var re = new RegExp(X_FORWARDED_PORT + '-(\\d+)\\.([\\w\\d\\-\\.]+)', 'i');
      // /xforwardedport-(\d+)\.([\w\d\-\.]+)/i
      proxiedURL = proxiedURL.replace(re, '$2:$1');
      return proxiedURL;
    };
    var unproxifyUrl = function (url) {
        var unproxied;
        if (url && url !== 'about:blank') {
          // Added isProxifiedByHost because otherwise ports get lost
          // -> e.g. unproxifyUrl("http://www.example.com:8181/")
          // -> returned "http://www.example.com/"
          if (!isProxifiedByHost(url)) {
            return url;
          }
          var djUrl = new DojoUrl(url.toString());
          // hostname
          var unproxiedHost = unproxifyHost(djUrl.host, djUrl.scheme);
          // port
          unproxiedHost = unproxifyPort(unproxiedHost);
          if (unproxiedHost.split('.').length <= 1 && unproxiedHost.indexOf(PROXIFICATION_DOT_REPLACEMENT) === -1) {
            // Unusual case, where we use synchronite on the synchronite website:
            // test.synchronite.de/present/?targetURL=http://www.synchronite.de
            // maybe also on singleTenant on-premise deployments
            return url;
          }
          unproxied = djUrl.scheme + '://' + unproxiedHost;
          if (djUrl.path) {
            unproxied += djUrl.path;
          }
          if (djUrl.query) {
            unproxied += '?' + djUrl.query;
          }
          unproxied = synchUrl.removeSynchParams(unproxied);
          if (djUrl.fragment) {
            unproxied += '#' + djUrl.fragment;
          }  //console.info("unproxifyUrl: " +  url + " --> " + unproxied);
        }
        return unproxied;
      }, proxifyUrl = function (url, noQuery, context) {
        //summary: Reroutes URLs found in websites to point to synchronite proxy.
        //description: Rewrites "http://www.xample.com/a/b/c?q=test" to
        //  "http://www.example.com.SYNCHRONITE_PROXY_SERVER/a/b/c?q=test"
        if (url) {
          // FIXED: url might be the (proxied) location object.
          url = url.toString();
        }
        if (!isAbsolute(url) && url.indexOf('//') !== 0) {
          // only proxify absolute urls and protocol relative urls e.g. //www.google.de
          return url;
        }
        //url is already proxified
        if (isProxifiedByHost(url)) {
          return url;
        }
        // make sure url is absolute
        url = synchUrl.resolveURL(url, context);
        var djUrl = new DojoUrl(url);
        //case https://search.google.de.synchronite.de
        if (djUrl.scheme === 'https' && djUrl.host.indexOf(synchroniteConfig.proxyHost) !== -1) {
          var newUrl = djUrl.scheme + '://';
          newUrl += djUrl.host.replace('.' + synchroniteConfig.proxyHost, '');
          if (djUrl.path) {
            newUrl += djUrl.path;
          }
          if (djUrl.query) {
            newUrl += '?' + djUrl.query;
          }
          if (djUrl.fragment != null) {
            newUrl += '#' + djUrl.fragment;
          }
          djUrl = new DojoUrl(newUrl);
        }
        var proxifiedUrl = djUrl.host;
        // do not set explicitly if the following standard ports are used:
        // Port  80 - HTTP
        // Port 443 - HTTPS
        if (!(!djUrl.port || djUrl.port == 80 && djUrl.scheme === 'http' || djUrl.port == 443 && djUrl.scheme === 'https')) {
          proxifiedUrl = X_FORWARDED_PORT + '-' + djUrl.port + '.' + proxifiedUrl;
        }
        if (djUrl.scheme === 'https') {
          proxifiedUrl = proxifiedUrl.replace(/\./gi, PROXIFICATION_DOT_REPLACEMENT);
        }
        proxifiedUrl += '.' + synchroniteConfig.proxyHost;
        proxifiedUrl = djUrl.scheme + '://' + proxifiedUrl;
        if (djUrl.path) {
          proxifiedUrl += djUrl.path;
        }
        if (!noQuery) {
          if (djUrl.query) {
            proxifiedUrl += '?' + djUrl.query;
          }
        }
        // The fragment might be an empty string. In that case
        // we still need to set it.
        // e.g. http://www.example.com/#
        if (djUrl.fragment != null) {
          proxifiedUrl += '#' + djUrl.fragment;
        }
        return proxifiedUrl;
      }, isAbsolute = function (href) {
        return /^([a-z]+):\/\//.test(href);
      }, isProxifiedByHost = function (url) {
        // URL might be a location object so we need to stringify first
        var djUrl = new DojoUrl(url.toString());
        var host = djUrl.host;
        var path = djUrl.path;
        var scheme = djUrl.scheme;
        if (!host) {
          // relative url
          return false;
        }
        // returns de.wikipedia.org for de.wikipedia.org
        // returns www for www.synchronite.de
        // return www--example--org for https://www--example--org.synchronite.de
        var unproxiedHost = host.replace('.' + synchroniteConfig.proxyHost, '');
        if (unproxiedHost.split('.').length <= 1 && unproxiedHost.indexOf(PROXIFICATION_DOT_REPLACEMENT) === -1) {
          // www.synchronite.de
          return false;
        }
        if (scheme === 'https' && unproxiedHost.split('.').length > 1 && unproxiedHost.indexOf(PROXIFICATION_DOT_REPLACEMENT) === -1) {
          // return false for something like https://google.de.synchronite.de
          return false;
        }
        return host.indexOf('.' + synchroniteConfig.proxyHost) > 0 || path && path.indexOf('resync') === 0;
      }, dojoUrlToString = function (relobj) {
        var uri = [];
        if (relobj.scheme) {
          uri.push(relobj.scheme, ':');
        }
        if (relobj.authority) {
          uri.push('//', relobj.authority);
        }
        uri.push(relobj.path);
        if (relobj.query) {
          uri.push('?', relobj.query);
        }
        if (relobj.fragment) {
          uri.push('#', relobj.fragment);
        }
        return uri.join('');
      };
    ///////////////////////////////////////////////
    // PUBLIC PROPERTIES & METHODS
    //////////////////////////////////////////////
    var synchUrl = {
      dojoUrlToString: dojoUrlToString,
      unproxifyHost: unproxifyHost,
      isAbsolute: function (url) {
        return isAbsolute(url);
      },
      isProxified: function (url) {
        // summary: Checks if the url is absolute and proxified.
        return isProxifiedByHost(url);
      },
      toSynchroniteURL: function (url, noQuery, context) {
        //e.g. #p0 (jump within site)
        //        if (url.indexOf("#")==0) {
        //            return url;
        //        }
        //do not proxify data urls
        if (DATA_MAIL_VOID_JS_URL.test(url)) {
          return url;
        }
        url = proxifyUrl(url, noQuery, context);
        return url;
      },
      fromSynchroniteURL: unproxifyUrl,
      prependPath: function (url, path) {
        var djUrl = new DojoUrl(url);
        djUrl.path = '/' + path + djUrl.path;
        url = dojoUrlToString(djUrl);
        return url;
      },
      correctURL: function (url) {
        if (url) {
          url = url.replace(/(^\s+|\s+$)/g, '');
          //allow typing www.google.de instead of http://www.google.de
          if (url.indexOf('http') !== 0) {
            url = 'http://' + url;  //assume http
          }
        }
        return url;
      },
      addParam: function (url, name, value) {
        if (DATA_MAIL_VOID_JS_URL.test(url)) {
          return url;
        }
        var djUrl = new DojoUrl(url);
        var query = djUrl.query;
        if (query) {
          // The url contains query parameters
          var pairs = query.split('&');
          //like dojo.forEach, but can be cancelled with "return false;"
          var inQuery = array.some(pairs, function (pair, index) {
            // should be pair.indexOf(name) == 0) instead of >= 0
            // otherwise we get a false positive for
            // "cacheKey" in http://mozilla.github.io/pdf.js/web/viewer.html?file=http%3A%2F%2Fwww.selab.isti.cnr.it.my.synchronite.de%2Fws-mate%2Fexample.pdf%3FcacheKey%3D-1045444555%26noProxy%3Dtrue
            if (pair.indexOf(name) === 0) {
              //parameter already exists
              pairs[index] = name + '=' + value;
              djUrl.query = pairs.join('&');
              return true;
            }
          });
          if (!inQuery) {
            // The parameter is not yet part of the query
            //url = url + "&" + name + "=" + value;
            djUrl.query += '&' + name + '=' + value;
          }
        } else {
          //url = url + "?" + name + "=" + value;
          djUrl.query = name + '=' + value;
        }
        url = dojoUrlToString(djUrl);
        return url;
      },
      removeParam: function (url, parameter) {
        var urlparts = url.split('?');
        if (urlparts.length >= 2) {
          var prefix = encodeURIComponent(parameter) + '=';
          var pars = urlparts[1].split(/[&;]/g);
          for (var i = pars.length; i-- > 0;) {
            if (pars[i].lastIndexOf(prefix, 0) !== -1) {
              pars.splice(i, 1);
            }
          }
          if (pars.length > 0) {
            url = urlparts[0] + '?' + pars.join('&');
          } else {
            url = urlparts[0];
          }
        }
        return url;
      },
      getParam: function (url, name) {
        name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
        var keyValueRegExp = '[\\?&]' + name + '=([^&#]*)';
        var regex = new RegExp(keyValueRegExp);
        var results = regex.exec(url);
        if (results) {
          return results[1];
        } else {
          return '';
        }
      },
      getBaseUrl: function (contextWindow) {
        var contextDoc = contextWindow.document;
        var bases = contextDoc.getElementsByTagName('base');
        if (bases.length > 0) {
          var basehref = bases[0].getAttribute('href');
          if (basehref) {
            return basehref;
          }
        }
        if (contextDoc.baseURI) {
          var cleanURL = synchUrl.removeSynchParams(contextDoc.baseURI);
          return cleanURL;
        }
        console.debug('WARNING BASEURI NOT FOUND!');
        return this.fromSynchroniteURL(contextWindow.location.href);
      },
      getHostWithoutSubdomains: function () {
        var i = 0, domain = document.domain, p = domain.split('.'), s = '_gd' + new Date().getTime();
        while (i < p.length - 1 && document.cookie.indexOf(s + '=' + s) == -1) {
          domain = p.slice(-1 - ++i).join('.');
          document.cookie = s + '=' + s + ';domain=' + domain + ';';
        }
        document.cookie = s + '=;expires=Thu, 01 Jan 1970 00:00:01 GMT;domain=' + domain + ';';
        return domain;
      },
      removeSynchParams: function (url) {
        for (var i = 0; i < synchParams.length; i++) {
          url = synchUrl.removeParam(url, synchParams[i]);
        }
        return url;
      },
      isHashOnly: function (absoluteUrlA, absoluteUrlB) {
        // summary: Checks if the only thing that changes is the hash tag which won't trigger
        //          a page reload.
        var i1, i2, partA, partB;
        if (absoluteUrlA && absoluteUrlB) {
          i1 = absoluteUrlA.indexOf('#');
          i2 = absoluteUrlB.indexOf('#');
          if (i1 == -1 && i2 == -1) {
            return false;
          }
          i1 = i1 >= 0 ? i1 : absoluteUrlA.length;
          i2 = i2 >= 0 ? i2 : absoluteUrlB.length;
          partA = absoluteUrlA.substring(0, i1);
          partB = absoluteUrlB.substring(0, i2);
          return partA === partB;
        }
        return false;
      },
      //qualify an HREF to form a complete URI
      resolveURL: function (href, contextOrWindow) {
        // FIXED: Cosmos Bug, where relative url with leading whitespace is assigned to window.location
        // Trim Whitespace from href
        if (typeof href === 'string') {
          href = dojoString.trim(href);
        }
        //Performance Optimization, check if URL is already qualified
        if (/^([a-z]+):\/\//.test(href)) {
          return href;
        }
        //look for a base element to use instead
        var here;
        // if the context argument is present and non-empty string, use that instead
        if (contextOrWindow) {
          if (dojoLang.isString(contextOrWindow)) {
            here = contextOrWindow;
          }
        } else {
          contextOrWindow = synchQuery.synchronizedWindow();
        }
        if (!here) {
          here = this.getBaseUrl(contextOrWindow);
          if (!here) {
            here = this.fromSynchroniteURL(contextOrWindow.location.href);
          }
        }
        //extract the protocol, host and path
        //and create a location object with the data
        var parts = here.replace('//', '/').split('/');
        var loc = {
          protocol: parts[0],
          host: parts[1]
        };
        //check if href is relative to protocol
        if (href.indexOf('//') === 0) {
          return loc.protocol + href;
        }
        var resolved = new DojoUrl(here, href).toString();
        //console.debug("Resolved URL: " + resolved);
        return resolved;  //            parts.splice(0, 2);
                          //            loc.pathname = "/" + parts.join("/");
                          //            //build a base URI from the protocol plus host (which includes port if applicable)
                          //            var uri = loc.protocol + "//" + loc.host;
                          //            //if the input path is relative-from-here
                          //            //just delete the ./ token to make it relative
                          //            if(/^(\.\/)([^\/]?)/.test(href))
                          //            {
                          //                href = href.replace(/^(\.\/)([^\/]?)/, "$2");
                          //            }
                          //
                          //            //if the input href is already qualified, copy it unchanged
                          //            if(/^([a-z]+)\:\/\//.test(href)) {
                          //                uri = href;
                          //            }
                          //            //or if the input href begins with a leading slash, then it"s base relative
                          //            //so just add the input href to the base URI
                          //            else if(href.substr(0, 1) == "/")
                          //            {
                          //                uri += href;
                          //            }
                          //            //or if it's an up-reference we need to compute the path
                          //            else if(/^((\.\.\/)+)([^\/].*$)/.test(href))
                          //            {
                          //                //get the last part of the path, minus up-references
                          //                var lastpath = href.match(/^((\.\.\/)+)([^\/].*$)/);
                          //                lastpath = lastpath[lastpath.length - 1];
                          //                //count the number of up-references
                          //                var references = href.split("../").length - 1;
                          //                //get the path parts and delete the last one (this page or directory)
                          //                parts = loc.pathname.split("/");
                          //                parts = parts.splice(0, parts.length - 1);
                          //                //for each of the up-references, delete the last part of the path
                          //                for(var i=0; i<references; i++)
                          //                {
                          //                    parts = parts.splice(0, parts.length - 1);
                          //                }
                          //                //now rebuild the path
                          //                var path = "";
                          //                for(i=0; i<parts.length; i++)
                          //                {
                          //                    if(parts[i] != "")
                          //                    {
                          //                        path += "/" + parts[i];
                          //                    }
                          //                }
                          //                path += "/";
                          //                //and add the last part of the path
                          //                path += lastpath;
                          //                //then add the path and input href to the base URI
                          //                uri += path;
                          //            }
                          //            else if (/^#/.test(href)) { //hash
                          //                var newloc = uri + loc.pathname + href;
                          //                return newloc;
                          //            } else { //otherwise it"s a relative path,
                          //
                          //                //calculate the path to this directory
                          //                path = "";
                          //                parts = loc.pathname.split("/");
                          //                parts = parts.splice(0, parts.length - 1);
                          //                for(var i=0; i<parts.length; i++)
                          //                {
                          //                    if(parts[i] != "")
                          //                    {
                          //                        path += "/" + parts[i];
                          //                    }
                          //                }
                          //                path += "/";
                          //                //then add the path and input href to the base URI
                          //                uri += path + href;
                          //            }
                          //            //return the final uri
                          //            return uri;
      },
      isCrossDomainSrc: isCrossDomainSrc
    };
    return synchUrl;
  }(dojo__base_lang, dojo_string, dojo__base_array, dojo__base_url, synchronite__base_query, synchronite_constants_strings);
  synchronite_proxyless_storage = function (dojoCookie, lang, Deferred, lpSecureStorage, baseUrl) {
    var storage = {
      storageEngine: 'cookie',
      secureStorageFrameLocation: '/js/synchronite/webagent/libs/lpSecureStorage/storage.min.html',
      secureStorageDomain: '',
      secureStorageApp: 'cobrowse',
      // If changed must also be changed in cobrowse.js (taglet)
      site: '',
      defaultExpires: 7200 * 1000,
      // two hours
      initialized: false,
      init: function (params) {
        if (this.initialized) {
          return;
        }
        this.initialized = true;
        var win = window;
        if (win.lpTag && win.lpTag.taglets && win.lpTag.taglets.lpSecureStorage) {
          this.storageEngine = 'secureStorage';
          if (win.proxyless && win.proxyless.useCdn === true) {
            var leCdnDomain = win.lpTag.getDomain('leCdnDomain');
            var secureStorageTaglet = win.lpTag.taglets.lpSecureStorage;
            this.secureStorageDomain = 'https://' + leCdnDomain + '/le_secure_storage/' + (secureStorageTaglet.v ? secureStorageTaglet.v + '/' : '');
          } else {
            this.secureStorageDomain = params.cobrowseBaseUrl + this.secureStorageFrameLocation;
          }
          if (!/\:\/\/localhost/.test(this.secureStorageDomain) && this.secureStorageDomain.indexOf('http://') === 0) {
            this.secureStorageDomain = this.secureStorageDomain.replace('http://', 'https://');
          }
          this.site = params.site;
          var conf = {
            url: this.secureStorageDomain,
            site: params.site,
            initialStorageType: 'sessionStorage',
            app: this.secureStorageApp,
            chosenStorageHandler: function (h) {
              console.log('Using secureStorage type ' + h);
            }
          };
          var env = lpTag && lpTag.getEnv && lpTag.getEnv();
          if (env) {
            conf.env = env;
          }
          //init SecureStorage
          lpSecureStorage.configure({ conf: conf });
        }
      },
      setValue: function (paramsOrKey, value, options) {
        var key, ret, locations = (synchroniteConfig.restrictToDomains || []).slice(), deferred = new Deferred();
        options = options || {};
        if (value) {
          key = paramsOrKey;
        } else {
          key = paramsOrKey.key;
          value = paramsOrKey.value;
        }
        console.debug('storage.setValue(' + key + ', ' + value + ')...Engine = ' + this.storageEngine);
        if (this.storageEngine === 'cookie') {
          options = lang.mixin({
            domain: '.' + baseUrl.getHostWithoutSubdomains(),
            path: '/'
          }, options);
          ret = dojoCookie(key, value, options);
          deferred.resolve(ret);
        } else {
          console.log('cometd setValue saving to lpSecureStorage');
          lpSecureStorage.setValue({
            site: this.site,
            app: this.secureStorageApp,
            appName: 'cobrowse',
            key: key,
            value: value,
            domain: this.secureStorageDomain,
            expires: this.defaultExpires,
            locations: locations,
            success: function (data) {
              console.debug('storage.setValue(' + key + ', ' + value + ')...SUCCESS');
              deferred.resolve(data);
            },
            error: function (error) {
              console.debug('storage.setValue(' + key + ', ' + value + ')...ERROR');
              deferred.reject(error);
            }
          });
        }
        return deferred;
      },
      getValue: function (key, successCallback, errorCallback) {
        console.debug('storage.getValue(' + key + ').....Engine = ' + this.storageEngine);
        if (this.storageEngine === 'cookie') {
          return successCallback(dojoCookie(key));
        } else {
          lpSecureStorage.getValue({
            site: this.site,
            app: this.secureStorageApp,
            appName: 'cobrowse',
            key: key,
            domain: this.secureStorageDomain,
            success: function (data) {
              console.debug('SUCCESS storage.getValue(' + key + ') -> ' + data);
              if (successCallback) {
                successCallback(data);
              }
            },
            error: function (data) {
              console.error('ERROR storage.getValue(' + key + ') -> ' + data);
              if (errorCallback) {
                errorCallback(data);
              }
            }
          });
        }
      },
      removeValue: function (key) {
        console.debug('Remove ' + key + ' from storage');
        var deferred = new Deferred();
        if (this.storageEngine === 'cookie') {
          this.deleteCookie(key, '/', baseUrl.getHostWithoutSubdomains());
          deferred.resolve();
        } else {
          lpSecureStorage.removeValue({
            site: this.site,
            app: this.secureStorageApp,
            appName: 'cobrowse',
            key: key,
            domain: this.secureStorageDomain,
            success: function () {
              console.log(arguments);
              deferred.resolve();
            },
            error: function () {
              console.log(arguments);
              deferred.reject();
            }
          });
        }
        return deferred.promise;
      },
      deleteCookie: function (name, path, domain) {
        document.cookie = name + '=' + (path ? ';path=' + path : '') + (domain ? ';domain=' + domain : '') + ';expires=Thu, 01 Jan 1970 00:00:01 GMT';
      },
      setValueInLocalStorage: function (id, val) {
        localStorage.setItem(id, val);
      },
      itemInLocalStorageExists: function (id) {
        return localStorage.getItem(id) !== null;
      },
      removeValueInLocalStorage: function (id) {
        localStorage.removeItem(id);
      }
    };
    return storage;
  }(dojo_cookie, dojo__base_lang, dojo_Deferred, synchronite_proxyless_lib_lpSecureStorageAMD, synchronite__base_url);
  /*
   * Copyright (c) 2008-2017 the original author or authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  (function () {
    function bind(org_cometd) {
      if (!org_cometd.COOKIE) {
        org_cometd.COOKIE = {};
        org_cometd.COOKIE.set = function (name, value, options) {
          throw 'Abstract';
        };
        org_cometd.COOKIE.get = function (name) {
          throw 'Abstract';
        };
      }
      /**
       * The reload extension allows a page to be loaded (or reloaded)
       * without having to re-handshake in the new (or reloaded) page,
       * therefore resuming the existing CometD connection.
       *
       * When the reload() method is called, the state of the CometD
       * connection is stored in the window.sessionStorage object.
       * The reload() method must therefore be called by page unload
       * handlers, often provided by JavaScript toolkits.
       *
       * When the page is (re)loaded, this extension checks the
       * window.sessionStorage and restores the CometD connection,
       * maintaining the same CometD clientId.
       */
      return org_cometd.ReloadExtension = function (configuration) {
        var _cometd;
        var _debug;
        var _state = {};
        var _cookieName = 'org.cometd.reload';
        var _cookiePath = '/';
        var _cookieMaxAge = 5;
        var _cookieDomain = window.location.host;
        var _batch = false;
        var _reloading = false;
        var _cookie;
        this.setCookie = function (cookie) {
          _cookie = cookie;
        };
        function _reload(config) {
          if (_state.handshakeResponse) {
            // _reloading = true; //PATCHED
            // var transport = _cometd.getTransport();
            // if (transport) {
            //     transport.abort();
            // }
            _configure(config);
            var cookie = JSON.stringify(_state);
            _debug('Reload extension saving state', cookie);
            org_cometd.COOKIE.set(_cookieName, cookie, {
              'max-age': _cookieMaxAge,
              path: _cookiePath,
              domain: _cookieDomain,
              expires: 1800000
            });
          }
        }
        function _setReloadCookie() {
          _state.cookiePath = _cookiePath;
          var cookie = JSON.stringify(_state);
          org_cometd.COOKIE.set(_cookieName, cookie);
        }
        function _similarState(oldState) {
          // We want to check here that the CometD object
          // did not change much between reloads.
          // We just check the URL for now, but in future
          // further checks may involve the transport type
          // and other configuration parameters.
          return _state.url == oldState.url;
        }
        function _configure(config) {
          if (config) {
            if (typeof config.cookieMaxAge === 'number') {
              _cookieMaxAge = config.cookieMaxAge;
            }
            if (typeof config.cookieName === 'string') {
              _cookieName = config.cookieName;
            }
            if (typeof config.cookiePath === 'string') {
              _cookiePath = config.cookiePath;
            }
            if (typeof config.cookieDomain === 'string') {
              _cookieDomain = config.cookieDomain;
            }
          }
        }
        function _receive(response) {
          _cometd.receive(response);
        }
        this.configure = _configure;
        this._receive = _receive;
        this.registered = function (name, cometd) {
          _cometd = cometd;
          _cometd.reload = _reload;
          _cometd.setReloadCookie = _setReloadCookie;
          _debug = _cometd._debug;
        };
        this.unregistered = function () {
          delete _cometd.reload;
          _cometd = null;
        };
        this.outgoing = function (message) {
          switch (message.channel) {
          case '/meta/handshake': {
              _state = {};
              _state.url = _cometd.getURL();
              _debug('Reload extension found state', _cookie);
              // Is there a saved handshake response from a prior load ?
              if (_cookie) {
                try {
                  var oldState = JSON.parse(_cookie);
                  _cookie = null;
                  if (oldState.handshakeResponse && _similarState(oldState)) {
                    _debug('Reload extension restoring state', oldState);
                    // Since we are going to abort this message,
                    // we must save an eventual callback to restore
                    // it when we replay the handshake response.
                    var callback = _cometd._getCallback(message.id);
                    var self = this;
                    setTimeout(function () {
                      _debug('Reload extension replaying handshake response', oldState.handshakeResponse);
                      _state.handshakeResponse = oldState.handshakeResponse;
                      _state.transportType = oldState.transportType;
                      // Restore the callback.
                      _cometd._putCallback(message.id, callback);
                      var response = _cometd._mixin(true, {}, _state.handshakeResponse, {
                        // Keep the response message id the same as the request.
                        id: message.id,
                        // Tells applications this is a handshake replayed by the reload extension.
                        ext: { reload: true }
                      });
                      // Use the same transport as before.
                      if (!_state.transportType) {
                        _state.transportType = 'websocket';
                      }
                      response.supportedConnectionTypes = [_state.transportType];
                      self._receive(response);
                      _debug('Reload extension replayed handshake response', response);
                    }, 0);
                    // Delay any sends until first connect is complete.
                    // This avoids that there is an old /meta/connect pending on server
                    // that will be resumed to send messages to the client, when the
                    // client has already closed the connection, thereby losing the messages.
                    // if (!_batch) {
                    //     _batch = true;
                    //     _cometd.startBatch();
                    // }
                    // This handshake is aborted, as we will replay the prior handshake response
                    return null;
                  } else {
                    _debug('Reload extension could not restore state', oldState);
                  }
                } catch (x) {
                  _debug('Reload extension error while trying to restore state', x);
                }
              }
              break;
            }
          case '/meta/connect': {
              if (_reloading === true) {
                // The reload causes the failure of the outstanding /meta/connect,
                // which CometD will react to by sending another. Here we avoid
                // that /meta/connect messages are sent between the reload and
                // the destruction of the JavaScript context, so that we are sure
                // that the first /meta/connect is the one triggered after the
                // replay of the /meta/handshake by this extension.
                _debug('Reload extension aborting /meta/connect during reload');
                return null;
              }
              if (!_state.transportType) {
                _state.transportType = message.connectionType;
                _debug('Reload extension tracked transport type', _state.transportType);
              }
              break;
            }
          case '/meta/disconnect': {
              _state = {};
              break;
            }
          default: {
              break;
            }
          }
          return message;
        };
        this.incoming = function (message) {
          if (message.successful) {
            switch (message.channel) {
            case '/meta/handshake': {
                // If the handshake response is already present, then we're replaying it.
                // Since the replay may have modified the handshake response, do not record it here.
                if (!_state.handshakeResponse) {
                  // Save successful handshake response
                  _state.handshakeResponse = message;
                  _debug('Reload extension tracked handshake response', message);
                }
                break;
              }
            case '/meta/connect': {
                // if (_batch) {
                //     _batch = false;
                //     _cometd.endBatch();
                // }
                break;
              }
            case '/meta/disconnect': {
                _state = {};
                break;
              }
            default: {
                break;
              }
            }
          }
          return message;
        };
        _configure(configuration);
      };
    }
    if (true) {
      org_cometd_ReloadExtensionLP = function (org_cometd) {
        return typeof bind === 'function' ? bind(org_cometd) : bind;
      }(org_cometd);
    } else {
      bind(org.cometd);
    }
  }());
  synchronite_constants_constants = {
    defaultChannel: '/pl',
    serviceChannel: '/t/sn',
    cssProxySuffix: '/cssproxy',
    imgProxySuffix: '/imgproxy',
    fontProxySuffix: '/fontproxy',
    cobrowsingFrameName: 'displayContent',
    // storage keys
    ticketIdKey: 's.tid',
    cometReloadKey: 's.connect',
    userIdKey: 's.uid',
    skillId: 'skillId',
    sessionIdKey: 's.sid',
    usernameKey: 's.userName',
    sendStateKey: 'sendState',
    startTimestampKey: 's.startTS',
    type: 's.type',
    cobrowseActive: 's.cobrowseActive',
    isLocalAudioEnabledKey: 's.isLocalAudioEnabled',
    isLocalVideoEnabledKey: 's.isLocalCameraEnabled',
    defaultUsername: 'Visitor',
    CONFIG: {
      CALL_TYPE: {
        VOICE: 'voice',
        VIDEO: 'video'
      }
    },
    // event types
    EVENT: {
      DOM: 'dom',
      TEXTCONTENT: 'textcontent',
      STATE: 'state',
      MOUSE: 'mouse',
      UWSTATE: 'uwState',
      RESIZE: 'window:resize',
      SELECT: 'select',
      RESTRICTEDPAGE: 'restrictedPage',
      ELEMENTVALUE: 'elementvalue',
      KEYBOARD: 'keyboard',
      SCROLL: 'scroll',
      CANVAS: 'canvas',
      MOUSEMOVE: 'mousemove',
      FOCUS: 'focus',
      LOADING: 'loading',
      DUMMY: 'dummy',
      CSAT: 'csat',
      HEARTBEAT: 'heartbeat',
      SIGNAL: 'signal',
      REMOTESIGNAL: 'remoteSignal',
      LOCALSIGNAL: 'localSignal',
      CANSTARTCALL: 'canStartCall',
      STARTCALL: 'startCall',
      GAINEDMEDIAPERMISSIONS: 'gainedMediaPermissions',
      TURNCONFIG: 'turnConfig',
      TOGGLEVIDEO: 'videoToggle',
      TOGGLEAUDIO: 'audioToggle',
      ENDSESSION: 'endSession',
      NOCAMERAACCESS: 'noCameraAccess',
      FLIPCAMERA: 'flipCamera',
      TURNUSAGE: 'turnIsUsed',
      BROWSERNOTSUPPORTED: 'browserNotSupported',
      CONNECTIONLOST: 'connectionLost',
      RECEIVEDREMOTESTREAM: 'receivedRemoteStream',
      CALLDROPPED: 'callDropped',
      STOPCALLANDRESTART: 'stopCallAndRestart',
      TICKETEXPIRED: 'ticketExpired',
      GENERALCALLINITIALIZATIONERROR: 'generalCallInitializationError',
      CONSUMERJOINING: 'consumerJoining',
      DUPLICATECONSUMERDETECTED: 'duplicateConsumerDetected'
    },
    COMMAND: {
      REQUESTSTATE: 'requestState',
      REQUESTTURN: 'requestTurnConfig',
      TURNLOGGING: 'turnLogging',
      CLIENTSIDELOGGING: 'clientSideLogging'
    },
    ERROR: {
      UNABLETOCONNECT: 'UNABLE_TO_CONNECT',
      BROWSERNOTSUPPORTED: 'BROWSER_NOT_SUPPORTED',
      NOCAMERAACCESS: 'NO_CAMERA_ACCESS',
      AGENTDISCONNECTED: 'AGENT_DISCONNECTED',
      TICKETEXPIRED: 'TICKET_EXPIRED',
      INITIALIZATIONERROR: 'INITIALIZATION_ERROR',
      JOINEDFROMOTHERBROWSER: 'JOINED_FROM_OTHER_BROWSER'
    },
    LOGGING: {
      LEVEL: {
        ERROR: 'error',
        WARN: 'warn',
        INFO: 'info',
        DEBUG: 'debug',
        TRACE: 'trace'
      }
    },
    ERRORNUMBER: {
      // client signals
      UNABLE_TO_CONNECT: 1510,
      BROWSER_NOT_SUPPORTED: 1511,
      NO_CAMERA_ACCESS: 1512,
      AGENT_DISCONNECTED: 1513,
      NO_MICROPHONE_OR_ENUMERATION_BLOCKED: 1514,
      NO_CAMERA_OR_ENUMERATION_BLOCKED: 1515,
      // app initialization
      ERROR_INIT_UNABLE_TO_CREATE_UI_WHEN_FIRST_START: 1530,
      ERROR_RESUMING_SESSION_UNABLE_TO_CREATE_UI_ON_SLIDER_OPENED: 1531,
      ERROR_RESUMING_SESSION_UNABLE_TO_CREATE_UI_ON_ALREADY_FIRED_EVENTS: 1532,
      ERROR_INIT_UNIFIED_WINDOW_DID_NOT_LOAD: 1533,
      ERROR_INIT_I18N_UNABLE_TO_CHANGE_LANGUAGE: 1534,
      ERROR_INIT_I18N_UNABLE_TO_LOAD_LANGUAGE_NAMESPACES: 1535,
      ERROR_INIT_UNKNOWN_ERROR: 1536,
      ERROR_TICKET_ID_NOT_VALID: 1537,
      ERROR_VALIDATING_TICKET_ID: 1538,
      ERROR_TICKET_ID_NOT_FOUND: 1539,
      ERROR_ACCESSING_STORAGE: 1540,
      ERROR_ACCESSING_STORAGE_SEND_STATE: 1541,
      ERROR_ACCESSING_STORAGE_SESSION_ID: 1542,
      // simple-peer WebRTC errors
      UNKNOWN_SIMPLE_PEER_ERROR: 1700,
      SIMPLE_PEER_DEPENDENCY_ERROR: 1701,
      ERR_WEBRTC_SUPPORT: 1702,
      ERR_CREATE_OFFER: 1703,
      ERR_CREATE_ANSWER: 1704,
      ERR_SET_LOCAL_DESCRIPTION: 1705,
      ERR_SET_REMOTE_DESCRIPTION: 1706,
      ERR_ADD_ICE_CANDIDATE: 1707,
      ERR_ICE_CONNECTION_FAILURE: 1708,
      ERR_SIGNALING: 1709,
      ERR_DATA_CHANNEL: 1710,
      ERR_CONNECTION_FAILURE: 1711,
      ERR_PC_CONSTRUCTOR: 1712,
      ERR_ADD_TRANSCEIVER: 1713,
      ERR_SENDER_REMOVED: 1714,
      ERR_SENDER_ALREADY_ADDED: 1715,
      ERR_TRACK_NOT_ADDED: 1716,
      ERR_UNSUPPORTED_REPLACETRACK: 1717,
      ERR_REMOVE_TRACK: 1718,
      ERR_ICE_CONNECTION_CLOSED: 1719,
      // misc.
      ERROR_AUTOPLAY_REMOTE_VIDEO: 1570,
      SECOND_ERROR_AFTER_ATTEMPT_TO_PLAY_VIDEO: 1572,
      ERROR_SYNCHRONIZING_STREAM_TO_PEER: 1573,
      UNKNOWN_ERROR_SYNCHRONIZING_STREAM_TO_PEER: 1574,
      ERROR_THROWN_DURING_SIGNALING: 1575,
      UNKNOWN_ERROR_THROWN_DURING_SIGNALING: 1576,
      GET_STATS_ERROR: 1577,
      UNKNOWN_GET_STATS_ERROR: 1578,
      ERROR_AUTOPLAY_LOCAL_VIDEO: 1579,
      NO_REMOTE_AUDIO_TRACK: 1580,
      NO_LOCAL_AUDIO_TRACK: 1581,
      TOO_MANY_LOCAL_VIDEO_TRACKS: 1582,
      TOO_MANY_LOCAL_AUDIO_TRACKS: 1583,
      TOO_MANY_REMOTE_VIDEO_TRACKS: 1584,
      TOO_MANY_REMOTE_AUDIO_TRACKS: 1585,
      ERROR_AUTOPLAY_TIMEOUT: 1586,
      SEVERE_ERROR_AUTOPLAY_LOCAL_VIDEO: 1587,
      SEVERE_ERROR_AUTOPLAY_REMOTE_VIDEO: 1588,
      DEVICE_ENUMERATION_FAILED: 1589,
      CALL_RESTARTING: 1590,
      CALL_MAX_RESTARTS_EXHAUSTED: 1591
    }
  };
  dojox_cometd_reloadLP = function (org_cometd, domReady, lang, storage, ReloadExtensionLP, cometd, constants) {
    var reloadExtension = new ReloadExtensionLP();
    cometd.registerExtension('reload', reloadExtension);
    domReady(function () {
      storage.init({
        site: synchroniteConfig.tenantId,
        cobrowseBaseUrl: synchroniteConfig.serverUrl || window.location.protocol + '//' + synchroniteConfig.tenantHost
      });
      storage.getValue(constants.cometReloadKey, function (cookie) {
        if (cookie) {
          console.log('got cookie, set it in reload extension');
          reloadExtension.setCookie(cookie);
        } else {
          console.log('no valid reload cookie found');
        }
      });
    });
    // Remap cometd COOKIE functions to dojo cookie functions
    org_cometd.COOKIE.set = lang.hitch(storage, storage.setValue);
    org_cometd.COOKIE.get = lang.hitch(storage, storage.getValue);
    org_cometd.COOKIE.remove = lang.hitch(storage, storage.removeValue);
    return reloadExtension;
  }(org_cometd, dojo_domReady, dojo__base_lang, synchronite_proxyless_storage, org_cometd_ReloadExtensionLP, dojox_cometd, synchronite_constants_constants);
  dojo__base_unload = function (dojo, lang, on) {
    // module:
    //		dojo/unload
    var win = window;
    var unload = {
      // summary:
      //		This module contains the document and window unload detection API.
      //		This module is deprecated.  Use on(window, "unload", func)
      //		and on(window, "beforeunload", func) instead.
      addOnWindowUnload: function (obj, functionName) {
        // summary:
        //		Registers a function to be triggered when window.onunload fires.
        //		Deprecated, use on(window, "unload", lang.hitch(obj, functionName)) instead.
        // description:
        //		The first time that addOnWindowUnload is called Dojo
        //		will register a page listener to trigger your unload
        //		handler with. Note that registering these handlers may
        //		destroy "fastback" page caching in browsers that support
        //		it. Be careful trying to modify the DOM or access
        //		JavaScript properties during this phase of page unloading:
        //		they may not always be available. Consider
        //		addOnUnload() if you need to modify the DOM or do
        //		heavy JavaScript work since it fires at the equivalent of
        //		the page's "onbeforeunload" event.
        // example:
        //	|	var afunc = function() {console.log("global function");};
        //	|	require(["dojo/_base/unload"], function(unload) {
        //	|		var foo = {bar: function(){ console.log("bar unloading...");}, 
        //	|		           data: "mydata"};
        //	|		unload.addOnWindowUnload(afunc);
        //	|		unload.addOnWindowUnload(foo, "bar");
        //	|		unload.addOnWindowUnload(foo, function(){console.log("", this.data);});
        //	|	});
        if (!dojo.windowUnloaded) {
          on(win, 'unload', dojo.windowUnloaded = function () {
          });
        }
        on(win, 'unload', lang.hitch(obj, functionName));
      },
      addOnUnload: function (obj, functionName) {
        // summary:
        //		Registers a function to be triggered when the page unloads.
        //		Deprecated, use on(window, "beforeunload", lang.hitch(obj, functionName)) instead.
        // description:
        //		The first time that addOnUnload is called Dojo will
        //		register a page listener to trigger your unload handler
        //		with.
        //
        //		In a browser environment, the functions will be triggered
        //		during the window.onbeforeunload event. Be careful of doing
        //		too much work in an unload handler. onbeforeunload can be
        //		triggered if a link to download a file is clicked, or if
        //		the link is a javascript: link. In these cases, the
        //		onbeforeunload event fires, but the document is not
        //		actually destroyed. So be careful about doing destructive
        //		operations in a dojo.addOnUnload callback.
        //
        //		Further note that calling dojo.addOnUnload will prevent
        //		browsers from using a "fast back" cache to make page
        //		loading via back button instantaneous.
        // example:
        //	|	var afunc = function() {console.log("global function");};
        //	|	require(["dojo/_base/unload"], function(unload) {
        //	|		var foo = {bar: function(){ console.log("bar unloading...");}, 
        //	|		           data: "mydata"};
        //	|		unload.addOnUnload(afunc);
        //	|		unload.addOnUnload(foo, "bar");
        //	|		unload.addOnUnload(foo, function(){console.log("", this.data);});
        //	|	});
        on(win, 'beforeunload', lang.hitch(obj, functionName));
      }
    };
    dojo.addOnWindowUnload = unload.addOnWindowUnload;
    dojo.addOnUnload = unload.addOnUnload;
    return unload;
  }(dojo__base_kernel, dojo__base_lang, dojo_on);
  liveperson_visitor_common = function () {
    function _getMonitoringSDK(win) {
      return win.lpTag && win.lpTag.taglets && win.lpTag.taglets.lp_monitoringSDK;
    }
    function _getSessionId(win) {
      // Example: SSID = 3d40kdbJSpmkcF3oPzN8xg.85c5d403b52e2e8304052c44f2fa4b6c0da97f73
      // lp_ssid
      var id;
      var lpMonitoring = _getMonitoringSDK(win);
      if (lpMonitoring) {
        id = lpMonitoring.getSid();
      }
      if (id) {
        return id;
      }
      var lpMTagConfig = win.lpMTagConfig;
      if (lpMTagConfig && lpMTagConfig.FPC_SKEY) {
        id = lpMTagConfig.FPC_SKEY;
      }
      return id;
    }
    function _getVisitorSessionId(win) {
      // vsid
      // sessionDataManager.readCookie(configuration.lpNumber + "-SKEY") || (window.lpMTagConfig && window.lpMTagConfig.LPSID_VAR);
      // lpSessionID = waitForCookieNamed("LPSID-" + siteEntity.getSiteId(), 20); // SHARK
      var id;
      var lpMTagConfig = win.lpMTagConfig;
      if (lpMTagConfig && lpMTagConfig.LPSID_VAR) {
        id = lpMTagConfig.LPSID_VAR;
      }
      return id;
    }
    function _getVisitorId(win) {
      // Example: SVID = rWF8UL4RS02p%2BVxF88nH3A
      // lp_svid
      // visitorId = reqObj.visitorId || sessionDataManager.readCookie(configuration.lpNumber + '-VID');
      var id;
      var lpMonitoring = _getMonitoringSDK(win);
      if (lpMonitoring) {
        // unified window
        id = lpMonitoring.getVid();
      }
      if (id) {
        return id;
      }
      var lpMTagConfig = win.lpMTagConfig;
      if (lpMTagConfig && lpMTagConfig.FPC_VID) {
        id = lpMTagConfig.FPC_VID;
      }
      return id;
    }
    function _getRedirectedSiteId(win) {
      // This detects a redirected site based on the presence of lpMTagConfig first party cookie configuration
      // <SITEID>-SKEY and <SITEID>-VID that indicate a redirected account
      var tagConfig = win && win.lpMTagConfig, PROPS = [
          'FPC_SKEY_NAME',
          'FPC_VID_NAME'
        ], value, matches;
      if (tagConfig) {
        for (var i = 0; i < PROPS.length; i++) {
          value = tagConfig[PROPS[i]];
          if (value) {
            matches = value.match(/((qa|P)?[\d]+)(-[\w])/);
            if (matches && matches.length > 0) {
              return matches[1];
            }
          }
        }
      }
    }
    return {
      getVisitorId: _getVisitorId,
      getSessionId: _getSessionId,
      getVisitorSessionId: _getVisitorSessionId,
      getRedirectedSiteId: _getRedirectedSiteId
    };
  }();
  synchronite__base_goog = function () {
    // The 'sinkValue' function is required to signal to the closure
    // compiler that a variable should not be removed.
    // see: http://docs.closure-library.googlecode.com/git/closure_goog_reflect_reflect.js.source.html
    // bug reports:
    // https://code.google.com/p/closure-compiler/issues/detail?id=506
    // https://code.google.com/p/closure-compiler/issues/detail?id=451
    /**
     * To assert to the compiler that an operation is needed when it would
     * otherwise be stripped. For example:
     * <code>
     *     // Force a layout
     *     goog.reflect.sinkValue(dialog.offsetHeight);
     * </code>
     * @type {!Function}
     */
    var sinkValue = function (x) {
      sinkValue[' '](x);
      return x;
    };
    /**
     * The compiler should optimize this function away iff no one ever uses
     * goog.reflect.sinkValue.
     */
    sinkValue[' '] = function () {
    };
    var goog = {
      sinkValue: sinkValue,
      keepFunctionName: function (name, anonFunc) {
        if (anonFunc.toString) {
          var functionComplete = anonFunc.toString();
          var functionParamsAndBody = functionComplete.slice(functionComplete.indexOf('('), functionComplete.length + 1);
          //noinspection JSHint
          return new Function('return function ' + name + functionParamsAndBody)();
        }
        return anonFunc;
      }
    };
    return goog;
  }();
  synchronite_micro_dom = function (has, goog, baseArray) {
    //PRIVATE
    var _isVisible = function (node) {
      // summary: Elements are considered visible if they consume space in the document. Visible elements have a width or height that is greater than zero.
      // description: Elements with visibility: hidden or opacity: 0 are considered visible, since they still consume space in the layout.
      // Some SVG elements do not implement getBox() and throw a "NS_ERROR_NOT_IMPLEMENTED" exception
      var visible = false;
      try {
        visible = node.offsetWidth && node.offsetHeight || node.clientWidth && node.clientHeight || node.getBBox && node.getBBox() && node.getBBox().width && node.getBBox().width;
      } catch (e) {
        console.warn('Failed to determine if element is visible ' + e);
      }
      return visible;
    };
    /**
     * For feature detection
     * @param {Function} fn The function to test for native support
     */
    var _isNative = function (f) {
      try {
        return !!f && ((typeof f).toLowerCase() == 'function' || (typeof f).toLowerCase() == 'object') && (f === Function.prototype || /\s*\[native code\]\s*s*/i.test(String(f)));
      } catch (e) {
        return true;
      }
    };
    var scrollable = function (theoreticallyScrollable, contextWindow) {
      var filter = function (element) {
        var elementStyle = contextWindow.getComputedStyle(element);
        if (!elementStyle) {
          return false;
        }
        var overflow = elementStyle.overflow, overflowX = elementStyle.overflowX, overflowY = elementStyle.overflowY;
        if (!(overflow || overflowX || overflowY)) {
          // Shortcut when styles are not set at all
          return false;
        }
        if (element.className.indexOf('scrollWindow') >= 0) {
          // Fixes dijit scrollable view on HSBC website
          return true;
        }
        var SCROLLABLE = {
          scroll: 1,
          auto: 1  // visible: 1 // Overflow is not clipped. It renders outside the element's box. This is default
        };
        var vertically_scrollable, horizontally_scrollable;
        if (overflow in SCROLLABLE) {
          return true;
        }
        vertically_scrollable = (theoreticallyScrollable || element.clientHeight < element.scrollHeight) && (overflowY in SCROLLABLE || overflow in SCROLLABLE);
        if (vertically_scrollable) {
          return true;
        }
        horizontally_scrollable = (theoreticallyScrollable || element.clientWidth < element.scrollWidth) && (overflowX in SCROLLABLE || overflow in SCROLLABLE);
        if (horizontally_scrollable) {
          return true;
        }
        return false;
      };
      return filter;
    };
    var docScroll = function docScroll(doc) {
      // summary:
      //		Returns an object with {node, x, y} with corresponding offsets.
      // doc: Document?
      //		Optional document to query.   If unspecified, use win.doc.
      // returns: Object
      var scrollRoot = doc.parentWindow || doc.defaultView;
      // use UI window, not dojo.global window.   TODO: use dojo/window::get() except for circular dependency problem
      return 'pageXOffset' in scrollRoot ? {
        x: scrollRoot.pageXOffset,
        y: scrollRoot.pageYOffset
      } : (scrollRoot = has('quirks') ? _getBody(doc) : doc.documentElement) && {
        x: scrollRoot.scrollLeft || 0,
        y: scrollRoot.scrollTop || 0
      };
    };
    var getPosition = function (node, includeScroll) {
      // summary:
      //		Gets the position and size of the passed element relative to
      //		the viewport (if includeScroll==false), or relative to the
      //		document root (if includeScroll==true).
      //
      // description:
      //		Returns an object of the form:
      //		`{ x: 100, y: 300, w: 20, h: 15 }`.
      //		If includeScroll==true, the x and y values will include any
      //		document offsets that may affect the position relative to the
      //		viewport.
      //		Uses the border-box model (inclusive of border and padding but
      //		not margin).  Does not act as a setter.
      // node: DOMNode|String
      // includeScroll: Boolean?
      // returns: Object
      var db = _getBody(node.ownerDocument), ret = node.getBoundingClientRect();
      ret = {
        x: ret.left,
        y: ret.top,
        w: ret.right - ret.left,
        h: ret.bottom - ret.top
      };
      if (has('ie') < 9) {
        // On IE<9 there's a 2px offset that we need to adjust for, see dojo.getIeDocumentElementOffset()
        //var offset = geom.getIeDocumentElementOffset(node.ownerDocument);
        // fixes the position in IE, quirks mode
        ret.x -= has('quirks') ? db.clientLeft + db.offsetLeft : 0;
        ret.y -= has('quirks') ? db.clientTop + db.offsetTop : 0;
      }
      // account for document scrolling
      // if offsetParent is used, ret value already includes scroll position
      // so we may have to actually remove that value if !includeScroll
      if (includeScroll) {
        var scroll = docScroll(node.ownerDocument);
        ret.x += scroll.x;
        ret.y += scroll.y;
      }
      return ret;  // Object
    };
    var getNodePosition = function (node) {
      // summary: Gets the x,y position of an element target including scroll.
      if (_isVisible(node)) {
        try {
          // Uses the border-box model (inclusive of border and padding but
          // not margin).
          return getPosition(node, true);
        } catch (e) {
          console.warn('getNodePosition: Unable to get node position. Page unloaded?');
        }
      }
      return null;
    };
    var _isTextType = function (type) {
      return /text|search|tel|url|email|datetime|date|month|week|time|number|range|color/i.test(type);
    };
    var _isHtml5Typeable = function (el) {
      var tagName = el.tagName;
      return /input/i.test(tagName) && _isTextType(el.type);
    };
    var _getBody = function (doc) {
      return doc.body || doc.getElementsByTagName('body')[0];  // Node
    };
    var _getWin = function (doc) {
      return doc.parentWindow || doc.defaultView;  // Window
    };
    ///////////////
    /**
     * Check if a property can be accessed without throwing an exception.
     * Adapted from goog.reflect.canAccessProperty
     * @param {Object} obj The owner of the property.
     * @param {string} prop The property name.
     * @return {boolean} Whether the property is accessible. Will also return true
     *     if obj is null.
     *
     */
    var _canAccessProperty = function (obj, prop) {
      /** @preserveTry */
      try {
        goog.sinkValue(obj[prop]);
        return true;
      } catch (e) {
      }
      return false;
    };
    // get inherited background color to use as endColor
    // Derives color of child node by parent nodes color
    var getInheritedBgcolor = function (aNode) {
      var parentNode = aNode;
      var body = synchDom.getBody(aNode.ownerDocument);
      if (body && parentNode && parentNode.style) {
        var color = null;
        do {
          color = parentNode.style.backgroundColor;
          if (!color || color.toLowerCase() == 'rgba(0, 0, 0, 0)') {
            color = 'transparent';
          }
          if (parentNode == body) {
            parentNode = null;
            return color;
          }
          parentNode = parentNode.parentNode;
        } while (parentNode && color == 'transparent');
        return color;
      } else {
        return null;
      }
    };
    //PUBLIC
    var synchDom = {
      getInheritedBgcolor: getInheritedBgcolor,
      canAccessProperty: _canAccessProperty,
      canAccessNode: function (node) {
        return _canAccessProperty(node, 'nodeType');
      },
      byId: function (id, doc) {
        if (typeof id != 'string') {
          return id;
        }
        doc = doc || document;
        return doc.getElementById(id);
      },
      setAttributes: function (node, attrs) {
        for (var key in attrs) {
          if (attrs.hasOwnProperty(key)) {
            if (/(innerHTML|className)/.test(key)) {
              node[key] = attrs[key];
            } else {
              node.setAttribute(key, attrs[key]);
            }
          }
        }
      },
      setStyles: function (node, styles) {
        var nodeStyle = node.style;
        for (var key in styles) {
          if (styles.hasOwnProperty(key)) {
            nodeStyle[key] = styles[key];
          }
        }
      },
      toDom: function (html, doc) {
        doc = doc || document;
        html = html.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, html);
        // trim
        var div = doc.createElement('div');
        div.innerHTML = html;
        return div.firstChild;
      },
      create: function (name, attrs, styles, container) {
        if (arguments.length == 3) {
          container = styles;
        }
        var doc = container.ownerDocument, el = doc.createElement(name);
        synchDom.setStyles(el, styles);
        synchDom.setAttributes(el, attrs);
        return container.appendChild(el);
      },
      canAccessWindow: function (win) {
        return _canAccessProperty(win, 'document');
      },
      isWindowScroll: function (node) {
        // summary: Checks if the node scroll should be executed on the window.
        return node.nodeType && node.nodeType == 9 || node.nodeName && /^html$/i.test(node.nodeName);
      },
      isTextType: _isTextType,
      isHtml5Typeable: _isHtml5Typeable,
      isTypeable: function (el) {
        // FIXED: Removed password field
        return el && (/textarea|input/i.test(el.tagName) && (/text|password/i.test(el.type) || _isHtml5Typeable(el)));
      },
      isVisible: _isVisible,
      isNative: _isNative,
      scrollable: scrollable,
      loadScript: function (doc, script, url, id, callback) {
        var scriptNode, exisitingNode = doc.getElementsByTagName(script)[0];
        if (doc.getElementById(id)) {
          if (callback) {
            callback({ scriptExists: true });
          }
          return;
        }
        scriptNode = doc.createElement(script);
        scriptNode.id = id;
        scriptNode.onload = callback;
        scriptNode.src = url;
        exisitingNode.parentNode.insertBefore(scriptNode, exisitingNode);
      },
      scrollableDoc: function (win) {
        var doc = win.document;
        var body = _getBody(doc);
        var scrollRoot = doc.compatMode === 'BackCompat' ? body : doc.documentElement;
        if (scrollRoot) {
          return scrollable(true)(scrollRoot);
        }
        return false;
      },
      addEvent: function (target, eventName, listener) {
        if (target.attachEvent) {
          //Internet Explorer
          target.attachEvent('on' + eventName, function () {
            listener.call(target);
          });
          return {
            remove: function () {
            }
          };
        } else if (target.addEventListener) {
          //Firefox & company
          target.addEventListener(eventName, listener, false);
          //don't need the 'call' trick because in FF everything already works in the right way
          return {
            remove: function () {
              target.removeEventListener(eventName, listener);
            }
          };
        }
      },
      getWin: _getWin,
      getBody: _getBody,
      getNodePosition: getNodePosition,
      getNormalizedMouseOffset: function (element, pageX, pageY) {
        // get x,y position of event target
        var pos;
        try {
          pos = getNodePosition(element);
        } catch (e) {
          console.warn('Unable to get element position. Window may have been unloaded: ' + e);
        }
        if (!pos) {
          return {
            nx: 0.5,
            ny: 0.5
          };
        }
        // position may contain half pixels that we should round
        var offsetX = Math.round(pageX - pos.x);
        var offsetY = Math.round(pageY - pos.y);
        var normalizedX = offsetX / pos.w;
        var normalizedY = offsetY / pos.h;
        if (normalizedX === Infinity || normalizedY === Infinity) {
          normalizedX = 0.5;
          normalizedY = 0.5;
        }
        return {
          ox: offsetX,
          oy: offsetY,
          nx: normalizedX,
          ny: normalizedY
        };
      }
    };
    return synchDom;
  }(dojo_has, synchronite__base_goog, dojo__base_array);
  synchronite__base_cookie = function (dojoRegexp) {
    return function (doc, name, value, props) {
      // PACTHED FROM DEFAULT DOJO COOKIE NOT TO USE decodeURIComponent.
      //  summary:
      //      Get or set a cookie.
      //  description:
      //      If one argument is passed, returns the value of the cookie
      //      For two or more arguments, acts as a setter.
      //  doc:
      //      document object to operate on
      //  name:
      //      Name of the cookie
      //  value:
      //      Value for the cookie
      //  props:
      //      Properties for the cookie
      //  example:
      //      set a cookie with the JSON-serialized contents of an object which
      //      will expire 5 days from now:
      //  |   dojoCookie("configObj", dojoJson.stringify(config), { expires: 5 });
      //
      //  example:
      //      de-serialize a cookie back into a JavaScript object:
      //  |   var config = dojoJson.parse(dojoCookie("configObj"));
      //
      //  example:
      //      delete a cookie:
      //  |   dojoCookie("configObj", null, {expires: -1});
      var c = doc.cookie, ret;
      if (arguments.length == 2) {
        var matches = c.match(new RegExp('(?:^|; )' + dojoRegexp.escapeString(name) + '=([^;]*)'));
        ret = matches ? matches[1] : undefined;  // String or undefined
      } else {
        props = props || {};
        // FIXME: expires=0 seems to disappear right away, not on close? (FF3)  Change docs?
        var exp = props.expires;
        if (typeof exp == 'number') {
          var d = new Date();
          d.setTime(d.getTime() + exp * 24 * 60 * 60 * 1000);
          exp = props.expires = d;
        }
        if (exp && exp.toUTCString) {
          props.expires = exp.toUTCString();
        }
        var updatedCookie = name + '=' + value, propName;
        for (propName in props) {
          updatedCookie += '; ' + propName;
          var propValue = props[propName];
          if (propValue !== true) {
            updatedCookie += '=' + propValue;
          }
        }
        doc.cookie = updatedCookie;
      }
      return ret;  // String|undefined
    };
  }(dojo_regexp);
  synchronite__base_window = function (synchQuery, synchCookie, strings) {
    ////////////////////////////////////
    // PRIVATE VARIABLES & FUNCTIONS
    ////////////////////////////////////
    var win = window, config = win.synchroniteConfig;
    var _isWindow = function (o) {
      return 'navigator' in o && 'clearInterval' in o && 'moveBy' in o && o.self === o.window;
    };
    var topOrExternalTargets = {
      '_top': 1,
      '_parent': 1,
      '_blank': 1,
      '_new': 1
    };
    ///////////////////////////////////////////
    // PUBLIC METHODS AND PROPERTIES
    ///////////////////////////////////////////
    var synchWindow = {
      // http://stackoverflow.com/questions/679112/copying-a-function-object-from-one-window-to-another
      exportFunction: function (fn, win) {
        var code;
        try {
          code = fn.toString();
          var params = code.match(/\(([^)]*)\)/);
          if (typeof params[1] !== 'undefined') {
            params = params[1].split(/\s*,\s*/);
          } else {
            params = null;
          }
          code = code.replace(/^[^{]*\{/, '');
          code = code.replace(/}$/, '');
          if (params) {
            return new win.Function(params, code);
          }
          return new win.Function(code);
        } catch (e) {
          console.error('exportFunction: Cannot export function: ' + code);
        }
      },
      hasInflightRequest: function (method) {
        if (win.synch && !win.synch.allFramesLoaded) {
          if (!method) {
            // We just want to know if a new page load is in progress and are not interested in the method
            // that caused the page load (e.g. GET or POST)
            console.debug('hasInflightRequest(' + (method ? method : '') + ') -> true');
            return true;
          }
          // mouse click triggered has triggered new page load
          // Two scenarios:
          // 1. GET Request (e.g. Click on link)
          if (method == 'post') {
            console.debug('hasInflightRequest(' + (method ? method : '') + ') -> ' + !!synch.postInProgress);
            return !!synch.postInProgress;
          }
          console.debug('hasInflightRequest(' + (method ? method : '') + ') -> true');
          return true;
        }
        console.debug('hasInflightRequest(' + (method ? method : '') + ') -> false');
        return false;
      },
      isWindowInitialized: function (selector) {
        var aWindow = null;
        try {
          if (_isWindow(selector)) {
            aWindow = selector;
          } else {
            var frameSelector = selector.frame;
            var frameName = selector.frameName;
            var windowName = selector.windowName;
            if (frameName) {
              aWindow = synchQuery.getWindowFromFrameName(frameName);
            } else if (windowName == strings.SYNCHRONIZED_WINDOW) {
              aWindow = synchQuery.synchronizedWindow();
            } else if (windowName && window[windowName]) {
              aWindow = window[windowName];
            } else if (windowName && window.name == windowName) {
              console.warn('Accessing presenter window. Dialog open?');
              aWindow = window;
            } else if (frameSelector) {
              aWindow = synchQuery.queryFrame(frameSelector);
            } else {
              aWindow = synchQuery.synchronizedWindow();
            }
          }
          //            if (aWindow && aWindow.document) {
          //                console.debug("readyState: " + aWindow.document.readyState);
          //                console.debug("initialized: " + aWindow.initialized);
          //            }
          if (aWindow && (aWindow.document && (aWindow.document.readyState == 'interactive' || aWindow.document.readyState == 'complete') || aWindow.initialized)) {
            return true;
          } else {
            console.warn('WINDOW LOADING: ' + selector.frame);
            return false;
          }
        } catch (e) {
          if (typeof selector === 'undefined') {
            console.warn('WINDOW LOADING');
          } else {
            console.warn('WINDOW LOADING:  ', selector.frame);
          }
          return false;
        }
      },
      rewriteLinkTarget: function (linkNode) {
        // summary: Adjusts/Rewrites the target attribute of the anchor node, to make sure
        //          the new window is opened in the main synchronized window.
        // Warning: formTag.action fails to retrieve the attribute when the form has an input
        //          child node with name='target'
        var currentLinkTarget = linkNode.getAttribute('target');
        var newLinkTarget;
        if (currentLinkTarget) {
          var sourceDoc = linkNode.ownerDocument, sourceWin = sourceDoc.parentWindow || sourceDoc.defaultView;
          var synchronizedWindow = synchQuery.synchronizedWindow();
          var synchronizedWindowName = synchronizedWindow.name;
          // May be changed by scripts inside synchronized page
          if (sourceWin == synchronizedWindow && currentLinkTarget in topOrExternalTargets) {
            // FIXED: Bug where strings.SYNCHRONIZED_WINDOW target cannot be found because
            //        the name of the synchronized window has changed and windows
            //        with target == "_top" --> strings.SYNCHRONIZED_WINDOW open in new window.
            linkNode.removeAttribute('target');
          } else if (currentLinkTarget === '_top') {
            newLinkTarget = synchronizedWindowName;
          } else if (currentLinkTarget === '_parent') {
            //relative target
            var targetWin = sourceWin[currentLinkTarget.substring(1)];
            if (targetWin == synchronizedWindow) {
              newLinkTarget = currentLinkTarget;
            } else if (sourceWin == synchronizedWindow) {
              newLinkTarget = '_self';
            } else if (targetWin == window) {
              newLinkTarget = synchronizedWindowName;
            } else {
              newLinkTarget = currentLinkTarget;
            }
          } else if (currentLinkTarget === '_blank' || currentLinkTarget === '_new') {
            newLinkTarget = synchQuery.getRelativeIdentifier(sourceWin, synchQuery.synchronizedWindow());
          } else {
            newLinkTarget = currentLinkTarget;
          }
          if (newLinkTarget) {
            linkNode.setAttribute('target', newLinkTarget);
          }
        }
      },
      eraseCookies: function (cookieWin) {
        var cookieDoc;
        try {
          cookieWin = cookieWin || synchQuery.synchronizedWindow();
          cookieDoc = cookieWin.document;
        } catch (e) {
          console.error('Unable to find cookieWin. Possible XSS issue.');
        }
        // Try to remove all cookies using javascript
        if (cookieDoc) {
          var cookies = cookieDoc.cookie.split(';');
          var cookieName;
          // SYNCHRONITEID should not and cannot be deleted since it is
          // HttpOnly. Other s.xyz cookies should also not be deleted.
          for (var i = 0; i < cookies.length; i++) {
            cookieName = cookies[i].split('=')[0];
            cookieName = cookieName.replace(/\s/gi, '');
            if (cookieName && !/s\.[\w]{3}/.test(cookieName)) {
              // I. TRY: Delete cookie on current domain and current path
              synchCookie(cookieDoc, cookieName, null, { expires: -1 });
              // II. TRY: Delete cookies on current domain name and root path
              synchCookie(cookieDoc, cookieName, null, {
                expires: -1,
                path: '/'
              });
              // III. TRY: If cookie still exists
              // delete cookie with proxy host
              if (synchCookie(cookieDoc, cookieName)) {
                synchCookie(cookieDoc, cookieName, null, {
                  expires: -1,
                  path: '/',
                  domain: '.' + config.proxyHost
                });
              }
            }
          }
        }
      }
    };
    return synchWindow;
  }(synchronite__base_query, synchronite__base_cookie, synchronite_constants_strings);
  synchronite__base_state = function (synchQuery, synchDom, baseCookie, baseUrl, synchWindow, lang, Deferred, DojoURL, sizzle, string, baseArray, aspect, on, base64, strings, storage) {
    //////////////////////////////////////////
    // PRIVATE FUNCTIONS AND VARIABLES
    //////////////////////////////////////////
    var STATE_STORAGE_KEY = 's.state';
    var config = synchroniteConfig;
    var configScripts = config && config.scripts || config && config.integration && config.integration.scripts;
    var filterNodes = function (nodes, excludeNodes) {
      nodes = nodes.filter(function (node) {
        if (synchQuery.isProtected(node)) {
          return false;
        }
        for (var i = 0; i < excludeNodes.length; i++) {
          if (excludeNodes[i] == node) {
            return false;
          }
        }
        return true;
      });
      return nodes;
    };
    var isTextType = synchDom.isTextType;
    var val = function (node) {
      var ret = node.value;
      // Fixes IE8 / Win7 serialization bug.
      // http://blogs.msdn.com/b/jscript/archive/2009/06/23/serializing-the-value-of-empty-dom-elements-using-native-json-in-ie8.aspx
      if (ret === '') {
        ret = '';
      }
      return ret;
    };
    var _executeStateCallback = function (customStateFunction, state, win) {
      if (typeof customStateFunction == 'string') {
        try {
          console.info('Creating State Function');
          customStateFunction = synchWindow.exportFunction(customStateFunction, win);
        } catch (e) {
          console.warn('Error creating state get function: ', e);
          return state;
        }
      }
      var modifiedState;
      try {
        modifiedState = customStateFunction(state);
      } catch (e) {
        console.warn('Error customStateFunction: ', e);
      }
      if (modifiedState) {
        state = modifiedState;
      }
      return state;
    };
    var getState = function (activeWindow, ticketId, username, force) {
      var completeState = { state: synchState.getWindowState(activeWindow, force) };
      if (ticketId) {
        completeState.ticket = ticketId;
      }
      if (username) {
        completeState.username = username;
      }
      completeState.duration = synchState.getSessionDuration();
      if (typeof synch !== 'undefined') {
        if (synch.store) {
          completeState.storeEntries = synch.store.entries;
        }  // cthum: Do we still need this?
           //var chatUrl = synch.deferredLocalState && synch.deferredLocalState.chatUrl;
           //if (chatUrl) {
           //    completeState.chatUrl = chatUrl;
           //    if (completeState.state) {
           //        completeState.state.chatUrl = chatUrl;
           //    }
           //}
      }
      if (typeof config.telepointer != 'undefined') {
        completeState.telepointer = config.telepointer;
      }
      // Loading the local state should be forced, when we change
      // the targetURL because of a redirect from http to https or
      // vice versa
      console.info('completeState.state.force = ' + force);
      completeState.state.force = force;
      return completeState;
    };
    /* this method will catch all userinput from the site (e.g.
     * get the content of form fields)
     * @return all input of the website in json format */
    var getDOMState = function (aDocument) {
      var root, result = [];
      try {
        root = aDocument;
      } catch (e) {
        console.debug('Access to document not allowed. XSS Error?');
        return result;
      }
      var serializeNode = function (node) {
        try {
          var nodeState = synchState.getNodeState(node);
          nodeState.s = synchQuery.getNodeSelector(node);
          result.push(nodeState);
        } catch (e) {
          console.error('Unable to serializeNode ' + node);
        }
      };
      var DIALOG_REQUEST_SUPPORT = 'dialog-request-support';
      //get all input fields but exclude those created by synchronite
      var nodeList = sizzle('input:not([type=submit]):not([type=button]):not([type=hidden]):not([type=image])', root);
      var nodeListExclude = sizzle('#' + DIALOG_REQUEST_SUPPORT + ' input', root);
      nodeList = filterNodes(nodeList, nodeListExclude);
      nodeList.forEach(serializeNode);
      //get all drop down lists
      nodeList = sizzle('select', root);
      nodeListExclude = sizzle('#' + DIALOG_REQUEST_SUPPORT + ' select', root);
      nodeList = filterNodes(nodeList, nodeListExclude);
      nodeList.forEach(serializeNode);
      //get all textareas
      nodeList = sizzle('textarea', root);
      nodeListExclude = sizzle('#' + DIALOG_REQUEST_SUPPORT + ' textarea', root);
      nodeList = filterNodes(nodeList, nodeListExclude);
      nodeList.forEach(serializeNode);
      //add here maybe more input elements in the future
      console.debug('getDOMState result: ' + JSON.stringify(result));
      return result;
    };
    var COMPLETE_DOM = 'cD', DESIGN_MODE = 'dM';
    var DOMStateTries = 0, MAXDOMStateTries = 7, DOMStateTimeout = 1250, DOMStateTimer = null, setDOMState = function (state) {
        console.info('Starting to set DOM State. TRY: ' + DOMStateTries + ' of ' + MAXDOMStateTries);
        window.clearTimeout(DOMStateTimer);
        if (!state) {
          console.warn('DOMSTATE EMPTY!');
          return;
        }
        if (typeof synch != 'undefined') {
          baseArray.forEach(synch.frameLoadedListeners, function (entry) {
            entry.remove();
          });
          synch.frameLoadedListeners = [];
        }
        var domState = state.dom || state;
        if (domState && domState.length > 0) {
          //because the website content is in an iframe, the dojo.global
          //has to be temporary changed (if not, dojo isn't working
          //within the iframe, e.g. dojoDom.byId()
          var activeWindow = synchQuery.synchronizedWindow();
          // get the global scope object from the iframe
          var failedNodes = [];
          console.debug('...complete state: ' + JSON.stringify(state));
          baseArray.forEach(domState, function (nodeState, index) {
            if (nodeState && nodeState.s && nodeState.s.windowName == 'presenterWindow') {
              nodeState.s.windowName = strings.SYNCHRONIZED_WINDOW;
            }
            if (nodeState.s && nodeState.s.element && nodeState.s.element.indexOf(' &gt; ') >= 0) {
              nodeState.s.element = nodeState.s.element.replace(/ &gt; /g, ' > ');
            }
            var node = synchQuery.queryElement(nodeState.s);
            if (node) {
              //check if element exists
              synchState.setNodeState(node, nodeState);
            } else {
              //should not happen...
              failedNodes.push(nodeState);
              console.warn('setDOMState: Element with selector\'' + nodeState.s.element + '\' was not found. document.readyState=' + activeWindow.document.readyState);
            }
          });
          if (failedNodes.length === 0) {
            console.info('DOMState successfully set.');
            DOMStateTries = 0;
            runOnStateSet(activeWindow, state);
          } else if (DOMStateTries < MAXDOMStateTries) {
            console.info('Failed to set DOM State of ' + failedNodes.length + ' nodes.');
            DOMStateTries++;
            // only keep nodes that have already been not yet been set successfully
            state.dom = failedNodes;
            console.info('Unable to set dom state, maybe there are elements that are dynamically created via Ajax. So let\'s wait for them...');
            DOMStateTimer = window.setTimeout(lang.hitch(this, setDOMState, state), DOMStateTimeout);
          } else {
            console.info('Timeout waiting for DOMState.');
            DOMStateTries = 0;
            runOnStateSet(activeWindow, state);
          }
        }
      }, runOnStateSet = function (activeWindow, state) {
        if (configScripts && configScripts.onStateSet) {
          console.info('Executing runOnStateSet using state ' + JSON.stringify(state));
          var modifiedDomState = _executeStateCallback(configScripts.onStateSet, state, activeWindow);
          console.info('Executing State Function...Finished');
        }
      }, setCookieState = function (doc, cookies) {
        var changedCookies;
        for (var key in cookies) {
          var cookie = cookies[key];
          // dojoCookie modifies cookie value by using encodeURIComponent,
          // so use custom function
          var props = {};
          props.path = cookie.path || '/';
          if (props.domain) {
            props.domain = cookie.domain;
          }
          var existingCookieVal = baseCookie(doc, cookie.name);
          if (existingCookieVal) {
            // replace cookie value only if it has changed
            if (existingCookieVal != cookie.value) {
              // but don't set path
              changedCookies = true;
              baseCookie(doc, cookie.name, cookie.value, props);
            }
          } else {
            baseCookie(doc, cookie.name, cookie.value, props);
            changedCookies = true;
          }
        }
        return changedCookies;
      };
    var endsWith = function (str, suffix) {
      return str.indexOf(suffix, str.length - suffix.length) !== -1;
    };
    ///////////////////////////////////////////
    // PUBLIC METHODS AND PROPERTIES
    ///////////////////////////////////////////
    var synchState = {
      on: function (type, listener) {
        return on.parse(this, type, listener, function (target, type) {
          return aspect.after(target, 'on' + type, listener, true);
        });
      },
      emit: function (type, event) {
        var args = [this];
        args.push.apply(args, arguments);
        return on.emit.apply(on, args);
      },
      getWindowState: function (selector, force) {
        // 1. Select the window whose state should be saved.
        var activeWindow;
        try {
          if (selector && selector.frame) {
            activeWindow = synchQuery.queryFrame(selector.frame);
          } else {
            activeWindow = selector;
          }
        } catch (e) {
          console.warn('Unable to get window state for selector: ' + selector + ' getting top window state instead. Error: ' + e);
        }
        // 2. Get the URL of the window
        var state, windowUrl;
        try {
          if (typeof synch != 'undefined' && force) {
            // This happens when we switch between http/https
            state = { url: synch.currentURL };
          } else {
            //if (synchUrl.isProxified(activeWindow.location.href)) {
            if (typeof synch != 'undefined' && synch.currentURL) {
              windowUrl = synch.currentURL;
              // hash changes are not always reflected in currentURL, so we need to append it
              var windowHash = activeWindow.location.hash;
              if (windowHash) {
                var windowUrlObject = new DojoURL(windowUrl);
                if ('#' + windowUrlObject.fragment != windowHash) {
                  windowUrlObject.fragment = windowHash.substr(1);
                  windowUrl = baseUrl.dojoUrlToString(windowUrlObject);
                }
              }
            } else {
              windowUrl = activeWindow.location.href;
            }
            //                           //FIXED: Also add hash tag.
            //                            var hash = activeWindow.location.hash;
            //                            if (hash) {
            //                                windowUrl += hash;
            //                            }
            if (activeWindow.synchEndUrl) {
              var decodedURL = base64.decode(activeWindow.synchEndUrl);
              //  saved parameters of original post request
              if (windowUrl.indexOf('?') == -1) {
                windowUrl += '?';
              }
              windowUrl += decodedURL;
              console.info('Appending original post parameters: ' + activeWindow.synchEndUrl);
            }
            state = {
              url: baseUrl.fromSynchroniteURL(windowUrl + ''),
              cacheKey: activeWindow.synchCacheKey || null
            };
            state.dom = getDOMState(activeWindow.document);
            // if (config.lpPluginActive) {
            //     state.lpVisitId = activeWindow.lpVisitId || null;
            // }
            // Save document cookies?
            var activeDoc = activeWindow.document;
            if (activeDoc.cookie) {
              var jsonCookies = [];
              var documentCookies = activeDoc.cookie.split(';');
              baseArray.forEach(documentCookies, function (oneEntry) {
                var name, value = '';
                // FIXED: Limit number of splits since, cookie value might
                // contain "=" which might be cut off.
                var i = oneEntry.indexOf('=');
                if (i == -1) {
                  name = oneEntry;
                } else {
                  name = oneEntry.substring(0, i);
                  value = oneEntry.substring(i + 1);
                }
                //trim key, so the key is without leading whitespace (if one was existing)
                name = string.trim(name);
                if (/^(cometd|synchronite|s\.)/.test(name) || name.length === 0) {
                  return;
                }
                if (name.length !== 0) {
                  jsonCookies.push({
                    name: name,
                    value: value
                  });
                }
              });
              state.docCookies = jsonCookies;
            }
            // include userPrefs (mouse pointers of other users)
            if (typeof synch != 'undefined' && synch.store) {
              state.storeEntries = synch.store.entries;
            }
          }
        } catch (e) {
          console.warn('getWindowState: Probably unable to access window object. Unloaded or Xss? Details:' + e);
          state = { url: windowUrl };
        }
        if (configScripts && configScripts.onStateGet) {
          state = _executeStateCallback(configScripts.onStateGet, state, activeWindow);
        }
        console.info('getWindowState result: ' + JSON.stringify(state));
        // handlers can add info to the session state object
        this.emit('get', state, activeWindow);
        return state;
      },
      setNodeState: function (node, nodeState) {
        if (nodeState.p) {
          console.debug('     ...skipping protected node');
          return;
        }
        console.debug('     ...setting node type=' + nodeState.t + ' val=' + nodeState.v || nodeState.c);
        if (isTextType(nodeState.t) || nodeState.t == 'textarea') {
          //element is a textbox
          node.value = nodeState.v;
        } else if (nodeState.t == 'file') {
          // see: http://stackoverflow.com/questions/11780959/jquery-javascript-throws-error-the-operation-is-insecure-when-setting-value
          try {
            node.value = nodeState.v;
          } catch (e) {
            console.warn('Unable to set input file value: ' + nodeState.v);
          }
        } else if (nodeState.t == 'checkbox' || nodeState.t == 'radio') {
          //element is a checkbox or radiobox
          node.checked = nodeState.c;
        } else if (nodeState.t == 'select') {
          //element is a drop down list
          node.selectedIndex = nodeState.v;
          if (nodeState.m) {
            var optionState = nodeState.m;
            var optionNodes = node.options;
            if (optionNodes && optionNodes.length > 0) {
              baseArray.forEach(optionNodes, function (opts, index) {
                opts.selected = optionState[index];
              });
            }
          }
        } else if (nodeState.t == 'hidden' || nodeState.t == 'password' || nodeState.t == 'reset') {
        } else if (nodeState.t == DESIGN_MODE) {
          //type = designMode frame or node
          node.innerHTML = nodeState.v;
        } else if (nodeState.t == COMPLETE_DOM) {
          var iframeDoc = synchQuery.synchronizedWindow().document;
          // This is so evil...
          iframeDoc.open();
          iframeDoc.write(nodeState.v);
          iframeDoc.close();
        } else {
          //should not happen...
          console.debug('setNodeState: unknown type of element: [type=' + nodeState.t + ']');
        }
      },
      getNodeState: function (node) {
        var nodeState = {};
        var nodeName = node.nodeName.toLowerCase();
        if (synchQuery.isProtected(node)) {
          nodeState.p = true;
          //node is protected
          return nodeState;
        }
        if (nodeName == 'input') {
          nodeState.t = node.type;
          //t for type
          if (isTextType(node.type)) {
            //escape the text to prevent possible problems with e.g. & or ? characters
            //http://blogs.msdn.com/b/jscript/archive/2009/06/23/serializing-the-value-of-empty-dom-elements-using-native-json-in-ie8.aspx
            nodeState.v = val(node);  //synch.escape(node.value).replace(/'/g, "%27").replace(/"/g, "%22"); //v for value (value is the text of the field)
          } else if (node.type == 'checkbox' || node.type == 'radio') {
            nodeState.c = node.checked;  //v for value (value is true if selected; else false)
          }
        } else if (nodeName == 'select') {
          // single value select fields
          nodeState.t = 'select';
          //t for type
          nodeState.v = node.selectedIndex;
          //v for value (value is the selected index)
          // multi value select fields
          var m;
          if (node.multiple) {
            var optionNodes = node.options;
            if (optionNodes && optionNodes.length > 0) {
              m = [];
              baseArray.forEach(optionNodes, function (opt, index) {
                m[index] = opt.selected;
              });
            }
          }
          nodeState.m = m;
        } else if (nodeName == 'textarea') {
          nodeState.t = 'textarea';
          //t for type
          nodeState.v = val(node);  //v for value (value is the selected index)
        }
        return nodeState;
      },
      loadStateFromConfig: function () {
        var state = null;
        var base64EncodedState = config.initialState;
        if (base64EncodedState) {
          state = JSON.parse(base64.decode(base64EncodedState));
        }
        return state;
      },
      loadStateFromStorage: function () {
        var deferred = new Deferred();
        storage.getValue(STATE_STORAGE_KEY, function (state) {
          if (state) {
            state = JSON.parse(base64.decode(state));
          }
          deferred.resolve(state);
        });
        return deferred;
      },
      loadStateFromWindow: function (win, data) {
        var state;
        win = win || window;
        var windowData = data || win.name;
        if (windowData) {
          windowData = windowData.split('|', 2);
          if (windowData.length > 1) {
            win.name = windowData[0];
            try {
              state = windowData[1] ? JSON.parse(base64.decode(windowData[1])) : null;
            } catch (e) {
              console.warn('Error restoring session state from window.name:' + e);
              return null;
            }
            return state;
          }
        }
      },
      saveStateEncoded: function (activeWindow, ticketId, username, force) {
        var state = getState(activeWindow, ticketId, username, force);
        console.info('Getting encoded local state.');
        return base64.encode(JSON.stringify(state));
      },
      saveStateToStorage: function (activeWindow, ticketId, username, force) {
        try {
          var doc = activeWindow.document;
        } catch (e) {
          console.debug('Probably no page has been loaded in the iframe yet or there is a xss problem.');
          return false;
        }
        var state = getState(activeWindow, ticketId, username, force);
        var serializedState = JSON.stringify(state);
        console.info('Saving local state in storage: ' + serializedState);
        serializedState = base64.encode(serializedState);
        return storage.setValue(STATE_STORAGE_KEY, serializedState);
      },
      saveStateName: function (activeWindow, ticketId, username, force) {
        var completeState = getState(activeWindow, ticketId, username, force);
        console.info('Saving local state as cookie.');
        window.name = window.name + '|' + base64.encode(JSON.stringify(completeState));
        return completeState;
      },
      // in milliseconds
      getSessionDuration: function () {
        var duration = 1000;
        // default value
        if (typeof synchroniteConfig != 'undefined' && synchroniteConfig.duration && typeof synch !== 'undefined' && synch.creationDate) {
          var timeSinceReload = new Date().getTime() - synch.creationDate;
          duration = synchroniteConfig.duration + timeSinceReload;
          console.info('Server Ticket Session Duration: ' + parseInt(synchroniteConfig.duration / 1000, 10) + 'sec');
          console.info('Time Since Presenter Reload: ' + parseInt(timeSinceReload / 1000, 10) + 'sec');
        }
        return duration;
      },
      applyState: function (state, selector) {
        // WARN: Be careful, when accessing window.document. The page may have not been fully
        //       loaded yet. Early access will throw a security exception in chrome 30+.
        this.emit('set', state, selector);
        var synchronizedWindow = synchQuery.synchronizedWindow();
        var aWindow = null;
        try {
          if (selector && selector.frame) {
            aWindow = synchQuery.queryFrame(selector.frame);
          } else {
            aWindow = synchronizedWindow;
          }
        } catch (e) {
          if (typeof console != 'undefined') {
            console['error']('Failed to apply state. Access to window is probably denied.');
          }
          window.location.reload();
        }
        if (!aWindow) {
          if (typeof console != 'undefined') {
            console['error']('Failed to apply state. Access to window is probably denied.');
          }
          synchronizedWindow.location.reload();
        }
        if (synchronizedWindow == window) {
          // session has just ended and we need to restore cookies.
          var stateCookies = state.cookies;
          var needPageReload;
          if (!stateCookies && typeof synchroniteConfig != 'undefined' && synchroniteConfig.restoreDocumentCookies) {
            needPageReload = true;
            stateCookies = state.docCookies;
          }
          if (stateCookies) {
            needPageReload = setCookieState(aWindow.document, stateCookies) && needPageReload;
            if (needPageReload) {
              console.log('Die Seite wird nun neugeladenm, um den Warenkorb \nder Co-Browsing Sitzung wiederherstellen.');
              window.setTimeout(function () {
                // Delay so the synchroniteOnPageLoad Script has time to run
                window.location.reload();
              }, 20);
            }
          }
        }
        // if (config.lpPluginActive) {
        //     var lpVisitId = state.lpVisitId || synchronizedWindow.lpVisitId;
        //     if (lpVisitId) {
        //         window.lpVisitId = lpVisitId;
        //         //synchronizedWindow.lpVisitId = lpVisitId;
        //         config.lpVisitId = lpVisitId;
        //         config.useLPChatBackend = true;
        //     } else {
        //         console.warn("Liveperson Plugin is Active, but no lpVisitId was found :(");
        //     }
        // }
        var iframeURL = null;
        if (typeof synch != 'undefined') {
          if (state.storeEntries) {
            synch.store.putAll(state.storeEntries);
          }
          if (state.cacheKey) {
            console.warn('Loading page via cacheKey! (experimental)');
            synch.frameLoadedListeners.push(aspect.after(synch, 'synchroniteAllFramesLoaded', lang.hitch(this, setDOMState, state)));
            var redirectURL = baseUrl.addParam(state.url, 'cacheKey', state.cacheKey);
            redirectURL = baseUrl.toSynchroniteURL(redirectURL);
            synch.loadPage(redirectURL, aWindow, true);
            return;
          } else if (!state.url) {
            synch.loadPage(synch.inactivePage, aWindow, true);
            return;
          }
          try {
            iframeURL = baseUrl.fromSynchroniteURL(aWindow.location.href);
          } catch (e) {
            console.error('applyState: ', e);
          }
          if (iframeURL != state.url) {
            console.debug('applyState: Loading new page: ' + state.url);
            synch.frameLoadedListeners.push(aspect.after(synch, 'synchroniteAllFramesLoaded', lang.hitch(this, setDOMState, state)));
            synch.loadPage(baseUrl.toSynchroniteURL(state.url), aWindow, true);
            return;  //on(aWindow, "load", dojoLang.hitch(this, setDOMState, state.dom))
          }
        }
        iframeURL = baseUrl.fromSynchroniteURL(aWindow.location.href);
        console.debug('applyState: Loading page not required...');
        if (!synchWindow.isWindowInitialized(aWindow)) {
          console.debug('applyState: ...but the page has not fully loaded yet. Waiting for complete load...');
          on(aWindow, 'load', lang.hitch(this, setDOMState, state));
        } else {
          console.debug('applyState: ...and the page has fully loaded.');
          setDOMState(state);
        }
      }
    };
    return synchState;
  }(synchronite__base_query, synchronite_micro_dom, synchronite__base_cookie, synchronite__base_url, synchronite__base_window, dojo__base_lang, dojo_Deferred, dojo__base_url, synchronite_libs_sizzle, dojo_string, dojo__base_array, dojo_aspect, dojo_on, synchronite__base_base64, synchronite_constants_strings, synchronite_proxyless_storage);
  synchronite_integration_session = {
    ACCEPTED: 'sessionAccepted',
    REJECTED: 'sessionRejected',
    OFFERED: 'sessionOffered',
    DECLINED: 'sessionDeclined',
    REQUESTED: 'sessionRequested',
    START: 'sessionStart'
  };
  synchronite__base_session_link = function (xhr) {
    //PRIVATE
    var PRESENTER_PATH = 'present';
    var JOIN_PATH = 'join';
    var PROXYLESS_PATH = 'proxyless';
    var CALL_PATH = 'call';
    var OMIT_SLASHES = {};
    OMIT_SLASHES[JOIN_PATH] = 1;
    var win = window, config = win.synchroniteConfig;
    var getBaseURL = function (targetURL) {
      var protocol;
      var loc = win.location;
      if (targetURL) {
        protocol = targetURL.split('//')[0];
      } else {
        protocol = loc.protocol;
      }
      var syncHost = config && config.tenantHost || loc.host;
      var result = protocol + '//' + syncHost + '/';
      return result;
    };
    var getWebAgentLink = function (ticket, username, master, profile, getAsRelativeUrl) {
      var path = '';
      if (profile === 'video-call' || profile === 'voice-call') {
        path += CALL_PATH;
      } else {
        path += PROXYLESS_PATH;
      }
      if (ticket) {
        path += '?ticket=' + ticket;
      }
      if (username) {
        path += '&username=' + encodeURIComponent(username);
      }
      if (master) {
        path += '&sendState=true';
      }
      if (profile) {
        path += '&profile=' + profile;
      }
      if (getAsRelativeUrl) {
        return '/' + path;
      } else {
        return getBaseURL() + path;
      }
    };
    var createSessionLink = function (profile, ticket, targetURL, username, chat, locale) {
      var path = '';
      if (profile) {
        path += profile;
        if (!OMIT_SLASHES[profile]) {
          profile += '/';
        }
      }
      if (ticket) {
        path += '?ticket=' + ticket;
      }
      if (username) {
        path += '&username=' + encodeURIComponent(username);
      }
      if (chat === false) {
        path += '&chat=0';
      }
      if (locale) {
        path += '&locale=' + locale;
      }
      if (targetURL) {
        path += '&targetURL=' + targetURL;
      }
      var oauthRequired = typeof synchroniteConfig != 'undefined' && synchroniteConfig.requireAuthorization;
      if (oauthRequired) {
        var result;
        xhr.get('/invitation', {
          sync: true,
          query: { path: path },
          handleAs: 'json'
        }).then(function (data) {
          result = data.url;
        }, function (data) {
          console.error('Error generating invitation: ' + data.message);
        });
        return result;
      } else {
        return getBaseURL(targetURL) + path;
      }
    };
    //PUBLIC
    var sessionLink = {
      init: function (cfg) {
        config = cfg;
      },
      getPresenterLink: function (ticket) {
        return createSessionLink(PRESENTER_PATH, ticket);
      },
      getJoinLink: function (ticket) {
        return createSessionLink(JOIN_PATH, ticket);
      },
      getWebAgentLink: getWebAgentLink,
      getLink: createSessionLink
    };
    return sessionLink;
  }(dojo_request_xhr);
  synchronite__base_page_visibility = function (on, aspect) {
    var after = aspect.after;
    var doc = document, win = window;
    var hiddenProperty, visibilityChangeEvent, isHidden = false;
    var init = function () {
      if (typeof doc.hidden !== 'undefined') {
        hiddenProperty = 'hidden';
        visibilityChangeEvent = 'visibilitychange';
      } else if (typeof doc.mozHidden !== 'undefined') {
        hiddenProperty = 'mozHidden';
        visibilityChangeEvent = 'mozvisibilitychange';
      } else if (typeof doc.msHidden !== 'undefined') {
        hiddenProperty = 'msHidden';
        visibilityChangeEvent = 'msvisibilitychange';
      } else if (typeof doc.webkitHidden !== 'undefined') {
        hiddenProperty = 'webkitHidden';
        visibilityChangeEvent = 'webkitvisibilitychange';
      }
      if (isSupported()) {
        isHidden = doc[hiddenProperty];
      }
      registerVisibilityChangeHandler();
    };
    var isSupported = function () {
      return typeof hiddenProperty !== 'undefined';
    };
    var onShow = function () {
      isHidden = false;
      pageVisibility.emit('show');
    };
    var onHide = function () {
      isHidden = true;
      pageVisibility.emit('hide');
    };
    var registerVisibilityChangeHandler = function () {
      try {
        /*if no native page visibility support found..*/
        if (isSupported()) {
          on(doc, visibilityChangeEvent, function () {
            if (doc[hiddenProperty] === true) {
              onHide();
            } else {
              onShow();
            }
          });
        } else {
          /*switch support based on prefix*/
          on(win, 'focus', onShow);
          on(win, 'blur', onHide);  //TEST: USE FOR IE:
                                    //     this.q.attachEvent('onfocusin', this._visible);
                                    //     this.q.attachEvent('onfocusout', this._hidden);
        }
      } catch (e) {
      }
    };
    var pageVisibility = {
      emit: function (type, event) {
        var args = [this];
        args.push.apply(args, arguments);
        return on.emit.apply(on, args);
      },
      on: function (type, listener) {
        return on.parse(this, type, listener, function (target, type) {
          return after(target, 'on' + type, listener, true);
        });
      },
      isVisible: function () {
        return !isHidden;
      },
      isHidden: function () {
        return isHidden;
      }
    };
    init();
    return pageVisibility;
  }(dojo_on, dojo_aspect);
  synchronite__base_locale = function () {
    // summary: get the locale of the current document or the locale
    //          forced via synchronite configuration.
    // 1. Check if locale is explicitly specified.
    if (typeof synchroniteConfig != 'undefined' && synchroniteConfig.locale) {
      return synchroniteConfig.locale;
    }
    // 2. Check if locale is specified inside html document
    // description: see http://www.w3.org/TR/2014/NOTE-WCAG20-TECHS-20140311/H57
    var LANG_ATTR = 'lang';
    var doc = document;
    var html = doc.documentElement;
    var body = doc.body || doc.getElementsByTagName('body')[0];
    return html && html.getAttribute(LANG_ATTR) || body && body.getAttribute(LANG_ATTR);
  };
  // Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
  // This work is free. You can redistribute it and/or modify it
  // under the terms of the WTFPL, Version 2
  // For more information see LICENSE.txt or http://www.wtfpl.net/
  //
  // For more information, the home page:
  // http://pieroxy.net/blog/pages/lz-string/testing.html
  //
  // LZ-based compression algorithm, version 1.4.4
  var LZString = function () {
    // private property
    var f = String.fromCharCode;
    var keyStrBase64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var keyStrUriSafe = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$';
    var baseReverseDic = {};
    function getBaseValue(alphabet, character) {
      if (!baseReverseDic[alphabet]) {
        baseReverseDic[alphabet] = {};
        for (var i = 0; i < alphabet.length; i++) {
          baseReverseDic[alphabet][alphabet.charAt(i)] = i;
        }
      }
      return baseReverseDic[alphabet][character];
    }
    var LZString = {
      compressToBase64: function (input) {
        if (input == null)
          return '';
        var res = LZString._compress(input, 6, function (a) {
          return keyStrBase64.charAt(a);
        });
        switch (res.length % 4) {
        // To produce valid Base64
        default:
        // When could this happen ?
        case 0:
          return res;
        case 1:
          return res + '===';
        case 2:
          return res + '==';
        case 3:
          return res + '=';
        }
      },
      decompressFromBase64: function (input) {
        if (input == null)
          return '';
        if (input == '')
          return null;
        return LZString._decompress(input.length, 32, function (index) {
          return getBaseValue(keyStrBase64, input.charAt(index));
        });
      },
      compressToUTF16: function (input) {
        if (input == null)
          return '';
        return LZString._compress(input, 15, function (a) {
          return f(a + 32);
        }) + ' ';
      },
      decompressFromUTF16: function (compressed) {
        if (compressed == null)
          return '';
        if (compressed == '')
          return null;
        return LZString._decompress(compressed.length, 16384, function (index) {
          return compressed.charCodeAt(index) - 32;
        });
      },
      //compress into uint8array (UCS-2 big endian format)
      compressToUint8Array: function (uncompressed) {
        var compressed = LZString.compress(uncompressed);
        var buf = new Uint8Array(compressed.length * 2);
        // 2 bytes per character
        for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
          var current_value = compressed.charCodeAt(i);
          buf[i * 2] = current_value >>> 8;
          buf[i * 2 + 1] = current_value % 256;
        }
        return buf;
      },
      //decompress from uint8array (UCS-2 big endian format)
      decompressFromUint8Array: function (compressed) {
        if (compressed === null || compressed === undefined) {
          return LZString.decompress(compressed);
        } else {
          var buf = new Array(compressed.length / 2);
          // 2 bytes per character
          for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
            buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
          }
          var result = [];
          buf.forEach(function (c) {
            result.push(f(c));
          });
          return LZString.decompress(result.join(''));
        }
      },
      //compress into a string that is already URI encoded
      compressToEncodedURIComponent: function (input) {
        if (input == null)
          return '';
        return LZString._compress(input, 6, function (a) {
          return keyStrUriSafe.charAt(a);
        });
      },
      //decompress from an output of compressToEncodedURIComponent
      decompressFromEncodedURIComponent: function (input) {
        if (input == null)
          return '';
        if (input == '')
          return null;
        input = input.replace(/ /g, '+');
        return LZString._decompress(input.length, 32, function (index) {
          return getBaseValue(keyStrUriSafe, input.charAt(index));
        });
      },
      compress: function (uncompressed) {
        return LZString._compress(uncompressed, 16, function (a) {
          return f(a);
        });
      },
      _compress: function (uncompressed, bitsPerChar, getCharFromInt) {
        if (uncompressed == null)
          return '';
        var i, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = '', context_wc = '', context_w = '', context_enlargeIn = 2,
          // Compensate for the first entry which should not count
          context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
        for (ii = 0; ii < uncompressed.length; ii += 1) {
          context_c = uncompressed.charAt(ii);
          if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
            context_dictionary[context_c] = context_dictSize++;
            context_dictionaryToCreate[context_c] = true;
          }
          context_wc = context_w + context_c;
          if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
            context_w = context_wc;
          } else {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 8; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 16; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            // Add wc to the dictionary.
            context_dictionary[context_wc] = context_dictSize++;
            context_w = String(context_c);
          }
        }
        // Output the code for w.
        if (context_w !== '') {
          if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
            if (context_w.charCodeAt(0) < 256) {
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
              }
              value = context_w.charCodeAt(0);
              for (i = 0; i < 8; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            } else {
              value = 1;
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = 0;
              }
              value = context_w.charCodeAt(0);
              for (i = 0; i < 16; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            delete context_dictionaryToCreate[context_w];
          } else {
            value = context_dictionary[context_w];
            for (i = 0; i < context_numBits; i++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
        }
        // Mark the end of the stream
        value = 2;
        for (i = 0; i < context_numBits; i++) {
          context_data_val = context_data_val << 1 | value & 1;
          if (context_data_position == bitsPerChar - 1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }
        // Flush the last char
        while (true) {
          context_data_val = context_data_val << 1;
          if (context_data_position == bitsPerChar - 1) {
            context_data.push(getCharFromInt(context_data_val));
            break;
          } else
            context_data_position++;
        }
        return context_data.join('');
      },
      decompress: function (compressed) {
        if (compressed == null)
          return '';
        if (compressed == '')
          return null;
        return LZString._decompress(compressed.length, 32768, function (index) {
          return compressed.charCodeAt(index);
        });
      },
      _decompress: function (length, resetValue, getNextValue) {
        var dictionary = [], next, enlargeIn = 4, dictSize = 4, numBits = 3, entry = '', result = [], i, w, bits, resb, maxpower, power, c, data = {
            val: getNextValue(0),
            position: resetValue,
            index: 1
          };
        for (i = 0; i < 3; i += 1) {
          dictionary[i] = i;
        }
        bits = 0;
        maxpower = Math.pow(2, 2);
        power = 1;
        while (power != maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }
        switch (next = bits) {
        case 0:
          bits = 0;
          maxpower = Math.pow(2, 8);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          c = f(bits);
          break;
        case 1:
          bits = 0;
          maxpower = Math.pow(2, 16);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          c = f(bits);
          break;
        case 2:
          return '';
        }
        dictionary[3] = c;
        w = c;
        result.push(c);
        while (true) {
          if (data.index > length) {
            return '';
          }
          bits = 0;
          maxpower = Math.pow(2, numBits);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          switch (c = bits) {
          case 0:
            bits = 0;
            maxpower = Math.pow(2, 8);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            dictionary[dictSize++] = f(bits);
            c = dictSize - 1;
            enlargeIn--;
            break;
          case 1:
            bits = 0;
            maxpower = Math.pow(2, 16);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            dictionary[dictSize++] = f(bits);
            c = dictSize - 1;
            enlargeIn--;
            break;
          case 2:
            return result.join('');
          }
          if (enlargeIn == 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
          }
          if (dictionary[c]) {
            entry = dictionary[c];
          } else {
            if (c === dictSize) {
              entry = w + w.charAt(0);
            } else {
              return null;
            }
          }
          result.push(entry);
          // Add w+entry[0] to the dictionary.
          dictionary[dictSize++] = w + entry.charAt(0);
          enlargeIn--;
          w = entry;
          if (enlargeIn == 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
          }
        }
      }
    };
    return LZString;
  }();
  if (true) {
    synchronite_libs_lz_string = function () {
      return LZString;
    }();
  } else if (typeof module !== 'undefined' && module != null) {
    module.exports = LZString;
  }
  synchronite_cometd_LargeMessageExtension = function (has, sniff, lzString) {
    var _cometd;
    function _getMaxCallbackPollingSize() {
      // The maximum size of a cometd message minus the data field
      // (Domain name and query parameters add up to hundreds of bytes)
      var ENVELOPE_SIZE = 1000;
      // The maximum URL size per browser determines the maximum size of callback-polling messages.
      //
      // 1. http://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers
      // 2. http://stackoverflow.com/questions/3721034/how-long-an-url-can-internet-explorer-9-take
      // 3. https://support.microsoft.com/en-us/kb/208427/en-us
      var MAX_URL_IE8 = 2000,
        // 2083 is the maximum URL length for GET requests in Internet Explorer 8
        MAX_URL_IE9 = 5000,
        // 5120 is the maximum URL length for GET requests in Internet Explorer 9
        MAX_URL_OTHER = 5000;
      var maxSize = MAX_URL_OTHER;
      if (has('ie') == 8) {
        maxSize = MAX_URL_IE8;
      } else if (has('ie') == 9) {
        maxSize = MAX_URL_IE9;
      }
      maxSize -= ENVELOPE_SIZE;
      // Better be on the safe side (Domain name and query parameters add up to hundreds of bytes)
      return maxSize;
    }
    var MAX_CHUNK_SIZE_DEFAULT = 1000, MAX_CHUNK_SIZE_WEBSOCKET = 1024 * 30,
      // maxMessageSize = 65520 -> http://docs.cometd.org/reference/java_server.html
      MAX_CHUNK_SIZE_LONGPOLLING = 1024 * 50,
      // 50KB
      MAX_CHUNK_SIZE_CALLBACKPOLLING = _getMaxCallbackPollingSize();
    var COMPRESS_IF_LARGER = 10 * 1024;
    // Always compress messages exceeding compression threshold
    var _chunkMap = {};
    var _getMaxMessageSize = function (currentTransport) {
        if (currentTransport == 'websocket') {
          return MAX_CHUNK_SIZE_WEBSOCKET;
        } else if (currentTransport == 'long-polling') {
          return MAX_CHUNK_SIZE_LONGPOLLING;
        } else if (currentTransport == 'callback-polling') {
          return MAX_CHUNK_SIZE_CALLBACKPOLLING;
        }
        return MAX_CHUNK_SIZE_DEFAULT;
      }, _splitAndEncodeText = function (text, maxChunkSize) {
        // NOTE: We must base64 encode the json string otherwise when splitting the string
        //       JS will automatically inject escape characters, thus increasing the string size.
        var encodedText = lzString.compressToEncodedURIComponent(text);
        console.debug('LargeMessageExtension: Compressed from ' + Math.round(text.length / 1024) + 'kb to ' + Math.round(encodedText.length / 1024) + 'kb (' + Math.round(encodedText.length / text.length * 100) + '%)');
        var chunks = [];
        var n = Math.floor(encodedText.length / maxChunkSize) + 1;
        var last = 0;
        for (var i = 0; i < n; i++) {
          chunks[i] = encodedText.substr(last, maxChunkSize);
          last += maxChunkSize;
        }
        return chunks;
      }, _chunksComplete = function (id, n) {
        var chunks = _chunkMap[id];
        for (var i = 0; i < n; i++) {
          if (!chunks[i]) {
            return false;
          }
        }
        return true;
      };
    var largeMessageExt = {
      COMPRESS_IF_LARGER: COMPRESS_IF_LARGER,
      registered: function (name, cometd) {
        // Store the cometd object reference
        _cometd = cometd;
      },
      outgoing: function (message) {
        if (!message.data || /^\/meta\//.test(message.channel)) {
          // Do not mess with meta messages
          return message;
        }
        if (message.data && message.data.type === 'chunk') {
          // Ignore messages that are already compressed
          return message;
        }
        var jsonMessage = JSON.stringify(message), currentTransport = _cometd.getTransport().toString();
        if (currentTransport === 'callback-polling') {
          jsonMessage = encodeURI(jsonMessage);
        }
        var size = jsonMessage.length, maxSizeForTransport = _getMaxMessageSize(currentTransport),
          /* substract 400 for the metadata we attach */
          maxSizeData = Math.min(maxSizeForTransport, COMPRESS_IF_LARGER), maxSizeChunk = maxSizeForTransport - 400;
        if (size >= maxSizeData) {
          // Log the long poll
          var chunkID = +new Date();
          console.info('LargeMessageExtension: Message "' + chunkID + ' is too large (' + size + '>' + maxSizeData + ') for transport ' + _cometd.getTransport().toString() + ' or exceeds defined threshold.');
          var timeStart = new Date().getTime(), splitted = _splitAndEncodeText(JSON.stringify(message), maxSizeChunk), timeTotal = new Date().getTime() - timeStart;
          if (timeTotal > 300) {
            console.warn('LargeMessageExtension: Detected slow parsing of a message. Took "' + timeTotal + 'ms\'');
          } else {
            console.debug('LargeMessageExtension: Parsing of a message. Took "' + timeTotal + 'ms\'');
          }
          timeStart = new Date().getTime();
          var cometdConfigCopy = _cometd.getConfiguration();
          // get a copy of the cometd config
          if (cometdConfigCopy.autoBatch) {
            _cometd.configure({ autoBatch: false });  // will be mixed into the existing config
          }
          var lastMessagesSent = function () {
            timeTotal = new Date().getTime() - timeStart;
            console.debug('LargeMessageExtension:  Sending of all chunks took "' + timeTotal + 'ms\'');
            // reset config autoBatch. timeout ensures that all messages have been sent.
            setTimeout(function () {
              if (cometdConfigCopy.autoBatch) {
                _cometd.configure({ autoBatch: true });  // will be mixed into the existing config
              }
            }, 1);
          };
          for (var index = 0; index < splitted.length; ++index) {
            var data = {
              type: 'chunk',
              i: index,
              n: splitted.length,
              id: chunkID,
              d: splitted[index]
            };
            if (!_cometd.isDisconnected()) {
              console.info('Sending \'' + chunkID + '\' chunk ' + (index + 1) + '/' + splitted.length + ' dataSize \'' + JSON.stringify(data).length + '\'');
              if (index == splitted.length - 1) {
                _cometd.publish(message.channel, data, lastMessagesSent);  // last message
              } else {
                _cometd.publish(message.channel, data);
              }
            }
          }
          // http://docs.cometd.org/reference/extensions.html#extensions_writing
          // If the extension method returns null, the processing should stop: other extensions do not process the
          // message, and CometD does not further process it. CometD does not send the message to the server,
          // nor notify listeners.
          return null;
        }
        return message;
      },
      incoming: function (message) {
        var data = message.data;
        if (data && data.type === 'chunk') {
          var id = data.id;
          var chunks = _chunkMap[id] || [];
          chunks[data.i] = data.d;
          _chunkMap[id] = chunks;
          if (_chunksComplete(id, data.n)) {
            var mergedChunks = chunks.join('');
            var largeMessage = JSON.parse(lzString.decompressFromEncodedURIComponent(mergedChunks));
            message.data = largeMessage.data;
            delete _chunkMap[id];
            return message;
          }
          return null;  // dismiss all chunk index messages
        }
      },
      getMaxMessageSize: _getMaxMessageSize
    };
    return largeMessageExt;
  }(dojo_has, dojo_sniff, synchronite_libs_lz_string);
  synchronite_integration_io = function (string, has, on, aspect, Deferred, cometd, cometdReloadLP, baseUnload, lang, baseArray, visitorCommon, synchState, base64, DojoURL, session, sessionLink, pageVisibility, getLocale, baseUrl, microDom, LargeMessageExtension) {
    var after = aspect.after;
    /******************************************
     * Private Methods
     * ****************************************/
    var STEP_SUPPORT_UNAVAILABLE = -1, STEP0 = 0, STEP1 = 1, STEP2 = 2, STEP3 = 3;
    var STATE_NOTHING = 0, STATE_REQUESTED = 1, STATE_OFFERED = 2, STATE_ACCEPTED = 3;
    var config = synchroniteConfig;
    var cometSubscriptions = [];
    var handshakeListener = null;
    var connectListener = null;
    var _enodeUserParam = function (param) {
      if (param) {
        return encodeURIComponent(param);
      } else {
        return null;
      }
    };
    has.add('html5-cors', function (win, doc, element) {
      // see: https://raw.github.com/Modernizr/Modernizr/master/feature-detects/cors.js
      return 'XMLHttpRequest' in win && 'withCredentials' in new XMLHttpRequest();
    });
    var CHANNEL_USERS,
      // publish and subscribe
      CHANNEL_AGENTS,
      // publish but no subscribe
      CHANNEL_SERVICE;
    var main, visitorInfo;
    /* This method initializes the comet service. */
    var initializeComet = function (_main, _visitorInfo) {
        var promise = new Deferred();
        console.debug('comet Start the comet service and subscribe channels.');
        var tenantId = config.tenantId;
        CHANNEL_USERS = '/u/' + tenantId;
        // publish and subscribe
        CHANNEL_AGENTS = '/a/' + tenantId;
        // publish but no subscribe
        CHANNEL_SERVICE = '/service/integration/' + tenantId;
        main = _main;
        visitorInfo = _visitorInfo;
        //initilize the comet service for continuous updates
        //initialize cometd
        //configure and handshake is 2.0 replacement for init
        cometd.ackEnabled = false;
        //the url to the comet service
        var protocol = 'https:';
        var serverUrl = protocol + '//' + config.cometUrl;
        var URL_TO_SERVLET_COMET = serverUrl + '/sync';
        // Enable CORS in IE8
        // http://bugs.cometd.org/browse/COMETD-267
        // xhrPlugins.addCrossSiteXhr(serverUrl);
        cometd.configure({
          url: URL_TO_SERVLET_COMET,
          logLevel: 'info',
          //"warn", "info", "debug"
          autoBatch: true,
          //TEST
          maxNetworkDelay: 15000,
          maxBackoff: 30000
        });
        cometd.onListenerException = function (exception, subscriptionHandle, isListener, cometdMessage) {
          // Uh-oh, something went wrong, disable this listener/subscriber
          // Object "this" points to the CometD object
          //            if (isListener)
          //                removeListener(subscriptionHandle);
          //            else
          //                unsubscribe(subscriptionHandl
          //                e);
          console.error(exception);
          console.error('exception.name: ' + exception.name);
          console.error('exception.category: ' + exception.category);
          console.error('exception.message: ' + exception.message);
          console.warn('exception.trace: ' + exception.trace);
          console.error('exception.description: ' + exception.description);
          console.error('subscriptionHandle:' + subscriptionHandle);
          console.error('cometdMessage: ' + cometdMessage);
        };
        cometConnect.onSuccessfulHandshake.push(promise);
        // comet reload is needed to detect comet sessions across page loads.
        cometdReloadLP.configure({
          cookieName: 's.connect',
          cookieMaxAge: 40,
          cookieDomain: baseUrl.getHostWithoutSubdomains()
        });
        //must be scoped
        handshakeListener = cometd.addListener('/meta/handshake', _handleHandshake);
        connectListener = cometd.addListener('/meta/connect', _metaConnect);
        var isSafari13 = has('safari') === 13;
        // see CC-1775. Remove once safari bug is fixed.
        if (synchroniteConfig.disableWebsockets || isSafari13) {
          cometd.unregisterTransport('websocket');
          cometd.websocketEnabled = false;
        }
        cometd.registerExtension('largeMessage', LargeMessageExtension);
        cometd.handshake();
        //disconnect from the comet service when the page unloads
        if (has('ie') === 9 || has('ie') === 10) {
          microDom.addEvent(window, 'unload', _handleWinUnload);
        } else {
          microDom.addEvent(window, 'beforeunload', _handleWinUnload);
        }
        return promise;
      }, getCommonDomain = function () {
        var hostDomain = window.location.host;
        //document.domain;
        var synchroniteDomain = config.tenantHost;
        //(new DojoURL(config.serverUrl)).host;
        for (var i = 0; i < hostDomain.length; i++) {
          if (hostDomain.lastIndexOf(synchroniteDomain.substring(i)) != -1) {
            return synchroniteDomain.indexOf('.', i) == i ? synchroniteDomain.substring(i + 1) : synchroniteDomain.substring(i);
          }
        }
        return null;
      },
      /* this method gets all cookies of the domain
       * @return all cookies as {name, value} array/map */
      getAllCookies = function () {
        var cookies = {};
        //cookies are visible to host server (up-to-date)
        var documentCookies = document.cookie.split(';');
        baseArray.forEach(documentCookies, function (oneEntry) {
          var name, value = '';
          // FIXED: Limit number of splits since, cookie value might
          // contain "=" which might be cut off.
          var i = oneEntry.indexOf('=');
          if (i == -1) {
            name = oneEntry;
          } else {
            name = oneEntry.substring(0, i);
            value = oneEntry.substring(i + 1);
          }
          //trim key, so the key is without leading whitespace (if one was existing)
          name = string.trim(name);
          if (/^(cometd|synchronite|s\.)/.test(name) || name.length === 0) {
            return;
          }
          cookies[name] = { v: value };  //encodeURIComponent(unescape(value));
        });
        //cookies are visible to host server (may not be up-to-date)
        var httpToken = config.httpToken;
        if (httpToken) {
          baseArray.forEach(httpToken, function (name) {
            //trim key, so the key is without leading whitespace (if one was existing)
            name = string.trim(name);
            if (/^(cometd|synchronite|s\.)/.test(name) || name.length === 0) {
              return;
            }
            // cookie already exists => is visible across domains, mark cookie
            // returns null if there is no common domain
            var commonDomain = getCommonDomain();
            if (commonDomain && cookies[name]) {
              // only add cookie if the synchronite server
              // and the current document location's hostname
              // have a common domain.
              cookies[name].d = '.' + commonDomain;
            }
          }, this);
        }
        return cookies;  //return them
      }, _multipleClients, _showSignal, _onPageShown = function () {
        // FIXME?: During Startup Multiple Handshakes may occur.
        //        So we need to check, that comet is disconnected AND
        //        NOT currently handshaking before performing another handshake.
        cometd.handshake();
        //reconnect comet
        if (_showSignal) {
          _showSignal.remove();
        }
        _showSignal = null;
      }, _hideSignal, _onPageHide = function () {
        if (_multipleClients) {
          if (_hideSignal) {
            _hideSignal.remove();
          }
          _hideSignal = null;
          _multipleWindowsVisible = false;
          _disconnectAndReconnectWhenPageIsShown();
          _multipleClients = false;
        }
      }, _multipleWindowsVisible, _disconnectAndReconnectWhenPageIsShown = function () {
        if (pageVisibility.isHidden()) {
          _disconnectComet();
          if (!_showSignal) {
            _showSignal = pageVisibility.on('show', _onPageShown);
          }  //document.title = "DISCONNECTED|HIDDEN";
        } else {
          //document.title = "CONNECTED|SHOWN";
          console.warn('There are two windows visible which both have an active comet connection!');
          _multipleWindowsVisible = true;
          if (!_hideSignal) {
            _hideSignal = pageVisibility.on('hide', _onPageHide);
          }
        }
      }, _publishDisconnectAdvice = function () {
        var channel = CHANNEL_USERS + '/' + visitorInfo.id();
        cometd.publish(channel, { action: 'disconnectWhenHidden' });
      }, _agentStatusPromise, _checkAgentStatus = function () {
        //check again if the support is available
        console.debug('checkAgentStatus (comet)');
        if (_agentStatusPromise) {
          // There's already a status check in progress
          return _agentStatusPromise;
        }
        _agentStatusPromise = new Deferred();
        // Will be resolved by handleMethod
        window.setTimeout(function () {
          // Autofail status check after timeout
          if (_agentStatusPromise) {
            _agentStatusPromise.reject('timeout occurred. sever unavailable. press f5 to refresh');
          }
        }, 7500);
        var msg = { action: 'isSupportAvailable' };
        cometd.publish(CHANNEL_SERVICE, msg);
        console.debug('Publishing via ' + CHANNEL_SERVICE + ':' + JSON.stringify(msg));
        return _agentStatusPromise;
      }, _connectionInitialized = function () {
        _unsubscribeChannels();
        _subscribeChannels();
        if (config.checkAgentAvailability) {
          //check if support is currently provided
          _checkAgentStatus().then(function (status) {
            console.log('_checkAgentStatus callback: ' + status);
          });
        }
        console.debug('Initializing cometd done.');
      }, _connectionClosed = function () {
        console.info('Comet connection closed');
      }, _connectionBroken = function () {
        console.warn('Comet connection broken');
      }, _connectionEstablished = function () {
        console.info('Comet connection established clientId: ' + cometd.getClientId());
        _publishUserInfo();
        cometd.setReloadCookie();
      }, _connected = false, _metaConnect = function (msg) {
        if (msg.successful) {
          var advice = msg.advice;
          if (advice) {
            if (advice['multiple-clients']) {
              _multipleClients = true;
              console.info('Multiple clients (tabs) detected.');
              if (pageVisibility.isHidden()) {
                // disconnect if the page is not visible
                console.warn('Disconnecting this tab, because it is NOT visible.');
                _disconnectAndReconnectWhenPageIsShown();
              } else {
                if (_multipleWindowsVisible) {
                  console.info('Still multiple clients. We do not ask others to disconnect, because the multiple windows are visible.');
                } else {
                  _publishDisconnectAdvice();
                  console.info('We keep this tab connected, because it is visible. But we ask other hidden tabs to disconnect.');
                }
              }
            }
          }
        }
        if (cometd.isDisconnected()) {
          _connected = false;
          _connectionClosed();
          return;
        }
        var wasConnected = _connected;
        _connected = msg.successful === true;
        if (!wasConnected && _connected) {
          _connectionEstablished();
        } else if (wasConnected && !_connected) {
          _connectionBroken();
        }
      }, _resolveHandshakePromises = function () {
        var length = cometConnect.onSuccessfulHandshake.length;
        if (length > 0) {
          console.info('comet Resolving ' + cometConnect.onSuccessfulHandshake.length + ' promises.');
          for (var i = 0; i < length; i++) {
            cometConnect.onSuccessfulHandshake[i].resolve(cometConnect);
          }
          cometConnect.onSuccessfulHandshake = [];
        } else {
          console.info('comet No onSuccessfulHandshake promises to be resolved.');
        }
      }, _handleHandshake = function (msg) {
        if (msg.successful) {
          //document.title = "CONNECTED";
          _multipleClients = false;
          console.debug('Comet Handshake successful.');
          _connectionInitialized();
          // Timeout allows cometd.subscribe() messages to leave the browser (might be auto batched)
          // before resolve handshake promises.
          setTimeout(_resolveHandshakePromises, 100);  // cometd.reload({reloading: false});
        }
      }, _publishSessionDeclinedToUserChannel = function () {
        // summary: Publishes a message to all visitors with visitorId that the session has been
        //          declined. This is used in case one visitor has multiple tabs opened.
        //
        //          In that case the support dialog should be closed in all other tabs and in case
        //          the user has not currently focused the session window, he should be notified.
        var visitorId = visitorInfo.id();
        var channel = CHANNEL_USERS + '/' + visitorId;
        window['s-session-declined'] = true;
        // Used for tracking
        var info = visitorInfo.event();
        info.agentAlias = visitorInfo.connectedAgentAlias;
        main.emit(session.DECLINED, info);
        cometd.publish(channel, { action: session.DECLINED });
      }, _publishSessionAccepted = function () {
        // summary: Publishes a message to all visitors with visitorId that the session is about
        //          to start. This is used in case one visitor has multiple tabs opened.
        //
        //          In that case the support dialog should be closed in all other tabs and in case
        //          the user has not currently focused the session window, he should be notified.
        var visitorId = visitorInfo.id();
        var channel = CHANNEL_USERS + '/' + visitorId;
        window['s-session-accepted'] = true;
        cometd.publish(channel, { action: session.ACCEPTED });
        // Used for tracking
        var info = visitorInfo.event();
        info.agentAlias = visitorInfo.connectedAgentAlias;
        main.emit(session.ACCEPTED, info);
      },
      /* this method request support */
      publishSupportRequest = function (params) {
        // summary: Sends a support request to an agent. Depending on the params the request is
        //          a full co-browsing request or request a chat only ({chatOnly: true}).
        console.log('integration/io - publishSupportRequest');
        var supportId = 'reactive-' + new Date().getTime() + '-' + Math.floor(Math.random() * 5000000);
        var serviceId;
        cometConnect.state = STATE_REQUESTED;
        var eventInfo = visitorInfo.event();
        var msg = {
          action: 'requestSupport',
          user: visitorInfo.allInfo(),
          tA: visitorInfo.termsAccepted(),
          supportId: supportId,
          type: 'cobrowse'
        };
        if (params) {
          msg = lang.mixin(msg, params);
          // params.type
          serviceId = params.sI || params.serviceId || params.agentServiceId;
        }
        if (serviceId) {
          eventInfo.agentServiceId = serviceId;
          visitorInfo.agentServiceId = serviceId;
          // need to store this for httponlyadapter
          msg.sI = serviceId;
        }
        main.emit(session.REQUESTED, eventInfo);
        cometd.publish(CHANNEL_SERVICE, msg);
        visitorInfo.supportId(supportId);
        console.debug('comet Published to ' + CHANNEL_SERVICE + ' action: \'publishSupportRequest\'');
      }, _subscribeChannels = function () {
        // 1. Subscribe to the specific/individual channel for this web visitor
        var userChannel = CHANNEL_USERS + '/' + visitorInfo.id();
        console.info('Subscribing User Channel: ' + userChannel);
        cometSubscriptions.push(cometd.subscribe(userChannel, lang.hitch(this, _handleUser)));
        cometSubscriptions.push(cometd.subscribe(CHANNEL_SERVICE, lang.hitch(this, _handleService)));
        cometSubscriptions.push(cometd.subscribe(CHANNEL_USERS, lang.hitch(this, _handleUsers)));
      }, _unsubscribeChannels = function () {
        baseArray.forEach(cometSubscriptions, function (item) {
          if (item) {
            //not null
            cometd.unsubscribe(item);
          }
        });
        cometSubscriptions = [];
        if (_hideSignal) {
          _hideSignal.remove();
        }
        if (_showSignal) {
          _showSignal.remove();
        }
      }, _cometCleanup = function () {
        console.log('remove cometd listeners in io.js');
        _unsubscribeChannels();
        cometd.removeListener(handshakeListener);
        cometd.removeListener(connectListener);
      }, _handleUsers = function (msg) {
        // receives messages that are intended for all users
        var data = msg.data;
        if (data.action) {
          //if the clients gets a message with the action
          if (data.action === 'updateIsSupportAvailable') {
            if (_agentStatusPromise) {
              _agentStatusPromise.resolve({ availability: data.isSupportAvailable });
              _agentStatusPromise = null;
            }
            cometConnect.emit('statusChange', { availability: data.isSupportAvailable });
          }
        }
      }, _handleUser = function (msg) {
        // receives messages that are intended for this user only
        var data = msg.data;
        var info;
        var action = data.action;
        if (action !== null) {
          //if the clients get a message with the action
          //'offerSupport' open die support dialog
          var agentAlias = data.aA;
          //Agent Alias
          var supportId = data.supportId;
          if (action == 'disconnectWhenHidden') {
            console.info('Received info that there are multiple clients.');
            _multipleClients = true;
            _disconnectAndReconnectWhenPageIsShown();
          } else if (action == 'offerSupport') {
            cometConnect.state = STATE_OFFERED;
            //was offered support
            console.debug(agentAlias + ' offers support.');
            // Save as global reference
            visitorInfo.connectedAgentAlias = agentAlias;
            visitorInfo.supportId(supportId);
            info = visitorInfo.event();
            info.agentAlias = agentAlias;
            info.type = data.type;
            main.emit(session.OFFERED, info);
          } else if (action == 'rejectOffer') {
            visitorInfo.connectedAgentAlias = null;
            info = visitorInfo.event();
            info.agentAlias = agentAlias;
            main.emit(session.REJECTED, info);
            if (main.supportDialog) {
              main.supportDialog.prepare(STEP_SUPPORT_UNAVAILABLE);
            }
            cometConnect.state = STATE_NOTHING;
          } else if (action == session.ACCEPTED) {
            // Close Support dialog.
            if (window['s-session-accepted']) {
              window['s-session-accepted'] = false;
              console.debug('The session was accepted in this tab');
            } else {
              console.debug('The session was accepted in another tab');
            }
            // hide support dialog if present
            if (main.supportDialog) {
              main.supportDialog.hide();
            }
          } else if (action == session.DECLINED) {
            if (window['s-session-declined']) {
              window['s-session-declined'] = false;
              console.debug('The session was declined in this tab');
            } else {
              console.debug('The session was declined in another tab');
            }
            // hide support dialog if present
            if (main.supportDialog) {
              main.supportDialog.hide();
            }
          }
        }
      }, _handleService = function (msg) {
        // receives messages that are intended for this user only
        var data = msg.data, action = data.action;
        if (action == 'startSession') {
          var sessionUrl;
          if (!data.error) {
            var url = data.url;
            url = url.replace(/&/g, '%26');
            //char escape
            sessionUrl = data.userSessionUrl;
            var fullname = data.vA || data.fullname;
            // fullname is sent as visitor Alias
            // function(profile, ticket, targetURL, username, chat)
            try {
              sessionUrl = sessionUrl || sessionLink.getLink('engage', data.t, url, _enodeUserParam(fullname), config.chatEnabled, getLocale());
            } catch (e) {
            }
          }
          var eventInfo = visitorInfo.event();
          eventInfo.agentAlias = data.aA || visitorInfo.connectedAgentAlias;
          eventInfo.ticket = data.t;
          eventInfo.url = data.url;
          eventInfo.type = data.type;
          eventInfo.sid = data.sid;
          eventInfo.error = data.error;
          eventInfo.visitorName = data.vA;
          eventInfo.skillId = data.skillId;
          //TODO: check, seems to not be working, go with window config
          window.config = window.config || {};
          window.config.skillId = data.skillId;
          if (sessionUrl) {
            eventInfo.sessionUrl = sessionUrl;
          }
          // FIXED: We use setTimeout to make sure all "sessionStart" events can
          //        trigger correctly.
          var delay = config.startDelay;
          //25ms was too short for cosmos
          var delayedStartEvent = function () {
            main.emit(session.START, eventInfo);
          };
          if (delay) {
            window.setTimeout(delayedStartEvent, delay);
          } else {
            delayedStartEvent();
          }
        }
      },
      /* this method returns the current url.
       * @return the current url of the browser/tab */
      _getCurrentUrl = function () {
        console.debug('webContent Current Url: ' + window.location.href);
        return window.location.href;
      }, prepareTicket = function (params) {
        params = params || {};
        var type = params.type || 'cobrowse', serviceId = params.serviceId || visitorInfo.agentServiceId || visitorInfo.serviceId, agentAlias = params.agentAlias || visitorInfo.connectedAgentAlias, agentId = params.channelSegment || agentAlias, visitorAlias = params.visitorAlias || visitorInfo.fullname(true), context = params.context;
        // optional: LIVEENGAGE, STANDALONE, LEGACY
        cometConnect.state = STATE_ACCEPTED;
        //
        // summary: Send all cookies and session state to the server.
        // inform other open tabs that the session is started so any open dialogs can be closed.
        _publishSessionAccepted();
        if (serviceId) {
          serviceId = ('' + serviceId).replace(/\s/gi, '');  // convert to string and remove whitespace
        }
        var sessionDataGeneral = {
          asI: serviceId,
          aI: agentId,
          aA: agentAlias,
          vI: visitorInfo.id(),
          vA: visitorAlias,
          tA: visitorInfo.termsAccepted(),
          type: type,
          //   ticketId: visitorInfo.ticketId,
          action: 'prepareTicket',
          supportId: visitorInfo.supportId(),
          url: _getCurrentUrl(),
          // LivePerson Parameters
          lp_ssid: params.ssid || visitorCommon.getSessionId(window),
          lp_svid: params.svid || visitorCommon.getVisitorId(window),
          lp_scid: params.scid,
          lp_eid: params.eid,
          lp_agentId: params.agentId,
          lp_chatId: params.chatId
        };
        var customVars = visitorInfo.getCustomVars();
        if (customVars) {
          sessionDataGeneral.custom = customVars;
        }
        if (context) {
          sessionDataGeneral.context = context;
        }
        if (type && type == 'chat') {
          // no need to send session state
          sessionDataGeneral.tA = true;
          cometd.publish(CHANNEL_SERVICE, sessionDataGeneral);
        } else {
          var state = _getState();
          var msg = lang.mixin(sessionDataGeneral, state);
          cometd.publish(CHANNEL_SERVICE, msg);
        }
      }, _getState = function () {
        var windowState = {}, cookieStore = {};
        if (config.cobrowseEngine !== 'proxyless') {
          // 1. Get Window State
          try {
            windowState = synchState.getWindowState(window, true);
          } catch (e) {
            console.log('getWindowState Error  ' + e);
          }
          windowState.force = true;
          // 2. Get Cookies
          var fromDomain = window.location.host;
          var fromPath = window.location.pathname;
          cookieStore = {
            cookies: getAllCookies(),
            fromDomain: fromDomain,
            fromPath: fromPath
          };
        }
        return {
          cookieStore: cookieStore,
          input: windowState
        };
      }, lpAddVisitorState = function (siteId, stateId) {
        // summary: Send all cookies and session state to the server.
        siteId = siteId || config.tenantId;
        stateId = stateId || visitorInfo.id();
        var sessionDataGeneral = {
          siteId: siteId,
          stateId: stateId,
          vI: visitorInfo.id(),
          vA: visitorInfo.fullname(true),
          //visitorAlias
          action: 'addState',
          url: _getCurrentUrl()
        };
        var customVars = visitorInfo.getCustomVars();
        if (customVars) {
          sessionDataGeneral.custom = customVars;
        }
        var stateData = _getState();
        var msg = lang.mixin(sessionDataGeneral, stateData);
        cometd.publish(CHANNEL_SERVICE, msg);
      }, _getAgentChannel = function (name) {
        return CHANNEL_AGENTS + '/' + base64.encodeChannel(name);
      }, _publishUserInfo = function () {
        var msg = {
          action: 'userInfo',
          user: visitorInfo.allInfo()
        };
        //publish the current url (and username for identification) to the comet service
        cometd.publish(CHANNEL_AGENTS, msg);
        console.debug('Publishing via ' + CHANNEL_AGENTS + ':' + JSON.stringify(msg));
      },
      /* this method publishs that the user declined the support via cometd */
      publishDeclineSupport = function (params) {
        var agentAlias = params && (params.channelSegment || params.agentAlias) || visitorInfo.connectedAgentAlias, serviceId = params && params.serviceId || visitorInfo.agentServiceId || visitorInfo.serviceId, visitorId = visitorInfo.id();
        //FIXME: We should only publish this message, when the visitor has already requested
        //       support. Currently we also publish declineSupport, when the user has only opened
        //       the dialog.
        // inform other open tabs that the session has been declined so any open dialogs can be closed.
        _publishSessionDeclinedToUserChannel();
        if (visitorId) {
          if (serviceId) {
            visitorInfo.lookupAgent(serviceId, function (agent) {
              var agentChannelSegment = agent.aI;
              agentAlias = agentAlias || agentChannelSegment;
              _pubishSessionDeclinedToAgentChannel(visitorId, agentAlias, agentChannelSegment);
            });
          } else {
            _pubishSessionDeclinedToAgentChannel(visitorId, agentAlias);
          }
        }
      }, _pubishSessionDeclinedToAgentChannel = function (visitorId, agentAlias, agentChannelSegment) {
        var channel;
        agentChannelSegment = agentChannelSegment || agentAlias;
        var msg = {
          action: 'declineSupport',
          vI: visitorId,
          supportId: visitorInfo.supportId()
        };
        if (agentChannelSegment) {
          // An agent already offered support. So we need only to
          // inform this agent.
          msg.aA = agentAlias;
          //FIXED: encodeURIComponent(supportUsername) encodes null values...
          channel = _getAgentChannel(agentChannelSegment);
        } else {
          // Publish to all agents
          channel = CHANNEL_AGENTS;
        }
        cometd.publish(channel, msg);
        console.debug('Declining support ' + channel + ':' + JSON.stringify(msg));
        // remove support state
        visitorInfo.connectedAgentAlias = null;
        visitorInfo.supportId(null);
        cometConnect.state = STATE_NOTHING;
      }, _disconnectComet = function () {
        //document.title = "DISCONNECTED";
        cometd.disconnect();
      },
      /* this method removes the subscription and from disconnects to the comet service  */
      _handleWinUnload = function () {
        // persist collected userinfo
        visitorInfo.persist();
        //FIXED: Do not send requests on unload, so page loads are not slowed down
        // FIXED: SEND DISCONNECT: We need to send a disconnect to avoid the 'onload' event form
        //        being deferred because we do a 25s long-poll on page reloads. These long-polls
        //        may be triggered by timeouts or delayed sends.
        //        https://groups.google.com/forum/?fromgroups=#!searchin/cometd-users/abort/cometd-users/YCukvSvYrR0/3iXc5XBACEkJ
        //_disconnectComet();
        // FIXED: 27.03.13 Only abort transport if currently connected.
        //if (!cometd.isDisconnected()) {
        try {
          cometd.getTransport().abort();
        } catch (e) {
        }  //dojoxCometd.disconnect(true);
           //}
      };
    ///////////////////////////////
    // PUBLIC METHODS
    ///////////////////////////////
    //noinspection JSHint
    var cometConnect = {
      statusChange: function (available) {
      },
      on: function (type, listener) {
        return on.parse(this, type, listener, function (target, type) {
          return after(target, 'on' + type, listener, true);
        });
      },
      emit: function (type, event) {
        var args = [this];
        args.push.apply(args, arguments);
        return on.emit.apply(on, args);
      },
      state: 0,
      // STATE_NOTHING = 0, STATE_REQUESTED = 1, STATE_OFFERED = 2, STATE_ACCEPTED = 3;
      _getCometd: function () {
        return cometd;
      },
      onSuccessfulHandshake: [],
      // called after successful handshake
      getStatus: function () {
        return cometd.getStatus();
      },
      isDisconnected: function () {
        return cometd.isDisconnected();
      },
      checkAgentStatus: _checkAgentStatus,
      initializeComet: initializeComet,
      publishDeclineSupport: publishDeclineSupport,
      publishSupportRequest: publishSupportRequest,
      prepareTicket: prepareTicket,
      addVisitorState: lpAddVisitorState,
      cometCleanUp: _cometCleanup
    };
    return cometConnect;
  }(dojo_string, dojo_has, dojo_on, dojo_aspect, dojo_Deferred, dojox_cometd, dojox_cometd_reloadLP, dojo__base_unload, dojo__base_lang, dojo__base_array, liveperson_visitor_common, synchronite__base_state, synchronite__base_base64, dojo__base_url, synchronite_integration_session, synchronite__base_session_link, synchronite__base_page_visibility, synchronite__base_locale, synchronite__base_url, synchronite_micro_dom, synchronite_cometd_LargeMessageExtension);
  synchronite_integration_ajax_status = function (strings, on, aspect, request) {
    var after = aspect.after;
    /* this method request support (ajax version) */
    //the url to the ajax (means non comet) version of this service
    var URL_TO_SERVLET_AJAX = synchroniteConfig.serverUrl + strings.AJAX_PATH;
    var ajaxStatus = {
      statusChange: function (available) {
      },
      on: function (type, listener) {
        return on.parse(this, type, listener, function (target, type) {
          return after(target, 'on' + type, listener, true);
        });
      },
      emit: function (type, event) {
        var args = [this];
        args.push.apply(args, arguments);
        return on.emit.apply(on, args);
      },
      checkAgentStatus: function (tenantId) {
        //check again if the support is available
        console.debug('checkAgentStatus (jsonp)');
        var data = {
          preventCache: true,
          handleAs: 'json',
          data: {
            action: 'isSupportAvailable',
            tI: tenantId
          }
        };
        //returns a dojo Promise
        var promise = request.post(URL_TO_SERVLET_AJAX, data);
        promise.then(function (data) {
          var supportAvailable = data.availability;
          console.debug('checkAgentStatus (jsonp) result:' + supportAvailable);
          ajaxStatus.emit('statusChange', data);
        });
        return promise;
      },
      checkSNisValid: function (host, tenantId, serviceNumber) {
        var data = {
          preventCache: true,
          handleAs: 'json',
          data: {
            action: 'validateSN',
            tI: tenantId,
            sI: serviceNumber
          }
        };
        //returns a dojo Promise
        var promise = request.post(host + strings.AJAX_PATH, data);
        return promise;
      }
    };
    return ajaxStatus;
  }(synchronite_constants_strings, dojo_on, dojo_aspect, dojo_request);
  synchronite_integration_tracking_ga = function (query) {
    //API: https://developers.google.com/analytics/devguides/collection/gajs/eventTrackerGuide#SettingUpEventTracking
    //PRIVATE
    var trackingEvents, visitorInfo, trackingWindow;
    //API: _trackEvent(category, action, opt_label, opt_value, opt_noninteraction)
    var googleTrack = function (action, opt_label, opt_value, opt_noninteraction) {
      //parameters
      //
      //String   category The general event category (e.g. "Videos").
      //
      //String   action The action for the event (e.g. "Play").
      //
      //String   opt_label An optional descriptor for the event.
      //
      //Int      opt_value An optional value associated with the event. You can see your event values in the Overview, Categories, and Actions reports, where they are listed by event or aggregated across events, depending upon your report view.
      //
      //Boolean  opt_noninteraction Default value is false. By default, the event hit sent by _trackEvent() will impact a visitor's bounce rate. By setting this parameter to true, this event hit will not be used in bounce rate calculations.
      //returns
      //
      //Boolean whether the event was successfully sent.
      var gaq = trackingWindow._gaq;
      if (typeof gaq !== 'undefined') {
        // category = "synchronite"
        var payload = [
          '_trackEvent',
          'cobrowse'
        ];
        payload.push(action);
        opt_label && payload.push(opt_label);
        opt_value && payload.push(opt_value);
        return gaq.push(payload);
      } else if (typeof ga !== 'undefined') {
        return ga('send', 'event', 'cobrowse', action, opt_label, opt_value);
      } else {
        console.warn('Google Analytics Tracking API not found. \'_gaq\' does not exist.');
        return null;
      }
    };
    // Google Analytics
    var sessionOffered = function (evt) {
        return googleTrack('sessionOffered', 'Visitor_Id_' + evt.visitorId);
      }, sessionStart = function (evt) {
        return googleTrack('sessionStarted', 'Visitor_Id_' + evt.visitorId);
      }, sessionRequested = function (evt) {
        return googleTrack('sessionRequested', 'Visitor_Id_' + evt.visitorId);
      }, sessionAccepted = function (evt) {
        return googleTrack('sessionAccepted', 'Visitor_Id_' + evt.visitorId);
      }, sessionDeclined = function (evt) {
        return googleTrack('sessionDeclined', 'Visitor_Id_' + evt.visitorId);
      }, sessionEnd = function (evt) {
        googleTrack('sessionDuration', 'Visitor_Id_' + evt.visitorId, evt.duration);
        return googleTrack('sessionEnd', 'Visitor_Id_' + evt.visitorId);
      }, liveSupportButtonClicked = function (evt) {
        return googleTrack('liveSupportButtonClicked', 'Visitor_Id_' + evt.visitorId);
      };
    // PUBLIC
    var setupTracking = function (_trackingWindow, _trackingEvents) {
      if (_trackingEvents.listening) {
        console.info('Already Tracking Event. Skipped setupTracking to prevent duplicate requests.');
        return;
      }
      trackingWindow = _trackingWindow;
      trackingEvents = _trackingEvents;
      if (_trackingEvents.visitorInfo) {
        visitorInfo = _trackingEvents.visitorInfo;
      }
      trackingEvents.on('sessionOffered', sessionOffered);
      trackingEvents.on('sessionRequested', sessionRequested);
      trackingEvents.on('sessionAccepted', sessionAccepted);
      trackingEvents.on('sessionDeclined', sessionDeclined);
      trackingEvents.on('sessionStart', sessionStart);
      trackingEvents.on('sessionEnd', sessionEnd);
      trackingEvents.on('liveSupportButtonClicked', liveSupportButtonClicked);
      _trackingEvents.listening = true;
    };
    return setupTracking;
  }(synchronite__base_query);
  synchronite_integration_tracking_piwik = function (query) {
    //PRIVATE
    var trackingEvents, visitorInfo, trackingWindow;
    var piwikTrack = function (index, name, value, scope) {
      // http://piwik.org/docs/javascript-tracking/#toc-custom-variables
      // Example:
      //  ASYNC CALL: _paq.push(['setCustomVariable','1','VisitorType','Member']);
      //  SYNC  CALL: setCustomVariable (index, name, value, scope = "page")
      var paq = trackingWindow._paq;
      if (typeof paq !== 'undefined') {
        var payload = ['setCustomVariable'];
        payload.push(index);
        payload.push(name);
        payload.push(value);
        //payload.push(eventName);
        if (scope) {
          payload.push(scope);
        } else {
          payload.push('page');
        }
        return paq.push(payload);
      } else {
        console.warn('Piwik Web Analytics Tracking API not found. \'_paq\' does not exist.');
        return null;
      }
    };
    // Piwik Web Analytics
    var liveSupportButtonClicked = function (evt) {
        return piwikTrack('1', 'liveSupportButtonClicked', 'Visitor_Id_' + evt.visitorId);
      }, sessionRequested = function (evt) {
        return piwikTrack('2', 'sessionRequested', 'Visitor_Id_' + evt.visitorId);
      }, sessionOffered = function (evt) {
        return piwikTrack('3', 'sessionOffered', 'Visitor_Id_' + evt.visitorId);
      }, sessionStart = function (evt) {
        return piwikTrack('4', 'sessionStarted', 'Visitor_Id_' + evt.visitorId);
      }, sessionEnd = function (evt) {
        return piwikTrack('5', 'sessionEnd', 'Visitor_Id_' + evt.visitorId);
      };
    // PUBLIC
    var setupTracking = function (_trackingWindow, _trackingEvents) {
      if (_trackingEvents.listening) {
        console.info('Already Tracking Event. Skipped setupTracking to prevent duplicate requests.');
        return;
      }
      trackingWindow = _trackingWindow;
      trackingEvents = _trackingEvents;
      if (_trackingEvents.visitorInfo) {
        visitorInfo = _trackingEvents.visitorInfo;
      }
      trackingEvents.on('sessionOffered', sessionOffered);
      trackingEvents.on('sessionRequested', sessionRequested);
      trackingEvents.on('sessionStart', sessionStart);
      trackingEvents.on('sessionEnd', sessionEnd);
      trackingEvents.on('liveSupportButtonClicked', liveSupportButtonClicked);
      _trackingEvents.listening = true;
    };
    return setupTracking;
  }(synchronite__base_query);
  synchronite_integration_tracking_wt = function (query) {
    //API: if(typeof wt!="undefined"){_wt.sendinfo({linkId:a,customClickParameter:b}
    //PRIVATE
    var trackingEvents, visitorInfo, trackingWindow;
    var PARAM_ORDER = [
      /* 0 */
      false,
      /* 1 */
      false,
      /* 2 */
      false,
      /* 3 */
      false,
      /* 4 */
      false,
      /* 5 */
      false,
      /* 6 */
      'duration',
      /* 7 */
      'visitorId'
    ];
    var wtTrack = function (linkId, evt, sendOnUnload) {
      // wtParams:
      //  contentId
      //  linkId - STRING - standard parameter (e.g. tracks facebook_like)
      //  customClickParameter - JSON ARRAY - { "1" : "HomePage" }
      //  sendOnUnload
      var customClickParameter = {};
      var trackAnonymous = typeof synchroniteConfig !== 'undefined' && synchroniteConfig.trackingAnonymous;
      var param, strKey, strValue;
      for (var i = 0; i < PARAM_ORDER.length; i++) {
        param = PARAM_ORDER[i];
        if (param && evt && evt[param]) {
          // We must pass the index/key AND value as a string, because webtrekk expects
          // an object. When the index is set as a number, the customClickParameter object
          // is converted to an array.
          strKey = i + '';
          strValue = evt[param] + '';
          if (param == 'visitorId') {
            strValue = 'Visitor_Id_' + (trackAnonymous ? 'anonymous' : strValue);
          }
          customClickParameter[strKey] = strValue;
        }
      }
      var _wt = trackingWindow.wt;
      if (typeof _wt !== 'undefined') {
        var wtParams = {
          linkId: 'synchronite_' + linkId,
          customClickParameter: customClickParameter
        };
        if (sendOnUnload) {
          // sendOnUnload: Beim Verlassen einer Seite knnen einige Browser das Pixel nicht
          //               mehr rechtzeitig versenden, falls der Parameter sendOnUnload
          //               weggelassen wird. (S. 28 - Integration und Konfiguration des
          //               Webtrekk Tracking-Pixels
          // sendOnUnload = !!sendOnUnload; // convert to boolean
          wtParams.sendOnUnload = sendOnUnload;
        }
        console.info('_wt.sendinfo(' + JSON.stringify(wtParams) + ')');
        // this.sendinfo = function(c, p, $V, ep) {
        _wt.sendinfo(wtParams);
      } else {
        console.warn('Webtrekk Tracking API not found. \'wt\' does not exist.');
        return null;
      }
    };
    // web trekk
    var sessionOffered = function (evt) {
        return wtTrack('sessionOffered', evt);
      }, sessionStart = function (evt) {
        return wtTrack('sessionStarted', evt, 1);
      }, sessionRequested = function (evt) {
        return wtTrack('sessionRequested', evt);
      }, sessionAccepted = function (evt) {
        return wtTrack('sessionAccepted', evt, 1);
      }, sessionDeclined = function (evt) {
        return wtTrack('sessionDeclined', evt);
      }, sessionEnd = function (evt) {
        return wtTrack('sessionEnd', evt);
      }, liveSupportButtonClicked = function (evt) {
        return wtTrack('liveSupportButtonClicked', evt.visitorId);
      };
    // PUBLIC
    var setupTracking = function (_trackingWindow, _trackingEvents) {
      if (_trackingEvents.listening) {
        console.info('Already Tracking Event. Skipped setupTracking to prevent duplicate requests.');
        return;
      }
      trackingWindow = _trackingWindow;
      trackingEvents = _trackingEvents;
      if (_trackingEvents.visitorInfo) {
        visitorInfo = _trackingEvents.visitorInfo;
      }
      _trackingEvents.on('sessionOffered', sessionOffered);
      _trackingEvents.on('sessionRequested', sessionRequested);
      _trackingEvents.on('sessionAccepted', sessionAccepted);
      _trackingEvents.on('sessionDeclined', sessionDeclined);
      _trackingEvents.on('sessionStart', sessionStart);
      _trackingEvents.on('sessionEnd', sessionEnd);
      _trackingEvents.on('liveSupportButtonClicked', liveSupportButtonClicked);
      _trackingEvents.listening = true;
    };
    return setupTracking;
  }(synchronite__base_query);
  synchronite_integration_tracking_lpEvents = function (query) {
    //PRIVATE
    var trackingEvents, visitorInfo, trackingWindow;
    var appName = 'cobrowse';
    var lpEventsTrack = function (eventName, data) {
      var lpEvents = trackingWindow.lpTag.events;
      lpEvents.trigger({
        appName: appName,
        eventName: eventName,
        data: data
      });
    };
    var sessionOffered = function (evt) {
        return lpEventsTrack('sessionOffered', { visitorId: 'Visitor_Id_' + evt.visitorId });
      }, sessionStart = function (evt) {
        return lpEventsTrack('sessionStarted', { visitorId: 'Visitor_Id_' + evt.visitorId });
      }, sessionRequested = function (evt) {
        return lpEventsTrack('sessionRequested', { visitorId: 'Visitor_Id_' + evt.visitorId });
      }, sessionAccepted = function (evt) {
        return lpEventsTrack('sessionAccepted', { visitorId: 'Visitor_Id_' + evt.visitorId });
      }, sessionDeclined = function (evt) {
        return lpEventsTrack('sessionDeclined', { visitorId: 'Visitor_Id_' + evt.visitorId });
      }, sessionResume = function (evt) {
        return lpEventsTrack('sessionResume', evt);
      }, sessionError = function (evt) {
        return lpEventsTrack('sessionError', evt);
      }, sessionEnd = function (evt) {
        lpEventsTrack('sessionDuration', {
          visitorId: 'Visitor_Id_' + evt.visitorId,
          duration: evt.duration
        });
        return lpEventsTrack('sessionEnd', {
          visitorId: 'Visitor_Id_' + evt.visitorId,
          ticketId: evt.ticketId,
          endedBy: evt.endedBy
        });
      }, liveSupportButtonClicked = function (evt) {
        return lpEventsTrack('liveSupportButtonClicked', { visitorId: 'Visitor_Id_' + evt.visitorId });
      };
    // PUBLIC
    var setupTracking = function (_trackingWindow, _trackingEvents) {
      if (_trackingEvents.listening) {
        console.info('Already Tracking Event. Skipped setupTracking to prevent duplicate requests.');
        return;
      }
      trackingWindow = _trackingWindow;
      trackingEvents = _trackingEvents;
      if (_trackingEvents.visitorInfo) {
        visitorInfo = _trackingEvents.visitorInfo;
      }
      trackingEvents.on('sessionOffered', sessionOffered);
      trackingEvents.on('sessionRequested', sessionRequested);
      trackingEvents.on('sessionAccepted', sessionAccepted);
      trackingEvents.on('sessionDeclined', sessionDeclined);
      trackingEvents.on('sessionResume', sessionResume);
      trackingEvents.on('sessionError', sessionError);
      trackingEvents.on('sessionStarted', sessionStart);
      trackingEvents.on('sessionEnd', sessionEnd);
      trackingEvents.on('liveSupportButtonClicked', liveSupportButtonClicked);
      _trackingEvents.listening = true;
    };
    return setupTracking;
  }(synchronite__base_query);
  synchronite_integration_tracking_tealium = function (string, lang) {
    //API: if(typeof wt!="undefined"){_wt.sendinfo({linkId:a,customClickParameter:b}
    //PRIVATE
    var trackingEvents, visitorInfo, trackingWindow;
    var track = function (type, originalData) {
      var _utag = trackingWindow.utag;
      if (!_utag) {
        if (trackingWindow.frames.length) {
          try {
            _utag = trackingWindow.frames[0].utag;
          } catch (e) {
            console.warn('Unable to find utag window.');
            console.warn(e);
          }
        }
      }
      if (typeof _utag !== 'undefined') {
        //utag.link({
        //
        //    'wt_link_id' :'liveperson_cobrowsing', // statischer Wert, der immer so mit in das Objekt geschrieben wird
        //    'cb_offers' : 'cobrowsing.angebot',   // Anzahl Angebote - statischer Wert, der bergeben wird bei der Eingabe in die Webcode-Lasche
        //    'cb_session' : 'TEAMID',               // Anzahl der tatschlich durchgefhrten Sessions inkl. Aufsplitung nach dem Team-Namen/der TeamID (Anzahl Sessions pro Team)
        //    'cb_cancel' : 'cobrowsing.abbruch',   // Daraus ergibt sich die Anzahl der durch Kunden abgebrochenen Session - statischer Wert
        //    'cb_sessiondauer' : '125',             // Dauer Session nach der Beendigung in Sekunden
        //    'cb_kundenbefragung' : 'ja'            // Wenn Die Kundenbefragung nach Beendigung der Session stattfinden soll wird der Wert 'ja' eingetragen
        //});
        var data = JSON.parse(JSON.stringify(originalData));
        // create copy of data
        // CUSTOM TELEKOM START
        addAgentTeam(data);
        if (data.agentAlias) {
          delete data.agentAlias;
        }
        if (data.agentId) {
          delete data.agentId;
        }
        for (var key in data) {
          if (data.hasOwnProperty(key)) {
            data['cb_' + key] = data[key] + '';
            // convert to String
            delete data[key];
          }
        }
        if (type == 'sessionEnd') {
          data.cb_kundenbefragung = 'ja';
        }
        // CUSTOM TELEKOM END
        var trackAnonymous = typeof synchroniteConfig !== 'undefined' && synchroniteConfig.trackingAnonymous;
        if (trackAnonymous && data.visitorId) {
          data.visitorId = 'anonymous';
        }
        var event = {
          'wt_link_id': 'liveperson_cobrowsing',
          'cb_type': type  // changed for telekom
        };
        event = lang.mixin(data, event);
        console.info('utag.link(' + JSON.stringify(event) + ')');
        _utag.link(event);
      } else {
        console.warn('Tealium UTag Tracking API not found. \'utag\' does not exist.');
        return null;
      }
    };
    var addAgentTeam = function (event) {
      var agentAlias = event.agentAlias;
      if (agentAlias) {
        var agentInfo = agentAlias.split(',');
        if (agentInfo.length > 1) {
          event.agentAlias = string.trim(agentInfo[0]);
          event.agentTeam = string.trim(agentInfo[1]);
        }
      }
      return event;
    };
    // web trekk
    var sessionOffered = function (evt) {
        return track('sessionOffered', evt);
      }, sessionStart = function (evt) {
        return track('sessionStarted', evt);
      }, sessionRequested = function (evt) {
        return track('sessionRequested', evt);
      }, sessionAccepted = function (evt) {
        return track('sessionAccepted', evt);
      }, sessionDeclined = function (evt) {
        return track('sessionDeclined', evt);
      }, sessionEnd = function (evt) {
        return track('sessionEnd', evt);
      }, liveSupportButtonClicked = function (evt) {
        return track('liveSupportButtonClicked', evt.visitorId);
      };
    // PUBLIC
    var setupTracking = function (_trackingWindow, _trackingEvents) {
      if (_trackingEvents.listening) {
        console.info('Already Tracking Event. Skipped setupTracking to prevent duplicate requests.');
        return;
      }
      trackingWindow = _trackingWindow;
      trackingEvents = _trackingEvents;
      if (_trackingEvents.visitorInfo) {
        visitorInfo = _trackingEvents.visitorInfo;
      }
      _trackingEvents.on('sessionOffered', sessionOffered);
      _trackingEvents.on('sessionRequested', sessionRequested);
      _trackingEvents.on('sessionAccepted', sessionAccepted);
      _trackingEvents.on('sessionDeclined', sessionDeclined);
      _trackingEvents.on('sessionStart', sessionStart);
      _trackingEvents.on('sessionEnd', sessionEnd);
      _trackingEvents.on('liveSupportButtonClicked', liveSupportButtonClicked);
      _trackingEvents.listening = true;
    };
    return setupTracking;
  }(dojo_string, dojo__base_lang);
  synchronite_integration_tracking_loader = function (trackingGA, trackingPiwik, trackingWT, trackingLpEvents, trackingTealium) {
    var trackingLoader = {
      setupTracker: function (trackingWindow, trackingAPI, trackingEvents) {
        // publish events to lpTag.events if it's defined
        var lpEvents = trackingWindow.lpTag && trackingWindow.lpTag.events;
        if (lpEvents) {
          trackingLpEvents(trackingWindow, trackingEvents);
        }
        // check if additional tracking is configured, e.g. to Google Analytics
        if (trackingAPI && trackingAPI != 'disabled') {
          console.debug('trackingLoader: Initialize tracking API \'' + trackingAPI + '\' in window ' + trackingWindow.location.href);
          if (trackingAPI == 'ga' && (trackingWindow._gaq || trackingWindow.ga)) {
            trackingGA(trackingWindow, trackingEvents);
          } else if (trackingAPI == 'piwik' && trackingWindow._paq) {
            trackingPiwik(trackingWindow, trackingEvents);
          } else if (trackingAPI == 'wt' && trackingWindow.wt) {
            trackingWT(trackingWindow, trackingEvents);
          } else if (trackingAPI == 'tealium'  /* && trackingWindow.utag*/) {
            // lazy loaded
            trackingTealium(trackingWindow, trackingEvents);
          }
        } else {
          console.debug('trackingLoader: trackingAPI is disabled');
        }
      }
    };
    return trackingLoader;
  }(synchronite_integration_tracking_ga, synchronite_integration_tracking_piwik, synchronite_integration_tracking_wt, synchronite_integration_tracking_lpEvents, synchronite_integration_tracking_tealium);
  dojo_selector__loader = function (has, sizzle) {
    // PATCH START
    has.add('dom-qsa2.1', function (global, doc, element) {
      return !!element.querySelectorAll;
    });
    has.add('dom-qsa3', function (global, doc, element) {
      // test to see if we have a reasonable native selector engine available
      try {
        element.innerHTML = '<p class=\'TEST\'></p>';
        // test kind of from sizzle
        // Safari can't handle uppercase or unicode characters when
        // in quirks mode, IE8 can't handle pseudos like :empty
        return element.querySelectorAll('.TEST:empty').length == 1;
      } catch (e) {
      }
    });
    // PATCH END (COMPAT WITH REQUIREJS)
    return {
      // summary:
      //		This module handles loading the appropriate selector engine for the given browser
      load: function (id, parentRequire, loaded, config) {
        loaded(sizzle);
      }
    };
  }(dojo_has, synchronite_libs_sizzle);
  dojo_query = function (dojo, has, dom, on, array, lang, loader, defaultEngine) {
    has.add('array-extensible', function () {
      // test to see if we can extend an array (not supported in old IE)
      return lang.delegate([], { length: 1 }).length == 1 && !has('bug-for-in-skips-shadowed');
    });
    var ap = Array.prototype, aps = ap.slice, apc = ap.concat, forEach = array.forEach;
    var tnl = function (a, parent, NodeListCtor) {
      // summary:
      //		decorate an array to make it look like a `dojo/NodeList`.
      // a:
      //		Array of nodes to decorate.
      // parent:
      //		An optional parent NodeList that generated the current
      //		list of nodes. Used to call _stash() so the parent NodeList
      //		can be accessed via end() later.
      // NodeListCtor:
      //		An optional constructor function to use for any
      //		new NodeList calls. This allows a certain chain of
      //		NodeList calls to use a different object than dojo/NodeList.
      var nodeList = new (NodeListCtor || this._NodeListCtor || nl)(a);
      return parent ? nodeList._stash(parent) : nodeList;
    };
    var loopBody = function (f, a, o) {
      a = [0].concat(aps.call(a, 0));
      o = o || dojo.global;
      return function (node) {
        a[0] = node;
        return f.apply(o, a);
      };
    };
    // adapters
    var adaptAsForEach = function (f, o) {
      // summary:
      //		adapts a single node function to be used in the forEach-type
      //		actions. The initial object is returned from the specialized
      //		function.
      // f: Function
      //		a function to adapt
      // o: Object?
      //		an optional context for f
      return function () {
        this.forEach(loopBody(f, arguments, o));
        return this;  // Object
      };
    };
    var adaptAsMap = function (f, o) {
      // summary:
      //		adapts a single node function to be used in the map-type
      //		actions. The return is a new array of values, as via `dojo/_base/array.map`
      // f: Function
      //		a function to adapt
      // o: Object?
      //		an optional context for f
      return function () {
        return this.map(loopBody(f, arguments, o));
      };
    };
    var adaptAsFilter = function (f, o) {
      // summary:
      //		adapts a single node function to be used in the filter-type actions
      // f: Function
      //		a function to adapt
      // o: Object?
      //		an optional context for f
      return function () {
        return this.filter(loopBody(f, arguments, o));
      };
    };
    var adaptWithCondition = function (f, g, o) {
      // summary:
      //		adapts a single node function to be used in the map-type
      //		actions, behaves like forEach() or map() depending on arguments
      // f: Function
      //		a function to adapt
      // g: Function
      //		a condition function, if true runs as map(), otherwise runs as forEach()
      // o: Object?
      //		an optional context for f and g
      return function () {
        var a = arguments, body = loopBody(f, a, o);
        if (g.call(o || dojo.global, a)) {
          return this.map(body);  // self
        }
        this.forEach(body);
        return this;  // self
      };
    };
    var NodeList = function (array) {
      // summary:
      //		Array-like object which adds syntactic
      //		sugar for chaining, common iteration operations, animation, and
      //		node manipulation. NodeLists are most often returned as the
      //		result of dojo/query() calls.
      // description:
      //		NodeList instances provide many utilities that reflect
      //		core Dojo APIs for Array iteration and manipulation, DOM
      //		manipulation, and event handling. Instead of needing to dig up
      //		functions in the dojo package, NodeLists generally make the
      //		full power of Dojo available for DOM manipulation tasks in a
      //		simple, chainable way.
      // example:
      //		create a node list from a node
      //		|	require(["dojo/query", "dojo/dom"
      //		|	], function(query, dom){
      //		|		query.NodeList(dom.byId("foo"));
      //		|	});
      // example:
      //		get a NodeList from a CSS query and iterate on it
      //		|	require(["dojo/on", "dojo/dom"
      //		|	], function(on, dom){
      //		|		var l = query(".thinger");
      //		|		l.forEach(function(node, index, nodeList){
      //		|			console.log(index, node.innerHTML);
      //		|		});
      //		|	});
      // example:
      //		use native and Dojo-provided array methods to manipulate a
      //		NodeList without needing to use dojo.* functions explicitly:
      //		|	require(["dojo/query", "dojo/dom-construct", "dojo/dom"
      //		|	], function(query, domConstruct, dom){
      //		|		var l = query(".thinger");
      //		|		// since NodeLists are real arrays, they have a length
      //		|		// property that is both readable and writable and
      //		|		// push/pop/shift/unshift methods
      //		|		console.log(l.length);
      //		|		l.push(domConstruct.create("span"));
      //		|
      //		|		// dojo's normalized array methods work too:
      //		|		console.log( l.indexOf(dom.byId("foo")) );
      //		|		// ...including the special "function as string" shorthand
      //		|		console.log( l.every("item.nodeType == 1") );
      //		|
      //		|		// NodeLists can be [..] indexed, or you can use the at()
      //		|		// function to get specific items wrapped in a new NodeList:
      //		|		var node = l[3]; // the 4th element
      //		|		var newList = l.at(1, 3); // the 2nd and 4th elements
      //		|	});
      // example:
      //		chainability is a key advantage of NodeLists:
      //		|	require(["dojo/query", "dojo/NodeList-dom"
      //		|	], function(query){
      //		|		query(".thinger")
      //		|			.onclick(function(e){ /* ... */ })
      //		|			.at(1, 3, 8) // get a subset
      //		|				.style("padding", "5px")
      //		|				.forEach(console.log);
      //		|	});
      var isNew = this instanceof nl && has('array-extensible');
      if (typeof array == 'number') {
        array = Array(array);
      }
      var nodeArray = array && 'length' in array ? array : arguments;
      if (isNew || !nodeArray.sort) {
        // make sure it's a real array before we pass it on to be wrapped 
        var target = isNew ? this : [], l = target.length = nodeArray.length;
        for (var i = 0; i < l; i++) {
          target[i] = nodeArray[i];
        }
        if (isNew) {
          // called with new operator, this means we are going to use this instance and push
          // the nodes on to it. This is usually much faster since the NodeList properties
          //	don't need to be copied (unless the list of nodes is extremely large).
          return target;
        }
        nodeArray = target;
      }
      // called without new operator, use a real array and copy prototype properties,
      // this is slower and exists for back-compat. Should be removed in 2.0.
      lang._mixin(nodeArray, nlp);
      nodeArray._NodeListCtor = function (array) {
        // call without new operator to preserve back-compat behavior
        return nl(array);
      };
      return nodeArray;
    };
    var nl = NodeList, nlp = nl.prototype = has('array-extensible') ? [] : {};
    // extend an array if it is extensible
    // expose adapters and the wrapper as private functions
    nl._wrap = nlp._wrap = tnl;
    nl._adaptAsMap = adaptAsMap;
    nl._adaptAsForEach = adaptAsForEach;
    nl._adaptAsFilter = adaptAsFilter;
    nl._adaptWithCondition = adaptWithCondition;
    // mass assignment
    // add array redirectors
    forEach([
      'slice',
      'splice'
    ], function (name) {
      var f = ap[name];
      //Use a copy of the this array via this.slice() to allow .end() to work right in the splice case.
      // CANNOT apply ._stash()/end() to splice since it currently modifies
      // the existing this array -- it would break backward compatibility if we copy the array before
      // the splice so that we can use .end(). So only doing the stash option to this._wrap for slice.
      nlp[name] = function () {
        return this._wrap(f.apply(this, arguments), name == 'slice' ? this : null);
      };
    });
    // concat should be here but some browsers with native NodeList have problems with it
    // add array.js redirectors
    forEach([
      'indexOf',
      'lastIndexOf',
      'every',
      'some'
    ], function (name) {
      var f = array[name];
      nlp[name] = function () {
        return f.apply(dojo, [this].concat(aps.call(arguments, 0)));
      };
    });
    lang.extend(NodeList, {
      // copy the constructors
      constructor: nl,
      _NodeListCtor: nl,
      toString: function () {
        // Array.prototype.toString can't be applied to objects, so we use join
        return this.join(',');
      },
      _stash: function (parent) {
        // summary:
        //		private function to hold to a parent NodeList. end() to return the parent NodeList.
        //
        // example:
        //		How to make a `dojo/NodeList` method that only returns the third node in
        //		the dojo/NodeList but allows access to the original NodeList by using this._stash:
        //	|	require(["dojo/query", "dojo/_base/lang", "dojo/NodeList", "dojo/NodeList-dom"
        //	|	], function(query, lang){
        //	|		lang.extend(NodeList, {
        //	|			third: function(){
        //	|				var newNodeList = NodeList(this[2]);
        //	|				return newNodeList._stash(this);
        //	|			}
        //	|		});
        //	|		// then see how _stash applies a sub-list, to be .end()'ed out of
        //	|		query(".foo")
        //	|			.third()
        //	|				.addClass("thirdFoo")
        //	|			.end()
        //	|			// access to the orig .foo list
        //	|			.removeClass("foo")
        //	|	});
        //
        this._parent = parent;
        return this;  // dojo/NodeList
      },
      on: function (eventName, listener) {
        // summary:
        //		Listen for events on the nodes in the NodeList. Basic usage is:
        //
        // example:
        //		|	require(["dojo/query"
        //		|	], function(query){
        //		|		query(".my-class").on("click", listener);
        //			This supports event delegation by using selectors as the first argument with the event names as
        //			pseudo selectors. For example:
        //		| 		query("#my-list").on("li:click", listener);
        //			This will listen for click events within `<li>` elements that are inside the `#my-list` element.
        //			Because on supports CSS selector syntax, we can use comma-delimited events as well:
        //		| 		query("#my-list").on("li button:mouseover, li:click", listener);
        //		|	});
        var handles = this.map(function (node) {
          return on(node, eventName, listener);  // TODO: apply to the NodeList so the same selector engine is used for matches
        });
        handles.remove = function () {
          for (var i = 0; i < handles.length; i++) {
            handles[i].remove();
          }
        };
        return handles;
      },
      end: function () {
        // summary:
        //		Ends use of the current `NodeList` by returning the previous NodeList
        //		that generated the current NodeList.
        // description:
        //		Returns the `NodeList` that generated the current `NodeList`. If there
        //		is no parent NodeList, an empty NodeList is returned.
        // example:
        //	|	require(["dojo/query", "dojo/NodeList-dom"
        //	|	], function(query){
        //	|		query("a")
        //	|			.filter(".disabled")
        //	|				// operate on the anchors that only have a disabled class
        //	|				.style("color", "grey")
        //	|			.end()
        //	|			// jump back to the list of anchors
        //	|			.style(...)
        //	|	});
        //
        if (this._parent) {
          return this._parent;
        } else {
          //Just return empty list.
          return new this._NodeListCtor(0);
        }
      },
      // http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array#Methods
      // FIXME: handle return values for #3244
      //		http://trac.dojotoolkit.org/ticket/3244
      // FIXME:
      //		need to wrap or implement:
      //			join (perhaps w/ innerHTML/outerHTML overload for toString() of items?)
      //			reduce
      //			reduceRight
      /*=====
      		slice: function(begin, end){
      			// summary:
      			//		Returns a new NodeList, maintaining this one in place
      			// description:
      			//		This method behaves exactly like the Array.slice method
      			//		with the caveat that it returns a `dojo/NodeList` and not a
      			//		raw Array. For more details, see Mozilla's [slice
      			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice)
      			// begin: Integer
      			//		Can be a positive or negative integer, with positive
      			//		integers noting the offset to begin at, and negative
      			//		integers denoting an offset from the end (i.e., to the left
      			//		of the end)
      			// end: Integer?
      			//		Optional parameter to describe what position relative to
      			//		the NodeList's zero index to end the slice at. Like begin,
      			//		can be positive or negative.
      			return this._wrap(a.slice.apply(this, arguments));
      		},
      
      		splice: function(index, howmany, item){
      			// summary:
      			//		Returns a new NodeList, manipulating this NodeList based on
      			//		the arguments passed, potentially splicing in new elements
      			//		at an offset, optionally deleting elements
      			// description:
      			//		This method behaves exactly like the Array.splice method
      			//		with the caveat that it returns a `dojo/NodeList` and not a
      			//		raw Array. For more details, see Mozilla's [splice
      			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice)
      			//		For backwards compatibility, calling .end() on the spliced NodeList
      			//		does not return the original NodeList -- splice alters the NodeList in place.
      			// index: Integer
      			//		begin can be a positive or negative integer, with positive
      			//		integers noting the offset to begin at, and negative
      			//		integers denoting an offset from the end (i.e., to the left
      			//		of the end)
      			// howmany: Integer?
      			//		Optional parameter to describe what position relative to
      			//		the NodeList's zero index to end the slice at. Like begin,
      			//		can be positive or negative.
      			// item: Object...?
      			//		Any number of optional parameters may be passed in to be
      			//		spliced into the NodeList
      			return this._wrap(a.splice.apply(this, arguments));	// dojo/NodeList
      		},
      
      		indexOf: function(value, fromIndex){
      			// summary:
      			//		see `dojo/_base/array.indexOf()`. The primary difference is that the acted-on
      			//		array is implicitly this NodeList
      			// value: Object
      			//		The value to search for.
      			// fromIndex: Integer?
      			//		The location to start searching from. Optional. Defaults to 0.
      			// description:
      			//		For more details on the behavior of indexOf, see Mozilla's
      			//		[indexOf
      			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf)
      			// returns:
      			//		Positive Integer or 0 for a match, -1 of not found.
      			return d.indexOf(this, value, fromIndex); // Integer
      		},
      
      		lastIndexOf: function(value, fromIndex){
      			// summary:
      			//		see `dojo/_base/array.lastIndexOf()`. The primary difference is that the
      			//		acted-on array is implicitly this NodeList
      			// description:
      			//		For more details on the behavior of lastIndexOf, see
      			//		Mozilla's [lastIndexOf
      			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf)
      			// value: Object
      			//		The value to search for.
      			// fromIndex: Integer?
      			//		The location to start searching from. Optional. Defaults to 0.
      			// returns:
      			//		Positive Integer or 0 for a match, -1 of not found.
      			return d.lastIndexOf(this, value, fromIndex); // Integer
      		},
      
      		every: function(callback, thisObject){
      			// summary:
      			//		see `dojo/_base/array.every()` and the [Array.every
      			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every).
      			//		Takes the same structure of arguments and returns as
      			//		dojo/_base/array.every() with the caveat that the passed array is
      			//		implicitly this NodeList
      			// callback: Function
      			//		the callback
      			// thisObject: Object?
      			//		the context
      			return d.every(this, callback, thisObject); // Boolean
      		},
      
      		some: function(callback, thisObject){
      			// summary:
      			//		Takes the same structure of arguments and returns as
      			//		`dojo/_base/array.some()` with the caveat that the passed array is
      			//		implicitly this NodeList.  See `dojo/_base/array.some()` and Mozilla's
      			//		[Array.some
      			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some).
      			// callback: Function
      			//		the callback
      			// thisObject: Object?
      			//		the context
      			return d.some(this, callback, thisObject); // Boolean
      		},
      		=====*/
      concat: function (item) {
        // summary:
        //		Returns a new NodeList comprised of items in this NodeList
        //		as well as items passed in as parameters
        // description:
        //		This method behaves exactly like the Array.concat method
        //		with the caveat that it returns a `NodeList` and not a
        //		raw Array. For more details, see the [Array.concat
        //		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/concat)
        // item: Object?
        //		Any number of optional parameters may be passed in to be
        //		spliced into the NodeList
        //return this._wrap(apc.apply(this, arguments));
        // the line above won't work for the native NodeList, or for Dojo NodeLists either :-(
        // implementation notes:
        // Array.concat() doesn't recognize native NodeLists or Dojo NodeLists
        // as arrays, and so does not inline them into a unioned array, but
        // appends them as single entities. Both the original NodeList and the
        // items passed in as parameters must be converted to raw Arrays
        // and then the concatenation result may be re-_wrap()ed as a Dojo NodeList.
        var t = aps.call(this, 0), m = array.map(arguments, function (a) {
            return aps.call(a, 0);
          });
        return this._wrap(apc.apply(t, m), this);  // dojo/NodeList
      },
      map: function (func, obj) {
        // summary:
        //		see `dojo/_base/array.map()`. The primary difference is that the acted-on
        //		array is implicitly this NodeList and the return is a
        //		NodeList (a subclass of Array)
        return this._wrap(array.map(this, func, obj), this);  // dojo/NodeList
      },
      forEach: function (callback, thisObj) {
        // summary:
        //		see `dojo/_base/array.forEach()`. The primary difference is that the acted-on
        //		array is implicitly this NodeList. If you want the option to break out
        //		of the forEach loop, use every() or some() instead.
        forEach(this, callback, thisObj);
        // non-standard return to allow easier chaining
        return this;  // dojo/NodeList
      },
      filter: function (filter) {
        // summary:
        //		"masks" the built-in javascript filter() method (supported
        //		in Dojo via `dojo/_base/array.filter`) to support passing a simple
        //		string filter in addition to supporting filtering function
        //		objects.
        // filter:
        //		If a string, a CSS rule like ".thinger" or "div > span".
        // example:
        //		"regular" JS filter syntax as exposed in `dojo/_base/array.filter`:
        //		|	require(["dojo/query", "dojo/NodeList-dom"
        //		|	], function(query){
        //		|		query("*").filter(function(item){
        //		|			// highlight every paragraph
        //		|			return (item.nodeName == "p");
        //		|		}).style("backgroundColor", "yellow");
        //		|	});
        // example:
        //		the same filtering using a CSS selector
        //		|	require(["dojo/query", "dojo/NodeList-dom"
        //		|	], function(query){
        //		|		query("*").filter("p").styles("backgroundColor", "yellow");
        //		|	});
        var a = arguments, items = this, start = 0;
        if (typeof filter == 'string') {
          // inline'd type check
          items = query._filterResult(this, a[0]);
          if (a.length == 1) {
            // if we only got a string query, pass back the filtered results
            return items._stash(this);  // dojo/NodeList
          }
          // if we got a callback, run it over the filtered items
          start = 1;
        }
        return this._wrap(array.filter(items, a[start], a[start + 1]), this);  // dojo/NodeList
      },
      instantiate: function (declaredClass, properties) {
        // summary:
        //		Create a new instance of a specified class, using the
        //		specified properties and each node in the NodeList as a
        //		srcNodeRef.
        // example:
        //		Grabs all buttons in the page and converts them to dijit/form/Button's.
        //	|	var buttons = query("button").instantiate(Button, {showLabel: true});
        var c = lang.isFunction(declaredClass) ? declaredClass : lang.getObject(declaredClass);
        properties = properties || {};
        return this.forEach(function (node) {
          new c(properties, node);
        });  // dojo/NodeList
      },
      at: function () {
        // summary:
        //		Returns a new NodeList comprised of items in this NodeList
        //		at the given index or indices.
        //
        // index: Integer...
        //		One or more 0-based indices of items in the current
        //		NodeList. A negative index will start at the end of the
        //		list and go backwards.
        //
        // example:
        //	Shorten the list to the first, second, and third elements
        //	|	require(["dojo/query"
        //	|	], function(query){
        //	|		query("a").at(0, 1, 2).forEach(fn);
        //	|	});
        //
        // example:
        //	Retrieve the first and last elements of a unordered list:
        //	|	require(["dojo/query"
        //	|	], function(query){
        //	|		query("ul > li").at(0, -1).forEach(cb);
        //	|	});
        //
        // example:
        //	Do something for the first element only, but end() out back to
        //	the original list and continue chaining:
        //	|	require(["dojo/query"
        //	|	], function(query){
        //	|		query("a").at(0).onclick(fn).end().forEach(function(n){
        //	|			console.log(n); // all anchors on the page.
        //	|	})
        //	|	});
        var t = new this._NodeListCtor(0);
        forEach(arguments, function (i) {
          if (i < 0) {
            i = this.length + i;
          }
          if (this[i]) {
            t.push(this[i]);
          }
        }, this);
        return t._stash(this);  // dojo/NodeList
      }
    });
    function queryForEngine(engine, NodeList) {
      var query = function (query, root) {
        // summary:
        //		Returns nodes which match the given CSS selector, searching the
        //		entire document by default but optionally taking a node to scope
        //		the search by. Returns an instance of NodeList.
        if (typeof root == 'string') {
          root = dom.byId(root);
          if (!root) {
            return new NodeList([]);
          }
        }
        var results = typeof query == 'string' ? engine(query, root) : query ? query.end && query.on ? query : [query] : [];
        if (results.end && results.on) {
          // already wrapped
          return results;
        }
        return new NodeList(results);
      };
      query.matches = engine.match || function (node, selector, root) {
        // summary:
        //		Test to see if a node matches a selector
        return query.filter([node], selector, root).length > 0;
      };
      // the engine provides a filtering function, use it to for matching
      query.filter = engine.filter || function (nodes, selector, root) {
        // summary:
        //		Filters an array of nodes. Note that this does not guarantee to return a NodeList, just an array.
        return query(selector, root).filter(function (node) {
          return array.indexOf(nodes, node) > -1;
        });
      };
      if (typeof engine != 'function') {
        var search = engine.search;
        engine = function (selector, root) {
          // Slick does it backwards (or everyone else does it backwards, probably the latter)
          return search(root || document, selector);
        };
      }
      return query;
    }
    var query = queryForEngine(defaultEngine, NodeList);
    /*=====
    	query = function(selector, context){
    		// summary:
    		//		This modules provides DOM querying functionality. The module export is a function
    		//		that can be used to query for DOM nodes by CSS selector and returns a NodeList
    		//		representing the matching nodes.
    		// selector: String
    		//		A CSS selector to search for.
    		// context: String|DomNode?
    		//		An optional context to limit the searching scope. Only nodes under `context` will be
    		//		scanned.
    		// example:
    		//		add an onclick handler to every submit button in the document
    		//		which causes the form to be sent via Ajax instead:
    		//	|	require(["dojo/query", "dojo/request", "dojo/dom-form", "dojo/dom-construct", "dojo/dom-style"
    		//	|	], function(query, request, domForm, domConstruct, domStyle){
    		//	|		query("input[type='submit']").on("click", function(e){
    		//	|			e.preventDefault(); // prevent sending the form
    		//	|			var btn = e.target;
    		//	|			request.post("http://example.com/", {
    		//	|				data: domForm.toObject(btn.form)
    		//	|			}).then(function(response){
    		//	|				// replace the form with the response
    		//	|				domConstruct.create(div, {innerHTML: response}, btn.form, "after");
    		//	|				domStyle.set(btn.form, "display", "none");
    		//	|			});
    		//	|		});
    		//	|	});
    		//
    		// description:
    		//		dojo/query is responsible for loading the appropriate query engine and wrapping
    		//		its results with a `NodeList`. You can use dojo/query with a specific selector engine
    		//		by using it as a plugin. For example, if you installed the sizzle package, you could
    		//		use it as the selector engine with:
    		//		|	require(["dojo/query!sizzle"], function(query){
    		//		|		query("div")...
    		//
    		//		The id after the ! can be a module id of the selector engine or one of the following values:
    		//
    		//		- acme: This is the default engine used by Dojo base, and will ensure that the full
    		//		Acme engine is always loaded.
    		//
    		//		- css2: If the browser has a native selector engine, this will be used, otherwise a
    		//		very minimal lightweight selector engine will be loaded that can do simple CSS2 selectors
    		//		(by #id, .class, tag, and [name=value] attributes, with standard child or descendant (>)
    		//		operators) and nothing more.
    		//
    		//		- css2.1: If the browser has a native selector engine, this will be used, otherwise the
    		//		full Acme engine will be loaded.
    		//
    		//		- css3: If the browser has a native selector engine with support for CSS3 pseudo
    		//		selectors (most modern browsers except IE8), this will be used, otherwise the
    		//		full Acme engine will be loaded.
    		//
    		//		- Or the module id of a selector engine can be used to explicitly choose the selector engine
    		//
    		//		For example, if you are using CSS3 pseudo selectors in module, you can specify that
    		//		you will need support them with:
    		//		|	require(["dojo/query!css3"], function(query){
    		//		|		query('#t > h3:nth-child(odd)')...
    		//
    		//		You can also choose the selector engine/load configuration by setting the query-selector:
    		//		For example:
    		//		|	<script data-dojo-config="query-selector:'css3'" src="dojo.js"></script>
    		//
    		return new NodeList(); // dojo/NodeList
    	 };
    	 =====*/
    // the query that is returned from this module is slightly different than dojo.query,
    // because dojo.query has to maintain backwards compatibility with returning a
    // true array which has performance problems. The query returned from the module
    // does not use true arrays, but rather inherits from Array, making it much faster to
    // instantiate.
    dojo.query = queryForEngine(defaultEngine, function (array) {
      // call it without the new operator to invoke the back-compat behavior that returns a true array
      return NodeList(array);  // dojo/NodeList
    });
    query.load = function (id, parentRequire, loaded) {
      // summary:
      //		can be used as AMD plugin to conditionally load new query engine
      // example:
      //	|	require(["dojo/query!custom"], function(qsa){
      //	|		// loaded selector/custom.js as engine
      //	|		qsa("#foobar").forEach(...);
      //	|	});
      loader.load(id, parentRequire, function (engine) {
        loaded(queryForEngine(engine, NodeList));
      });
    };
    dojo._filterQueryResult = query._filterResult = function (nodes, selector, root) {
      return new NodeList(query.filter(nodes, selector, root));
    };
    dojo.NodeList = query.NodeList = NodeList;
    return query;
  }(dojo__base_kernel, dojo_has, dojo_dom, dojo_on, dojo__base_array, dojo__base_lang, dojo_selector__loader, synchronite_libs_sizzle);
  dojo_Evented = function (aspect, on) {
    var after = aspect.after;
    function Evented() {
    }
    Evented.prototype = {
      on: function (type, listener) {
        return on.parse(this, type, listener, function (target, type) {
          return after(target, 'on' + type, listener, true);
        });
      },
      emit: function (type, event) {
        var args = [this];
        args.push.apply(args, arguments);
        return on.emit.apply(on, args);
      }
    };
    return Evented;
  }(dojo_aspect, dojo_on);
  dojo_topic = function (Evented) {
    // module:
    //		dojo/topic
    var hub = new Evented();
    return {
      // summary:
      //		Pubsub hub.
      // example:
      //		| 	topic.subscribe("some/topic", function(event){
      //		|	... do something with event
      //		|	});
      //		|	topic.publish("some/topic", {name:"some event", ...});
      publish: function (topic, event) {
        // summary:
        //		Publishes a message to a topic on the pub/sub hub. All arguments after
        //		the first will be passed to the subscribers, so any number of arguments
        //		can be provided (not just event).
        // topic: String
        //		The name of the topic to publish to
        // event: Object
        //		An event to distribute to the topic listeners
        return hub.emit.apply(hub, arguments);
      },
      subscribe: function (topic, listener) {
        // summary:
        //		Subscribes to a topic on the pub/sub hub
        // topic: String
        //		The topic to subscribe to
        // listener: Function
        //		A function to call when a message is published to the given topic
        return hub.on.apply(hub, arguments);
      }
    };
  }(dojo_Evented);
  dojo_mouse = function (dojo, on, has, dom, win) {
    // module:
    //		dojo/mouse
    has.add('dom-quirks', win.doc && win.doc.compatMode == 'BackCompat');
    has.add('events-mouseenter', win.doc && 'onmouseenter' in win.doc.createElement('div'));
    has.add('events-mousewheel', win.doc && 'onmousewheel' in win.doc);
    var mouseButtons;
    if (has('dom-quirks') && has('ie') || !has('dom-addeventlistener')) {
      mouseButtons = {
        LEFT: 1,
        MIDDLE: 4,
        RIGHT: 2,
        // helper functions
        isButton: function (e, button) {
          return e.button & button;
        },
        isLeft: function (e) {
          return e.button & 1;
        },
        isMiddle: function (e) {
          return e.button & 4;
        },
        isRight: function (e) {
          return e.button & 2;
        }
      };
    } else {
      mouseButtons = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        // helper functions
        isButton: function (e, button) {
          return e.button == button;
        },
        isLeft: function (e) {
          return e.button == 0;
        },
        isMiddle: function (e) {
          return e.button == 1;
        },
        isRight: function (e) {
          return e.button == 2;
        }
      };
    }
    dojo.mouseButtons = mouseButtons;
    /*=====
    	dojo.mouseButtons = {
    		// LEFT: Number
    		//		Numeric value of the left mouse button for the platform.
    		LEFT:   0,
    		// MIDDLE: Number
    		//		Numeric value of the middle mouse button for the platform.
    		MIDDLE: 1,
    		// RIGHT: Number
    		//		Numeric value of the right mouse button for the platform.
    		RIGHT:  2,
    
    		isButton: function(e, button){
    			// summary:
    			//		Checks an event object for a pressed button
    			// e: Event
    			//		Event object to examine
    			// button: Number
    			//		The button value (example: dojo.mouseButton.LEFT)
    			return e.button == button; // Boolean
    		},
    		isLeft: function(e){
    			// summary:
    			//		Checks an event object for the pressed left button
    			// e: Event
    			//		Event object to examine
    			return e.button == 0; // Boolean
    		},
    		isMiddle: function(e){
    			// summary:
    			//		Checks an event object for the pressed middle button
    			// e: Event
    			//		Event object to examine
    			return e.button == 1; // Boolean
    		},
    		isRight: function(e){
    			// summary:
    			//		Checks an event object for the pressed right button
    			// e: Event
    			//		Event object to examine
    			return e.button == 2; // Boolean
    		}
    	};
    =====*/
    function eventHandler(type, selectHandler) {
      // emulation of mouseenter/leave with mouseover/out using descendant checking
      var handler = function (node, listener) {
        return on(node, type, function (evt) {
          if (selectHandler) {
            return selectHandler(evt, listener);
          }
          if (!dom.isDescendant(evt.relatedTarget, node)) {
            return listener.call(this, evt);
          }
        });
      };
      handler.bubble = function (select) {
        return eventHandler(type, function (evt, listener) {
          // using a selector, use the select function to determine if the mouse moved inside the selector and was previously outside the selector
          var target = select(evt.target);
          var relatedTarget = evt.relatedTarget;
          if (target && target != (relatedTarget && relatedTarget.nodeType == 1 && select(relatedTarget))) {
            return listener.call(target, evt);
          }
        });
      };
      return handler;
    }
    var wheel;
    if (has('events-mousewheel')) {
      wheel = 'mousewheel';
    } else {
      //firefox
      wheel = function (node, listener) {
        return on(node, 'DOMMouseScroll', function (evt) {
          evt.wheelDelta = -evt.detail;
          listener.call(this, evt);
        });
      };
    }
    return {
      // summary:
      //		This module provide mouse event handling utility functions and exports
      //		mouseenter and mouseleave event emulation.
      // example:
      //		To use these events, you register a mouseenter like this:
      //		|	define(["dojo/on", "dojo/mouse"], function(on, mouse){
      //		|		on(targetNode, mouse.enter, function(event){
      //		|			dojo.addClass(targetNode, "highlighted");
      //		|		});
      //		|		on(targetNode, mouse.leave, function(event){
      //		|			dojo.removeClass(targetNode, "highlighted");
      //		|		});
      _eventHandler: eventHandler,
      // for dojo/touch
      // enter: Synthetic Event
      //		This is an extension event for the mouseenter that IE provides, emulating the
      //		behavior on other browsers.
      enter: eventHandler('mouseover'),
      // leave: Synthetic Event
      //		This is an extension event for the mouseleave that IE provides, emulating the
      //		behavior on other browsers.
      leave: eventHandler('mouseout'),
      // wheel: Normalized Mouse Wheel Event
      //		This is an extension event for the mousewheel that non-Mozilla browsers provide,
      //		emulating the behavior on Mozilla based browsers.
      wheel: wheel,
      isLeft: mouseButtons.isLeft,
      /*=====
      isLeft: function(){
      	// summary:
      	//		Test an event object (from a mousedown event) to see if the left button was pressed.
      },
      =====*/
      isMiddle: mouseButtons.isMiddle,
      /*=====
       isMiddle: function(){
      	 // summary:
      	 //		Test an event object (from a mousedown event) to see if the middle button was pressed.
       },
       =====*/
      isRight: mouseButtons.isRight
    };
  }(dojo__base_kernel, dojo_on, dojo_has, dojo_dom, dojo__base_window);
  dojo_keys = function (dojo, has) {
    // module:
    //		dojo/keys
    return dojo.keys = {
      // summary:
      //		Definitions for common key values.  Client code should test keyCode against these named constants,
      //		as the actual codes can vary by browser.
      BACKSPACE: 8,
      TAB: 9,
      CLEAR: 12,
      ENTER: 13,
      SHIFT: 16,
      CTRL: 17,
      ALT: 18,
      META: has('webkit') ? 91 : 224,
      // the apple key on macs
      PAUSE: 19,
      CAPS_LOCK: 20,
      ESCAPE: 27,
      SPACE: 32,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      LEFT_ARROW: 37,
      UP_ARROW: 38,
      RIGHT_ARROW: 39,
      DOWN_ARROW: 40,
      INSERT: 45,
      DELETE: 46,
      HELP: 47,
      LEFT_WINDOW: 91,
      RIGHT_WINDOW: 92,
      SELECT: 93,
      NUMPAD_0: 96,
      NUMPAD_1: 97,
      NUMPAD_2: 98,
      NUMPAD_3: 99,
      NUMPAD_4: 100,
      NUMPAD_5: 101,
      NUMPAD_6: 102,
      NUMPAD_7: 103,
      NUMPAD_8: 104,
      NUMPAD_9: 105,
      NUMPAD_MULTIPLY: 106,
      NUMPAD_PLUS: 107,
      NUMPAD_ENTER: 108,
      NUMPAD_MINUS: 109,
      NUMPAD_PERIOD: 110,
      NUMPAD_DIVIDE: 111,
      F1: 112,
      F2: 113,
      F3: 114,
      F4: 115,
      F5: 116,
      F6: 117,
      F7: 118,
      F8: 119,
      F9: 120,
      F10: 121,
      F11: 122,
      F12: 123,
      F13: 124,
      F14: 125,
      F15: 126,
      NUM_LOCK: 144,
      SCROLL_LOCK: 145,
      UP_DPAD: 175,
      DOWN_DPAD: 176,
      LEFT_DPAD: 177,
      RIGHT_DPAD: 178,
      // virtual key mapping
      copyKey: has('mac') && !has('air') ? has('safari') ? 91 : 224 : 17
    };
  }(dojo__base_kernel, dojo_sniff);
  dojo__base_connect = function (dojo, on, hub, aspect, eventModule, mouse, has, lang) {
    // module:
    //		dojo/_base/connect
    has.add('events-keypress-typed', function () {
      // keypresses should only occur a printable character is hit
      var testKeyEvent = { charCode: 0 };
      try {
        testKeyEvent = document.createEvent('KeyboardEvent');
        (testKeyEvent.initKeyboardEvent || testKeyEvent.initKeyEvent).call(testKeyEvent, 'keypress', true, true, null, false, false, false, false, 9, 3);
      } catch (e) {
      }
      return testKeyEvent.charCode == 0 && !has('opera');
    });
    function connect_(obj, event, context, method, dontFix) {
      method = lang.hitch(context, method);
      if (!obj || !(obj.addEventListener || obj.attachEvent)) {
        // it is a not a DOM node and we are using the dojo.connect style of treating a
        // method like an event, must go right to aspect
        return aspect.after(obj || dojo.global, event, method, true);
      }
      if (typeof event == 'string' && event.substring(0, 2) == 'on') {
        event = event.substring(2);
      }
      if (!obj) {
        obj = dojo.global;
      }
      if (!dontFix) {
        switch (event) {
        // dojo.connect has special handling for these event types
        case 'keypress':
          event = keypress;
          break;
        case 'mouseenter':
          event = mouse.enter;
          break;
        case 'mouseleave':
          event = mouse.leave;
          break;
        }
      }
      return on(obj, event, method, dontFix);
    }
    var _punctMap = {
      106: 42,
      111: 47,
      186: 59,
      187: 43,
      188: 44,
      189: 45,
      190: 46,
      191: 47,
      192: 96,
      219: 91,
      220: 92,
      221: 93,
      222: 39,
      229: 113
    };
    var evtCopyKey = has('mac') ? 'metaKey' : 'ctrlKey';
    var _synthesizeEvent = function (evt, props) {
      var faux = lang.mixin({}, evt, props);
      setKeyChar(faux);
      // FIXME: would prefer to use lang.hitch: lang.hitch(evt, evt.preventDefault);
      // but it throws an error when preventDefault is invoked on Safari
      // does Event.preventDefault not support "apply" on Safari?
      faux.preventDefault = function () {
        evt.preventDefault();
      };
      faux.stopPropagation = function () {
        evt.stopPropagation();
      };
      return faux;
    };
    function setKeyChar(evt) {
      evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
      evt.charOrCode = evt.keyChar || evt.keyCode;
    }
    var keypress;
    if (has('events-keypress-typed')) {
      // this emulates Firefox's keypress behavior where every keydown can correspond to a keypress
      var _trySetKeyCode = function (e, code) {
        try {
          // squelch errors when keyCode is read-only
          // (e.g. if keyCode is ctrl or shift)
          return e.keyCode = code;
        } catch (e) {
          return 0;
        }
      };
      keypress = function (object, listener) {
        var keydownSignal = on(object, 'keydown', function (evt) {
          // munge key/charCode
          var k = evt.keyCode;
          // These are Windows Virtual Key Codes
          // http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/WinUI/WindowsUserInterface/UserInput/VirtualKeyCodes.asp
          var unprintable = k != 13 && k != 32 && (k != 27 || !has('ie')) && (k < 48 || k > 90) && (k < 96 || k > 111) && (k < 186 || k > 192) && (k < 219 || k > 222) && k != 229;
          // synthesize keypress for most unprintables and CTRL-keys
          if (unprintable || evt.ctrlKey) {
            var c = unprintable ? 0 : k;
            if (evt.ctrlKey) {
              if (k == 3 || k == 13) {
                return listener.call(evt.currentTarget, evt);  // IE will post CTRL-BREAK, CTRL-ENTER as keypress natively
              } else if (c > 95 && c < 106) {
                c -= 48;  // map CTRL-[numpad 0-9] to ASCII
              } else if (!evt.shiftKey && (c >= 65 && c <= 90)) {
                c += 32;  // map CTRL-[A-Z] to lowercase
              } else {
                c = _punctMap[c] || c;  // map other problematic CTRL combinations to ASCII
              }
            }
            // simulate a keypress event
            var faux = _synthesizeEvent(evt, {
              type: 'keypress',
              faux: true,
              charCode: c
            });
            listener.call(evt.currentTarget, faux);
            if (has('ie')) {
              _trySetKeyCode(evt, faux.keyCode);
            }
          }
        });
        var keypressSignal = on(object, 'keypress', function (evt) {
          var c = evt.charCode;
          c = c >= 32 ? c : 0;
          evt = _synthesizeEvent(evt, {
            charCode: c,
            faux: true
          });
          return listener.call(this, evt);
        });
        return {
          remove: function () {
            keydownSignal.remove();
            keypressSignal.remove();
          }
        };
      };
    } else {
      if (has('opera')) {
        keypress = function (object, listener) {
          return on(object, 'keypress', function (evt) {
            var c = evt.which;
            if (c == 3) {
              c = 99;  // Mozilla maps CTRL-BREAK to CTRL-c
            }
            // can't trap some keys at all, like INSERT and DELETE
            // there is no differentiating info between DELETE and ".", or INSERT and "-"
            c = c < 32 && !evt.shiftKey ? 0 : c;
            if (evt.ctrlKey && !evt.shiftKey && c >= 65 && c <= 90) {
              // lowercase CTRL-[A-Z] keys
              c += 32;
            }
            return listener.call(this, _synthesizeEvent(evt, { charCode: c }));
          });
        };
      } else {
        keypress = function (object, listener) {
          return on(object, 'keypress', function (evt) {
            setKeyChar(evt);
            return listener.call(this, evt);
          });
        };
      }
    }
    var connect = {
      // summary:
      //		This module defines the dojo.connect API.
      //		This modules also provides keyboard event handling helpers.
      //		This module exports an extension event for emulating Firefox's keypress handling.
      //		However, this extension event exists primarily for backwards compatibility and
      //		is not recommended. WebKit and IE uses an alternate keypress handling (only
      //		firing for printable characters, to distinguish from keydown events), and most
      //		consider the WebKit/IE behavior more desirable.
      _keypress: keypress,
      connect: function (obj, event, context, method, dontFix) {
        // summary:
        //		`dojo.connect` is a deprecated event handling and delegation method in
        //		Dojo. It allows one function to "listen in" on the execution of
        //		any other, triggering the second whenever the first is called. Many
        //		listeners may be attached to a function, and source functions may
        //		be either regular function calls or DOM events.
        //
        // description:
        //		Connects listeners to actions, so that after event fires, a
        //		listener is called with the same arguments passed to the original
        //		function.
        //
        //		Since `dojo.connect` allows the source of events to be either a
        //		"regular" JavaScript function or a DOM event, it provides a uniform
        //		interface for listening to all the types of events that an
        //		application is likely to deal with though a single, unified
        //		interface. DOM programmers may want to think of it as
        //		"addEventListener for everything and anything".
        //
        //		When setting up a connection, the `event` parameter must be a
        //		string that is the name of the method/event to be listened for. If
        //		`obj` is null, `kernel.global` is assumed, meaning that connections
        //		to global methods are supported but also that you may inadvertently
        //		connect to a global by passing an incorrect object name or invalid
        //		reference.
        //
        //		`dojo.connect` generally is forgiving. If you pass the name of a
        //		function or method that does not yet exist on `obj`, connect will
        //		not fail, but will instead set up a stub method. Similarly, null
        //		arguments may simply be omitted such that fewer than 4 arguments
        //		may be required to set up a connection See the examples for details.
        //
        //		The return value is a handle that is needed to
        //		remove this connection with `dojo.disconnect`.
        //
        // obj: Object?
        //		The source object for the event function.
        //		Defaults to `kernel.global` if null.
        //		If obj is a DOM node, the connection is delegated
        //		to the DOM event manager (unless dontFix is true).
        //
        // event: String
        //		String name of the event function in obj.
        //		I.e. identifies a property `obj[event]`.
        //
        // context: Object|null
        //		The object that method will receive as "this".
        //
        //		If context is null and method is a function, then method
        //		inherits the context of event.
        //
        //		If method is a string then context must be the source
        //		object object for method (context[method]). If context is null,
        //		kernel.global is used.
        //
        // method: String|Function
        //		A function reference, or name of a function in context.
        //		The function identified by method fires after event does.
        //		method receives the same arguments as the event.
        //		See context argument comments for information on method's scope.
        //
        // dontFix: Boolean?
        //		If obj is a DOM node, set dontFix to true to prevent delegation
        //		of this connection to the DOM event manager.
        //
        // example:
        //		When obj.onchange(), do ui.update():
        //	|	dojo.connect(obj, "onchange", ui, "update");
        //	|	dojo.connect(obj, "onchange", ui, ui.update); // same
        //
        // example:
        //		Using return value for disconnect:
        //	|	var link = dojo.connect(obj, "onchange", ui, "update");
        //	|	...
        //	|	dojo.disconnect(link);
        //
        // example:
        //		When onglobalevent executes, watcher.handler is invoked:
        //	|	dojo.connect(null, "onglobalevent", watcher, "handler");
        //
        // example:
        //		When ob.onCustomEvent executes, customEventHandler is invoked:
        //	|	dojo.connect(ob, "onCustomEvent", null, "customEventHandler");
        //	|	dojo.connect(ob, "onCustomEvent", "customEventHandler"); // same
        //
        // example:
        //		When ob.onCustomEvent executes, customEventHandler is invoked
        //		with the same scope (this):
        //	|	dojo.connect(ob, "onCustomEvent", null, customEventHandler);
        //	|	dojo.connect(ob, "onCustomEvent", customEventHandler); // same
        //
        // example:
        //		When globalEvent executes, globalHandler is invoked
        //		with the same scope (this):
        //	|	dojo.connect(null, "globalEvent", null, globalHandler);
        //	|	dojo.connect("globalEvent", globalHandler); // same
        // normalize arguments
        var a = arguments, args = [], i = 0;
        // if a[0] is a String, obj was omitted
        args.push(typeof a[0] == 'string' ? null : a[i++], a[i++]);
        // if the arg-after-next is a String or Function, context was NOT omitted
        var a1 = a[i + 1];
        args.push(typeof a1 == 'string' || typeof a1 == 'function' ? a[i++] : null, a[i++]);
        // absorb any additional arguments
        for (var l = a.length; i < l; i++) {
          args.push(a[i]);
        }
        return connect_.apply(this, args);
      },
      disconnect: function (handle) {
        // summary:
        //		Remove a link created by dojo.connect.
        // description:
        //		Removes the connection between event and the method referenced by handle.
        // handle: Handle
        //		the return value of the dojo.connect call that created the connection.
        if (handle) {
          handle.remove();
        }
      },
      subscribe: function (topic, context, method) {
        // summary:
        //		Attach a listener to a named topic. The listener function is invoked whenever the
        //		named topic is published (see: dojo.publish).
        //		Returns a handle which is needed to unsubscribe this listener.
        // topic: String
        //		The topic to which to subscribe.
        // context: Object?
        //		Scope in which method will be invoked, or null for default scope.
        // method: String|Function
        //		The name of a function in context, or a function reference. This is the function that
        //		is invoked when topic is published.
        // example:
        //	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); });
        //	|	dojo.publish("alerts", [ "read this", "hello world" ]);
        return hub.subscribe(topic, lang.hitch(context, method));
      },
      publish: function (topic, args) {
        // summary:
        //		Invoke all listener method subscribed to topic.
        // topic: String
        //		The name of the topic to publish.
        // args: Array?
        //		An array of arguments. The arguments will be applied
        //		to each topic subscriber (as first class parameters, via apply).
        // example:
        //	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
        //	|	dojo.publish("alerts", [ "read this", "hello world" ]);
        return hub.publish.apply(hub, [topic].concat(args));
      },
      connectPublisher: function (topic, obj, event) {
        // summary:
        //		Ensure that every time obj.event() is called, a message is published
        //		on the topic. Returns a handle which can be passed to
        //		dojo.disconnect() to disable subsequent automatic publication on
        //		the topic.
        // topic: String
        //		The name of the topic to publish.
        // obj: Object?
        //		The source object for the event function. Defaults to kernel.global
        //		if null.
        // event: String
        //		The name of the event function in obj.
        //		I.e. identifies a property obj[event].
        // example:
        //	|	dojo.connectPublisher("/ajax/start", dojo, "xhrGet");
        var pf = function () {
          connect.publish(topic, arguments);
        };
        return event ? connect.connect(obj, event, pf) : connect.connect(obj, pf);  //Handle
      },
      isCopyKey: function (e) {
        // summary:
        //		Checks an event for the copy key (meta on Mac, and ctrl anywhere else)
        // e: Event
        //		Event object to examine
        return e[evtCopyKey];  // Boolean
      }
    };
    connect.unsubscribe = connect.disconnect;
    /*=====
     connect.unsubscribe = function(handle){
    	 // summary:
    	 //		Remove a topic listener.
    	 // handle: Handle
    	 //		The handle returned from a call to subscribe.
    	 // example:
    	 //	|	var alerter = dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
    	 //	|	...
    	 //	|	dojo.unsubscribe(alerter);
     };
     =====*/
    has('extend-dojo') && lang.mixin(dojo, connect);
    return connect;
  }(dojo__base_kernel, dojo_on, dojo_topic, dojo_aspect, dojo__base_event, dojo_mouse, dojo__base_sniff, dojo__base_lang);
  dojo_dom_prop = function (exports, dojo, has, lang, dom, style, ctr, conn) {
    // module:
    //		dojo/dom-prop
    // summary:
    //		This module defines the core dojo DOM properties API.
    // TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42
    // =============================
    // Element properties Functions
    // =============================
    // helper to connect events
    var _evtHdlrMap = {}, _ctr = 0, _attrId = dojo._scopeName + 'attrid';
    has.add('dom-textContent', function (global, doc, element) {
      return 'textContent' in element;
    });
    exports.names = {
      // properties renamed to avoid clashes with reserved words
      'class': 'className',
      'for': 'htmlFor',
      // properties written as camelCase
      tabindex: 'tabIndex',
      readonly: 'readOnly',
      colspan: 'colSpan',
      frameborder: 'frameBorder',
      rowspan: 'rowSpan',
      textcontent: 'textContent',
      valuetype: 'valueType'
    };
    function getText(node) {
      // summary:
      //		recursion method for get('textContent') to use. Gets text value for a node.
      // description:
      //		Juse uses nodedValue so things like <br/> tags do not end up in
      //		the text as any sort of line return.
      var text = '', ch = node.childNodes;
      for (var i = 0, n; n = ch[i]; i++) {
        //Skip comments.
        if (n.nodeType != 8) {
          if (n.nodeType == 1) {
            text += getText(n);
          } else {
            text += n.nodeValue;
          }
        }
      }
      return text;
    }
    exports.get = function getProp(node, name) {
      // summary:
      //		Gets a property on an HTML element.
      // description:
      //		Handles normalized getting of properties on DOM nodes.
      //
      // node: DOMNode|String
      //		id or reference to the element to get the property on
      // name: String
      //		the name of the property to get.
      // returns:
      //		the value of the requested property or its default value
      //
      // example:
      //	|	// get the current value of the "foo" property on a node
      //	|	require(["dojo/dom-prop", "dojo/dom"], function(domProp, dom){
      //	|		domProp.get(dom.byId("nodeId"), "foo");
      //	|		// or we can just pass the id:
      //	|		domProp.get("nodeId", "foo");
      //	|	});
      node = dom.byId(node);
      var lc = name.toLowerCase(), propName = exports.names[lc] || name;
      if (propName == 'textContent' && !has('dom-textContent')) {
        return getText(node);
      }
      return node[propName];  // Anything
    };
    exports.set = function setProp(node, name, value) {
      // summary:
      //		Sets a property on an HTML element.
      // description:
      //		Handles normalized setting of properties on DOM nodes.
      //
      //		When passing functions as values, note that they will not be
      //		directly assigned to slots on the node, but rather the default
      //		behavior will be removed and the new behavior will be added
      //		using `dojo.connect()`, meaning that event handler properties
      //		will be normalized and that some caveats with regards to
      //		non-standard behaviors for onsubmit apply. Namely that you
      //		should cancel form submission using `dojo.stopEvent()` on the
      //		passed event object instead of returning a boolean value from
      //		the handler itself.
      // node: DOMNode|String
      //		id or reference to the element to set the property on
      // name: String|Object
      //		the name of the property to set, or a hash object to set
      //		multiple properties at once.
      // value: String?
      //		The value to set for the property
      // returns:
      //		the DOM node
      //
      // example:
      //	|	// use prop() to set the tab index
      //	|	require(["dojo/dom-prop"], function(domProp){
      //	|		domProp.set("nodeId", "tabIndex", 3);
      //	|	});
      //
      // example:
      //	Set multiple values at once, including event handlers:
      //	|	require(["dojo/dom-prop"], function(domProp){
      //	|		domProp.set("formId", {
      //	|			"foo": "bar",
      //	|			"tabIndex": -1,
      //	|			"method": "POST",
      //	|		});
      //	|	});
      node = dom.byId(node);
      var l = arguments.length;
      if (l == 2 && typeof name != 'string') {
        // inline'd type check
        // the object form of setter: the 2nd argument is a dictionary
        for (var x in name) {
          exports.set(node, x, name[x]);
        }
        return node;  // DomNode
      }
      var lc = name.toLowerCase(), propName = exports.names[lc] || name;
      if (propName == 'style' && typeof value != 'string') {
        // inline'd type check
        // special case: setting a style
        style.set(node, value);
        return node;  // DomNode
      }
      if (propName == 'innerHTML') {
        // special case: assigning HTML
        // the hash lists elements with read-only innerHTML on IE
        if (has('ie') && node.tagName.toLowerCase() in {
            col: 1,
            colgroup: 1,
            table: 1,
            tbody: 1,
            tfoot: 1,
            thead: 1,
            tr: 1,
            title: 1
          }) {
          ctr.empty(node);
          node.appendChild(ctr.toDom(value, node.ownerDocument));
        } else {
          node[propName] = value;
        }
        return node;  // DomNode
      }
      if (propName == 'textContent' && !has('dom-textContent')) {
        ctr.empty(node);
        node.appendChild(node.ownerDocument.createTextNode(value));
        return node;
      }
      if (lang.isFunction(value)) {
        // special case: assigning an event handler
        // clobber if we can
        var attrId = node[_attrId];
        if (!attrId) {
          attrId = _ctr++;
          node[_attrId] = attrId;
        }
        if (!_evtHdlrMap[attrId]) {
          _evtHdlrMap[attrId] = {};
        }
        var h = _evtHdlrMap[attrId][propName];
        if (h) {
          //h.remove();
          conn.disconnect(h);
        } else {
          try {
            delete node[propName];
          } catch (e) {
          }
        }
        // ensure that event objects are normalized, etc.
        if (value) {
          //_evtHdlrMap[attrId][propName] = on(node, propName, value);
          _evtHdlrMap[attrId][propName] = conn.connect(node, propName, value);
        } else {
          node[propName] = null;
        }
        return node;  // DomNode
      }
      node[propName] = value;
      return node;  // DomNode
    };
    return exports;
  }(dojo_dom_prop, dojo__base_kernel, dojo_sniff, dojo__base_lang, dojo_dom, dojo_dom_style, dojo_dom_construct, dojo__base_connect);
  dojo_dom_attr = function (exports, has, lang, dom, style, prop) {
    // module:
    //		dojo/dom-attr
    // summary:
    //		This module defines the core dojo DOM attributes API.
    // TODOC: summary not showing up in output see https://github.com/csnover/js-doc-parse/issues/42
    // =============================
    // Element attribute Functions
    // =============================
    // This module will be obsolete soon. Use dojo/prop instead.
    // dojo/dom-attr.get() should conform to http://www.w3.org/TR/DOM-Level-2-Core/
    // attribute-related functions (to be obsolete soon)
    var forcePropNames = {
        innerHTML: 1,
        textContent: 1,
        className: 1,
        htmlFor: has('ie'),
        value: 1
      }, attrNames = {
        // original attribute names
        classname: 'class',
        htmlfor: 'for',
        // for IE
        tabindex: 'tabIndex',
        readonly: 'readOnly'
      };
    function _hasAttr(node, name) {
      var attr = node.getAttributeNode && node.getAttributeNode(name);
      return !!attr && attr.specified;  // Boolean
    }
    // There is a difference in the presence of certain properties and their default values
    // between browsers. For example, on IE "disabled" is present on all elements,
    // but it is value is "false"; "tabIndex" of <div> returns 0 by default on IE, yet other browsers
    // can return -1.
    exports.has = function hasAttr(node, name) {
      // summary:
      //		Returns true if the requested attribute is specified on the
      //		given element, and false otherwise.
      // node: DOMNode|String
      //		id or reference to the element to check
      // name: String
      //		the name of the attribute
      // returns: Boolean
      //		true if the requested attribute is specified on the
      //		given element, and false otherwise
      var lc = name.toLowerCase();
      return forcePropNames[prop.names[lc] || name] || _hasAttr(dom.byId(node), attrNames[lc] || name);  // Boolean
    };
    exports.get = function getAttr(node, name) {
      // summary:
      //		Gets an attribute on an HTML element.
      // description:
      //		Handles normalized getting of attributes on DOM Nodes.
      // node: DOMNode|String
      //		id or reference to the element to get the attribute on
      // name: String
      //		the name of the attribute to get.
      // returns:
      //		the value of the requested attribute or null if that attribute does not have a specified or
      //		default value;
      //
      // example:
      //	|	// get the current value of the "foo" attribute on a node
      //	|	require(["dojo/dom-attr", "dojo/dom"], function(domAttr, dom){
      //	|		domAttr.get(dom.byId("nodeId"), "foo");
      //	|		// or we can just pass the id:
      //	|		domAttr.get("nodeId", "foo");
      //	|	});	
      //	|	
      node = dom.byId(node);
      var lc = name.toLowerCase(), propName = prop.names[lc] || name, forceProp = forcePropNames[propName], value = node[propName];
      // should we access this attribute via a property or via getAttribute()?
      if (forceProp && typeof value != 'undefined') {
        // node's property
        return value;  // Anything
      }
      if (propName == 'textContent') {
        return prop.get(node, propName);
      }
      if (propName != 'href' && (typeof value == 'boolean' || lang.isFunction(value))) {
        // node's property
        return value;  // Anything
      }
      // node's attribute
      // we need _hasAttr() here to guard against IE returning a default value
      var attrName = attrNames[lc] || name;
      return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null;  // Anything
    };
    exports.set = function setAttr(node, name, value) {
      // summary:
      //		Sets an attribute on an HTML element.
      // description:
      //		Handles normalized setting of attributes on DOM Nodes.
      //
      //		When passing functions as values, note that they will not be
      //		directly assigned to slots on the node, but rather the default
      //		behavior will be removed and the new behavior will be added
      //		using `dojo.connect()`, meaning that event handler properties
      //		will be normalized and that some caveats with regards to
      //		non-standard behaviors for onsubmit apply. Namely that you
      //		should cancel form submission using `dojo.stopEvent()` on the
      //		passed event object instead of returning a boolean value from
      //		the handler itself.
      // node: DOMNode|String
      //		id or reference to the element to set the attribute on
      // name: String|Object
      //		the name of the attribute to set, or a hash of key-value pairs to set.
      // value: String?
      //		the value to set for the attribute, if the name is a string.
      // returns:
      //		the DOM node
      //
      // example:
      //	|	// use attr() to set the tab index
      //	|	require(["dojo/dom-attr"], function(domAttr){
      //	|		domAttr.set("nodeId", "tabIndex", 3);
      //	|	});
      //
      // example:
      //	Set multiple values at once, including event handlers:
      //	|	require(["dojo/dom-attr"],
      //	|	function(domAttr){
      //	|		domAttr.set("formId", {
      //	|			"foo": "bar",
      //	|			"tabIndex": -1,
      //	|			"method": "POST"
      //	|		}
      //	|	});
      node = dom.byId(node);
      if (arguments.length == 2) {
        // inline'd type check
        // the object form of setter: the 2nd argument is a dictionary
        for (var x in name) {
          exports.set(node, x, name[x]);
        }
        return node;  // DomNode
      }
      var lc = name.toLowerCase(), propName = prop.names[lc] || name, forceProp = forcePropNames[propName];
      if (propName == 'style' && typeof value != 'string') {
        // inline'd type check
        // special case: setting a style
        style.set(node, value);
        return node;  // DomNode
      }
      if (forceProp || typeof value == 'boolean' || lang.isFunction(value)) {
        return prop.set(node, name, value);
      }
      // node's attribute
      node.setAttribute(attrNames[lc] || name, value);
      return node;  // DomNode
    };
    exports.remove = function removeAttr(node, name) {
      // summary:
      //		Removes an attribute from an HTML element.
      // node: DOMNode|String
      //		id or reference to the element to remove the attribute from
      // name: String
      //		the name of the attribute to remove
      dom.byId(node).removeAttribute(attrNames[name.toLowerCase()] || name);
    };
    exports.getNodeProp = function getNodeProp(node, name) {
      // summary:
      //		Returns an effective value of a property or an attribute.
      // node: DOMNode|String
      //		id or reference to the element to remove the attribute from
      // name: String
      //		the name of the attribute
      // returns:
      //		the value of the attribute
      node = dom.byId(node);
      var lc = name.toLowerCase(), propName = prop.names[lc] || name;
      if (propName in node && propName != 'href') {
        // node's property
        return node[propName];  // Anything
      }
      // node's attribute
      var attrName = attrNames[lc] || name;
      return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null;  // Anything
    };
    return exports;
  }(dojo_dom_attr, dojo_sniff, dojo__base_lang, dojo_dom, dojo_dom_style, dojo_dom_prop);
  dojo_dom_construct = function (exports, dojo, has, win, dom, attr) {
    // module:
    //		dojo/dom-construct
    // summary:
    //		This module defines the core dojo DOM construction API.
    // TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42
    // support stuff for toDom()
    var tagWrap = {
        option: ['select'],
        tbody: ['table'],
        thead: ['table'],
        tfoot: ['table'],
        tr: [
          'table',
          'tbody'
        ],
        td: [
          'table',
          'tbody',
          'tr'
        ],
        th: [
          'table',
          'thead',
          'tr'
        ],
        legend: ['fieldset'],
        caption: ['table'],
        colgroup: ['table'],
        col: [
          'table',
          'colgroup'
        ],
        li: ['ul']
      }, reTag = /<\s*([\w\:]+)/, masterNode = {}, masterNum = 0, masterName = '__' + dojo._scopeName + 'ToCobrowseDomId';
    //PATCHED
    // generate start/end tag strings to use
    // for the injection for each special tag wrap case.
    for (var param in tagWrap) {
      if (tagWrap.hasOwnProperty(param)) {
        var tw = tagWrap[param];
        tw.pre = param == 'option' ? '<select multiple="multiple">' : '<' + tw.join('><') + '>';
        tw.post = '</' + tw.reverse().join('></') + '>';  // the last line is destructive: it reverses the array,
                                                          // but we don't care at this point
      }
    }
    var html5domfix;
    if (has('ie') <= 8) {
      html5domfix = function (doc) {
        doc.__dojo_html5_tested = 'yes';
        var div = create('div', {
          innerHTML: '<nav>a</nav>',
          style: { visibility: 'hidden' }
        }, doc.body);
        if (div.childNodes.length !== 1) {
          ('abbr article aside audio canvas details figcaption figure footer header ' + 'hgroup mark meter nav output progress section summary time video').replace(/\b\w+\b/g, function (n) {
            doc.createElement(n);
          });
        }
        destroy(div);
      };
    }
    function _insertBefore(node, ref) {
      var parent = ref.parentNode;
      if (parent) {
        parent.insertBefore(node, ref);
      }
    }
    function _insertAfter(node, ref) {
      // summary:
      //		Try to insert node after ref
      var parent = ref.parentNode;
      if (parent) {
        if (parent.lastChild == ref) {
          parent.appendChild(node);
        } else {
          parent.insertBefore(node, ref.nextSibling);
        }
      }
    }
    exports.toDom = function toDom(frag, doc) {
      // summary:
      //		instantiates an HTML fragment returning the corresponding DOM.
      // frag: String
      //		the HTML fragment
      // doc: DocumentNode?
      //		optional document to use when creating DOM nodes, defaults to
      //		dojo/_base/window.doc if not specified.
      // returns:
      //		Document fragment, unless it's a single node in which case it returns the node itself
      // example:
      //		Create a table row:
      //	|	require(["dojo/dom-construct"], function(domConstruct){
      //	|		var tr = domConstruct.toDom("<tr><td>First!</td></tr>");
      //	|	});
      doc = doc || win.doc;
      var masterId = doc[masterName];
      if (!masterId) {
        doc[masterName] = masterId = ++masterNum + '';
        masterNode[masterId] = doc.createElement('div');
      }
      if (has('ie') <= 8) {
        if (!doc.__dojo_html5_tested && doc.body) {
          html5domfix(doc);
        }
      }
      // make sure the frag is a string.
      frag += '';
      // find the starting tag, and get node wrapper
      var match = frag.match(reTag), tag = match ? match[1].toLowerCase() : '', master = masterNode[masterId], wrap, i, fc, df;
      if (match && tagWrap[tag]) {
        wrap = tagWrap[tag];
        master.innerHTML = wrap.pre + frag + wrap.post;
        for (i = wrap.length; i; --i) {
          master = master.firstChild;
        }
      } else {
        master.innerHTML = frag;
      }
      // one node shortcut => return the node itself
      if (master.childNodes.length == 1) {
        return master.removeChild(master.firstChild);  // DOMNode
      }
      // return multiple nodes as a document fragment
      df = doc.createDocumentFragment();
      while (fc = master.firstChild) {
        // intentional assignment
        df.appendChild(fc);
      }
      return df;  // DocumentFragment
    };
    exports.place = function place(node, refNode, position) {
      // summary:
      //		Attempt to insert node into the DOM, choosing from various positioning options.
      //		Returns the first argument resolved to a DOM node.
      // node: DOMNode|DocumentFragment|String
      //		id or node reference, or HTML fragment starting with "<" to place relative to refNode
      // refNode: DOMNode|String
      //		id or node reference to use as basis for placement
      // position: String|Number?
      //		string noting the position of node relative to refNode or a
      //		number indicating the location in the childNodes collection of refNode.
      //		Accepted string values are:
      //
      //		- before
      //		- after
      //		- replace
      //		- only
      //		- first
      //		- last
      //
      //		"first" and "last" indicate positions as children of refNode, "replace" replaces refNode,
      //		"only" replaces all children.  position defaults to "last" if not specified
      // returns: DOMNode
      //		Returned values is the first argument resolved to a DOM node.
      //
      //		.place() is also a method of `dojo/NodeList`, allowing `dojo/query` node lookups.
      // example:
      //		Place a node by string id as the last child of another node by string id:
      //	|	require(["dojo/dom-construct"], function(domConstruct){
      //	|		domConstruct.place("someNode", "anotherNode");
      //	|	});
      // example:
      //		Place a node by string id before another node by string id
      //	|	require(["dojo/dom-construct"], function(domConstruct){
      //	|		domConstruct.place("someNode", "anotherNode", "before");
      //	|	});
      // example:
      //		Create a Node, and place it in the body element (last child):
      //	|	require(["dojo/dom-construct", "dojo/_base/window"
      //	|	], function(domConstruct, win){
      //	|		domConstruct.place("<div></div>", win.body());
      //	|	});
      // example:
      //		Put a new LI as the first child of a list by id:
      //	|	require(["dojo/dom-construct"], function(domConstruct){
      //	|		domConstruct.place("<li></li>", "someUl", "first");
      //	|	});
      refNode = dom.byId(refNode);
      if (typeof node == 'string') {
        // inline'd type check
        node = /^\s*</.test(node) ? exports.toDom(node, refNode.ownerDocument) : dom.byId(node);
      }
      if (typeof position == 'number') {
        // inline'd type check
        var cn = refNode.childNodes;
        if (!cn.length || cn.length <= position) {
          refNode.appendChild(node);
        } else {
          _insertBefore(node, cn[position < 0 ? 0 : position]);
        }
      } else {
        switch (position) {
        case 'before':
          _insertBefore(node, refNode);
          break;
        case 'after':
          _insertAfter(node, refNode);
          break;
        case 'replace':
          refNode.parentNode.replaceChild(node, refNode);
          break;
        case 'only':
          exports.empty(refNode);
          refNode.appendChild(node);
          break;
        case 'first':
          if (refNode.firstChild) {
            _insertBefore(node, refNode.firstChild);
            break;
          }
        // else fallthrough...
        default:
          // aka: last
          refNode.appendChild(node);
        }
      }
      return node;  // DomNode
    };
    var create = exports.create = function create(tag, attrs, refNode, pos) {
      // summary:
      //		Create an element, allowing for optional attribute decoration
      //		and placement.
      // description:
      //		A DOM Element creation function. A shorthand method for creating a node or
      //		a fragment, and allowing for a convenient optional attribute setting step,
      //		as well as an optional DOM placement reference.
      //
      //		Attributes are set by passing the optional object through `dojo/dom-attr.set`.
      //		See `dojo/dom-attr.set` for noted caveats and nuances, and API if applicable.
      //
      //		Placement is done via `dojo/dom-construct.place`, assuming the new node to be
      //		the action node, passing along the optional reference node and position.
      // tag: DOMNode|String
      //		A string of the element to create (eg: "div", "a", "p", "li", "script", "br"),
      //		or an existing DOM node to process.
      // attrs: Object
      //		An object-hash of attributes to set on the newly created node.
      //		Can be null, if you don't want to set any attributes/styles.
      //		See: `dojo/dom-attr.set` for a description of available attributes.
      // refNode: DOMNode|String?
      //		Optional reference node. Used by `dojo/dom-construct.place` to place the newly created
      //		node somewhere in the dom relative to refNode. Can be a DomNode reference
      //		or String ID of a node.
      // pos: String?
      //		Optional positional reference. Defaults to "last" by way of `dojo/domConstruct.place`,
      //		though can be set to "first","after","before","last", "replace" or "only"
      //		to further control the placement of the new node relative to the refNode.
      //		'refNode' is required if a 'pos' is specified.
      // example:
      //		Create a DIV:
      //	|	require(["dojo/dom-construct"], function(domConstruct){
      //	|		var n = domConstruct.create("div");
      //	|	});
      //
      // example:
      //		Create a DIV with content:
      //	|	require(["dojo/dom-construct"], function(domConstruct){
      //	|		var n = domConstruct.create("div", { innerHTML:"<p>hi</p>" });
      //	|	});
      //
      // example:
      //		Place a new DIV in the BODY, with no attributes set
      //	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
      //	|		var n = domConstruct.create("div", null, win.body());
      //	|	});
      //
      // example:
      //		Create an UL, and populate it with LI's. Place the list as the first-child of a
      //		node with id="someId":
      //	|	require(["dojo/dom-construct", "dojo/_base/array"],
      //	|	function(domConstruct, arrayUtil){
      //	|		var ul = domConstruct.create("ul", null, "someId", "first");
      //	|		var items = ["one", "two", "three", "four"];
      //	|		arrayUtil.forEach(items, function(data){
      //	|			domConstruct.create("li", { innerHTML: data }, ul);
      //	|		});
      //	|	});
      //
      // example:
      //		Create an anchor, with an href. Place in BODY:
      //	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
      //	|		domConstruct.create("a", { href:"foo.html", title:"Goto FOO!" }, win.body());
      //	|	});
      var doc = win.doc;
      if (refNode) {
        refNode = dom.byId(refNode);
        doc = refNode.ownerDocument;
      }
      if (typeof tag == 'string') {
        // inline'd type check
        tag = doc.createElement(tag);
      }
      if (attrs) {
        attr.set(tag, attrs);
      }
      if (refNode) {
        exports.place(tag, refNode, pos);
      }
      return tag;  // DomNode
    };
    function _empty(node) {
      // TODO: remove this if() block in 2.0 when we no longer have to worry about IE memory leaks,
      // and then uncomment the emptyGrandchildren() test case from html.html.
      // Note that besides fixing #16957, using removeChild() is actually faster than setting node.innerHTML,
      // see http://jsperf.com/clear-dom-node.
      if ('innerHTML' in node) {
        try {
          // fast path
          node.innerHTML = '';
          return;
        } catch (e) {
        }
      }
      // SVG/strict elements don't support innerHTML
      for (var c; c = node.lastChild;) {
        // intentional assignment
        node.removeChild(c);
      }
    }
    exports.empty = function empty(node) {
      // summary:
      //		safely removes all children of the node.
      // node: DOMNode|String
      //		a reference to a DOM node or an id.
      // example:
      //		Destroy node's children byId:
      //	|	require(["dojo/dom-construct"], function(domConstruct){
      //	|		domConstruct.empty("someId");
      //	|	});
      _empty(dom.byId(node));
    };
    function _destroy(node, parent) {
      // in IE quirks, node.canHaveChildren can be false but firstChild can be non-null (OBJECT/APPLET)
      if (node.firstChild) {
        _empty(node);
      }
      if (parent) {
        // removeNode(false) doesn't leak in IE 6+, but removeChild() and removeNode(true) are known to leak under IE 8- while 9+ is TBD.
        // In IE quirks mode, PARAM nodes as children of OBJECT/APPLET nodes have a removeNode method that does nothing and
        // the parent node has canHaveChildren=false even though removeChild correctly removes the PARAM children.
        // In IE, SVG/strict nodes don't have a removeNode method nor a canHaveChildren boolean.
        has('ie') && parent.canHaveChildren && 'removeNode' in node ? node.removeNode(false) : parent.removeChild(node);
      }
    }
    var destroy = exports.destroy = function destroy(node) {
      // summary:
      //		Removes a node from its parent, clobbering it and all of its
      //		children.
      //
      // description:
      //		Removes a node from its parent, clobbering it and all of its
      //		children. Function only works with DomNodes, and returns nothing.
      //
      // node: DOMNode|String
      //		A String ID or DomNode reference of the element to be destroyed
      //
      // example:
      //		Destroy a node byId:
      //	|	require(["dojo/dom-construct"], function(domConstruct){
      //	|		domConstruct.destroy("someId");
      //	|	});
      node = dom.byId(node);
      if (!node) {
        return;
      }
      _destroy(node, node.parentNode);
    };
    return exports;
  }(dojo_dom_construct, dojo__base_kernel, dojo_sniff, dojo__base_window, dojo_dom, dojo_dom_attr);
  dojo_text = function (module) {
    var text, fs, Cc, Ci, xpcIsWindows, progIds = [
        'Msxml2.XMLHTTP',
        'Microsoft.XMLHTTP',
        'Msxml2.XMLHTTP.4.0'
      ], xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im, hasLocation = typeof location !== 'undefined' && location.href, defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''), defaultHostName = hasLocation && location.hostname, defaultPort = hasLocation && (location.port || undefined), buildMap = {}, masterConfig = module.config && module.config() || {};
    text = {
      version: '2.0.14',
      strip: function (content) {
        //Strips <?xml ...?> declarations so that external SVG and XML
        //documents can be added to a document without worry. Also, if the string
        //is an HTML document, only the part inside the body tag is returned.
        if (content) {
          content = content.replace(xmlRegExp, '');
          var matches = content.match(bodyRegExp);
          if (matches) {
            content = matches[1];
          }
        } else {
          content = '';
        }
        return content;
      },
      jsEscape: function (content) {
        return content.replace(/(['\\])/g, '\\$1').replace(/[\f]/g, '\\f').replace(/[\b]/g, '\\b').replace(/[\n]/g, '\\n').replace(/[\t]/g, '\\t').replace(/[\r]/g, '\\r').replace(/[\u2028]/g, '\\u2028').replace(/[\u2029]/g, '\\u2029');
      },
      createXhr: masterConfig.createXhr || function () {
        //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
        var xhr, i, progId;
        if (typeof XDomainRequest !== 'undefined') {
          // PATCHED IE9
          return new XDomainRequest();
        } else if (typeof XMLHttpRequest !== 'undefined') {
          return new XMLHttpRequest();
        } else if (typeof ActiveXObject !== 'undefined') {
          for (i = 0; i < 3; i += 1) {
            progId = progIds[i];
            try {
              xhr = new ActiveXObject(progId);
            } catch (e) {
            }
            if (xhr) {
              progIds = [progId];
              // so faster next time
              break;
            }
          }
        }
        return xhr;
      },
      /**
       * Parses a resource name into its component parts. Resource names
       * look like: module/name.ext!strip, where the !strip part is
       * optional.
       * @param {String} name the resource name
       * @returns {Object} with properties "moduleName", "ext" and "strip"
       * where strip is a boolean.
       */
      parseName: function (name) {
        var modName, ext, temp, strip = false, index = name.lastIndexOf('.'), isRelative = name.indexOf('./') === 0 || name.indexOf('../') === 0;
        if (index !== -1 && (!isRelative || index > 1)) {
          modName = name.substring(0, index);
          ext = name.substring(index + 1);
        } else {
          modName = name;
        }
        temp = ext || modName;
        index = temp.indexOf('!');
        if (index !== -1) {
          //Pull off the strip arg.
          strip = temp.substring(index + 1) === 'strip';
          temp = temp.substring(0, index);
          if (ext) {
            ext = temp;
          } else {
            modName = temp;
          }
        }
        return {
          moduleName: modName,
          ext: ext,
          strip: strip
        };
      },
      xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,
      /**
       * Is an URL on another domain. Only works for browser use, returns
       * false in non-browser environments. Only used to know if an
       * optimized .js version of a text resource should be loaded
       * instead.
       * @param {String} url
       * @returns Boolean
       */
      useXhr: function (url, protocol, hostname, port) {
        // PATCHED: ALLOW ALL CORS BROWSERS
        // Adapted from: https://raw.github.com/Modernizr/Modernizr/master/feature-detects/cors.js
        if (typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest()) {
          return true;
        }
        if (typeof XDomainRequest !== 'undefined') {
          return true;
        }
        // PATCHED: ALLOW ALL CORS BROWSERS END
        var uProtocol, uHostName, uPort, match = text.xdRegExp.exec(url);
        if (!match) {
          return true;
        }
        uProtocol = match[2];
        uHostName = match[3];
        uHostName = uHostName.split(':');
        uPort = uHostName[1];
        uHostName = uHostName[0];
        return (!uProtocol || uProtocol === protocol) && (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) && (!uPort && !uHostName || uPort === port);
      },
      finishLoad: function (name, strip, content, onLoad) {
        content = strip ? text.strip(content) : content;
        if (masterConfig.isBuild) {
          buildMap[name] = content;
        }
        onLoad(content);
      },
      load: function (name, req, onLoad, config) {
        //Name has format: some.module.filext!strip
        //The strip part is optional.
        //if strip is present, then that means only get the string contents
        //inside a body tag in an HTML string. For XML/SVG content it means
        //removing the <?xml ...?> declarations so the content can be inserted
        //into the current doc without problems.
        // Do not bother with the work if a build and text will
        // not be inlined.
        if (config && config.isBuild && !config.inlineText) {
          onLoad();
          return;
        }
        masterConfig.isBuild = config && config.isBuild;
        var parsed = text.parseName(name), nonStripName = parsed.moduleName + (parsed.ext ? '.' + parsed.ext : ''), url = req.toUrl(nonStripName), useXhr = masterConfig.useXhr || text.useXhr;
        // Do not load if it is an empty: url
        if (url.indexOf('empty:') === 0) {
          onLoad();
          return;
        }
        //Load the text. Use XHR if possible and in a browser.
        if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
          text.get(url, function (content) {
            text.finishLoad(name, parsed.strip, content, onLoad);
          }, function (err) {
            if (onLoad.error) {
              onLoad.error(err);
            }
          });
        } else {
          //Need to fetch the resource across domains. Assume
          //the resource has been optimized into a JS module. Fetch
          //by the module name + extension, but do not include the
          //!strip part to avoid file system issues.
          req([nonStripName], function (content) {
            text.finishLoad(parsed.moduleName + '.' + parsed.ext, parsed.strip, content, onLoad);
          });
        }
      },
      write: function (pluginName, moduleName, write, config) {
        if (buildMap.hasOwnProperty(moduleName)) {
          var content = text.jsEscape(buildMap[moduleName]);
          write.asModule(pluginName + '!' + moduleName, 'define(function () { return \'' + content + '\';});\n');
        }
      },
      writeFile: function (pluginName, moduleName, req, write, config) {
        var parsed = text.parseName(moduleName), extPart = parsed.ext ? '.' + parsed.ext : '', nonStripName = parsed.moduleName + extPart,
          //Use a '.js' file name so that it indicates it is a
          //script that can be loaded across domains.
          fileName = req.toUrl(parsed.moduleName + extPart) + '.js';
        //Leverage own load() method to load plugin value, but only
        //write out values that do not have the strip argument,
        //to avoid any potential issues with ! in file names.
        text.load(nonStripName, req, function (value) {
          //Use own write() method to construct full module value.
          //But need to create shell that translates writeFile's
          //write() to the right interface.
          var textWrite = function (contents) {
            return write(fileName, contents);
          };
          textWrite.asModule = function (moduleName, contents) {
            return write.asModule(moduleName, fileName, contents);
          };
          text.write(pluginName, nonStripName, textWrite, config);
        }, config);
      }
    };
    if (masterConfig.env === 'node' || !masterConfig.env && typeof process !== 'undefined' && process.versions && !!process.versions.node && !process.versions['node-webkit'] && !process.versions['atom-shell']) {
      //Using special require.nodeRequire, something added by r.js.
      fs = require.nodeRequire('fs');
      text.get = function (url, callback, errback) {
        try {
          var file = fs.readFileSync(url, 'utf8');
          //Remove BOM (Byte Mark Order) from utf8 files if it is there.
          if (file[0] === '\uFEFF') {
            file = file.substring(1);
          }
          callback(file);
        } catch (e) {
          if (errback) {
            errback(e);
          }
        }
      };
    } else if (masterConfig.env === 'xhr' || !masterConfig.env && text.createXhr()) {
      text.get = function (url, callback, errback, headers) {
        var xhr = text.createXhr(), header;
        // PATCH START: XDomainRequest support for IE
        if (typeof XDomainRequest !== 'undefined' && xhr instanceof XDomainRequest) {
          // Requests must be targeted to the same scheme as the hosting page
          // http://stackoverflow.com/questions/8464262/access-is-denied-error-on-xdomainrequest
          var pageProtocol = window.location.protocol;
          if (url.indexOf(pageProtocol) == -1) {
            url = pageProtocol + url.substring(url.indexOf('//'));
          }
        }
        // PATCHED END
        xhr.open('GET', url, true);
        //Allow plugins direct access to xhr headers
        if (headers) {
          for (header in headers) {
            if (headers.hasOwnProperty(header)) {
              xhr.setRequestHeader(header.toLowerCase(), headers[header]);
            }
          }
        }
        //Allow overrides specified in config
        if (masterConfig.onXhr) {
          masterConfig.onXhr(xhr, url);
        }
        xhr.onreadystatechange = function (evt) {
          var status, err;
          //Do not explicitly handle errors, those should be
          //visible via console output in the browser.
          if (xhr.readyState === 4) {
            status = xhr.status || 0;
            if (status > 399 && status < 600) {
              //An http 4xx or 5xx error. Signal an error.
              err = new Error(url + ' HTTP status: ' + status);
              err.xhr = xhr;
              if (errback) {
                errback(err);
              }
            } else {
              callback(xhr.responseText);
            }
            if (masterConfig.onXhrComplete) {
              masterConfig.onXhrComplete(xhr, url);
            }
          }
        };
        // PATCH START: XDomainRequest support for IE
        if (typeof XDomainRequest !== 'undefined' && xhr instanceof XDomainRequest) {
          xhr.onload = function () {
            callback(xhr.responseText);
          };
          xhr.onerror = function () {
            err = new Error(url);
            err.xhr = xhr;
            errback(err);
          };
          // Empty event handlers needs to be there, because IE9 is flawed: http://rudovsky.blogspot.dk/2012/09/microsoft-shit-xdomainrequest.html
          xhr.ontimeout = function () {
          };
          xhr.onprogress = function () {
          };
          xhr.send();
        } else {
          // PATCHED END
          xhr.send(null);
        }
      };
    } else if (masterConfig.env === 'rhino' || !masterConfig.env && typeof Packages !== 'undefined' && typeof java !== 'undefined') {
      //Why Java, why is this so awkward?
      text.get = function (url, callback) {
        var stringBuffer, line, encoding = 'utf-8', file = new java.io.File(url), lineSeparator = java.lang.System.getProperty('line.separator'), input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)), content = '';
        try {
          stringBuffer = new java.lang.StringBuffer();
          line = input.readLine();
          // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
          // http://www.unicode.org/faq/utf_bom.html
          // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
          // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
          if (line && line.length() && line.charAt(0) === 65279) {
            // Eat the BOM, since we've already found the encoding on this file,
            // and we plan to concatenating this buffer with others; the BOM should
            // only appear at the top of a file.
            line = line.substring(1);
          }
          if (line !== null) {
            stringBuffer.append(line);
          }
          while ((line = input.readLine()) !== null) {
            stringBuffer.append(lineSeparator);
            stringBuffer.append(line);
          }
          //Make sure we return a JavaScript string and not a Java string.
          content = String(stringBuffer.toString());  //String
        } finally {
          input.close();
        }
        callback(content);
      };
    } else if (masterConfig.env === 'xpconnect' || !masterConfig.env && typeof Components !== 'undefined' && Components.classes && Components.interfaces) {
      //Avert your gaze!
      Cc = Components.classes;
      Ci = Components.interfaces;
      Components.utils['import']('resource://gre/modules/FileUtils.jsm');
      xpcIsWindows = '@mozilla.org/windows-registry-key;1' in Cc;
      text.get = function (url, callback) {
        var inStream, convertStream, fileObj, readData = {};
        if (xpcIsWindows) {
          url = url.replace(/\//g, '\\');
        }
        fileObj = new FileUtils.File(url);
        //XPCOM, you so crazy
        try {
          inStream = Cc['@mozilla.org/network/file-input-stream;1'].createInstance(Ci.nsIFileInputStream);
          inStream.init(fileObj, 1, 0, false);
          convertStream = Cc['@mozilla.org/intl/converter-input-stream;1'].createInstance(Ci.nsIConverterInputStream);
          convertStream.init(inStream, 'utf-8', inStream.available(), Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);
          convertStream.readString(inStream.available(), readData);
          convertStream.close();
          inStream.close();
          callback(readData.value);
        } catch (e) {
          throw new Error((fileObj && fileObj.path || '') + ': ' + e);
        }
      };
    }
    return text;
  }({});
  dojo_text_synchronite_integration_templates_EnterServiceIdDialoghtml = '<div class="modal fade" id="${DIALOG_ENTER_ID}" tabindex="-1" role="dialog" aria-labelledby="${SUPPORT_DIALOG_TITLE}" aria-hidden="true">\n    <div class="modal-dialog">\n        <div class="modal-content">\n\n    <div class="modal-header">\n        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>\n        <h4 class="modal-title">${SHOW_SERVICE_TITLE}</h4>\n    </div>\n    <div class="modal-body">\n        <div class="input-container">\n            <div class="form-group">\n                <label class="control-label" for="service-input">${ENTER_SERVICE_NUMBER_INFO}</label>\n                <input class="form-control" type="text" id="service-input" placeholder="1234&hellip;"/>\n            </div>\n        </div>\n    </div>\n    <div class="modal-footer">\n        <button type="button" id="confirmEnterButton" class="btn btn-primary">${START}</button>\n        <button type="button" id="cancelEnterButton" data-dismiss="modal" aria-hidden="true" class="btn btn-default">${CLOSE}</button>\n    </div>\n    </div>\n    </div>\n</div>\n';
  dojo_text_synchronite_integration_templates_ShowServiceIdDialoghtml = '<div class="modal fade" id="${DIALOG_SHOW_ID}" tabindex="-1" role="dialog" aria-labelledby="${SUPPORT_DIALOG_TITLE}"\r\n     aria-hidden="true">\r\n    <div class="modal-dialog">\r\n        <div class="modal-content">\r\n            <div class="modal-header">\r\n                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>\r\n                <h4 class="modal-title">${SHOW_SERVICE_TITLE}</h4>\r\n            </div>\r\n            <div class="modal-body">\r\n\r\n                <p>${SHOW_SERVICE_NUMBER_INFO}</p>\r\n\r\n                <div style="text-align:center; margin: 18px 0px; padding:14px; font-size:2em;" class="alert alert-info">\r\n                    <strong>${SHOW_SERVICE_NUMBER_HEADER}</strong>\r\n                    <span id="sn-service-number">${STANDBY}</span>\r\n                </div>\r\n\r\n\r\n                <span class="label label-info">${SECURITY_HEADER}:</span>\r\n                <small>${SECURITY_INFORMATION}</small>\r\n\r\n            </div>\r\n            <div class="modal-footer">\r\n                <button type="button" data-dismiss="modal" aria-hidden="true" class="btn btn-default">${CLOSE}</button>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>';
  synchronite_integration_dialog_service = function (lang, baseWindow, on, query, dom, domConstruct, domAttr, domStyle, string, i18next, templateEnterServiceIdDialog, templateShowServiceIdDialog) {
    ///////////////////////////
    // PRIVATE METHODS
    ///////////////////////////
    var config = synchroniteConfig;
    var showDialog, enterDialog;
    /////////////
    //widget ids
    /////////////
    var DIALOG_ENTER_ID = 'dialog-enter-id', DIALOG_SHOW_ID = 'dialog-show-id', SYNCHRONITE_WIDGETS = 'synchronite-widgets';
    var BS_FORM_CLASS = '.form-group';
    var CONFIRM_ENTER_ID = 'confirmEnterButton', CANCEL_ENTER_ID = 'cancelEnterButton', CANCEL_SHOW_ID = 'cancelShowButton', _setDialogWidth = function (dialog, w) {
        var marginLeft = -(w / 2);
        domStyle.set(dialog, {
          width: w + 'px',
          marginLeft: marginLeft + 'px'
        });
      }, _createShowDialog = function () {
        /* The support dialog */
        var dialog = dom.byId(DIALOG_SHOW_ID);
        if (dialog) {
          return dialog;
        }
        templateShowServiceIdDialog = string.trim(i18next.replace(templateShowServiceIdDialog, { DIALOG_SHOW_ID: DIALOG_SHOW_ID }));
        var dialogContainer = dom.byId(SYNCHRONITE_WIDGETS) || domConstruct.create('div', { id: SYNCHRONITE_WIDGETS }, baseWindow.body());
        dialog = domConstruct.place(templateShowServiceIdDialog, dialogContainer);
        //_setDialogWidth(dialog, 500);
        query(dialog).modal({
          backdrop: false,
          // deactivate backdrop as it would require a global style on the page
          show: false
        });
        return dialogContainer.firstChild;
      }, _createEnterDialog = function (serviceNumberCallback) {
        var dialog = dom.byId(DIALOG_ENTER_ID);
        if (dialog) {
          return dialog;
        }
        templateEnterServiceIdDialog = string.trim(i18next.replace(templateEnterServiceIdDialog, { DIALOG_ENTER_ID: DIALOG_ENTER_ID }));
        var dialogContainer = dom.byId(SYNCHRONITE_WIDGETS) || domConstruct.create('div', { id: SYNCHRONITE_WIDGETS }, baseWindow.body());
        dialog = domConstruct.place(templateEnterServiceIdDialog, dialogContainer);
        //_setDialogWidth(dialog, 300);
        query(dialog).modal({
          backdrop: false,
          // deactivate backdrop as it would require a global style on the page
          show: false
        });
        on(dom.byId(CONFIRM_ENTER_ID), 'click', function () {
          var serviceInput = dom.byId('service-input');
          var serviceNumber = serviceInput.value;
          // remove spaces
          if (serviceNumber && typeof serviceNumber == 'string') {
            serviceNumber = serviceNumber.replace(/(\s)/gi, '');
          }
          var valid = serviceNumber && serviceNumber.length >= 4;
          query(serviceInput).closest(BS_FORM_CLASS).toggleClass('error', !valid);
          if (valid) {
            if (serviceNumberCallback) {
              serviceNumberCallback(serviceNumber);
            } else {
              console.debug('No callback defined');
            }
          } else {
            if (serviceInput) {
              serviceInput.focus();
            }
          }
        });
        return dialog;
      };
    var serviceDialog = {
      isShown: function () {
        var modal, dialog, dialogs = [
            enterDialog,
            showDialog
          ];
        for (var i = 0; i < dialogs.length; i++) {
          dialog = dialogs[i];
          if (dialog) {
            modal = query(dialog).data('modal');
            if (modal && modal.length && modal[0].isShown) {
              return true;
            }
          }
        }
        return false;
      },
      openEnterDialog: function (serviceNumberCallback) {
        var that = this;
        i18next.loadNamespaces([
          'integration',
          'common'
        ], function () {
          enterDialog = _createEnterDialog(serviceNumberCallback);
          if (!that.isShown()) {
            var _d = query('#' + DIALOG_ENTER_ID);
            _d.modal('show');
            _d.removeClass('hide');
          }
        });
      },
      hide: function () {
        if (this.isShown()) {
          if (enterDialog) {
            query(enterDialog).modal('hide');
          }
          if (showDialog) {
            query(showDialog).modal('hide');
          }
        }
      },
      openShowDialog: function () {
        var that = this;
        i18next.loadNamespaces([
          'integration',
          'common'
        ], function () {
          showDialog = _createShowDialog();
          if (!that.isShown()) {
            var _d = query('#' + DIALOG_SHOW_ID);
            _d.modal('show');
            _d.removeClass('hide');
          }
        });
      },
      showServiceNumber: function (serviceId) {
        if (serviceId) {
          var serviceNumberNode = dom.byId('sn-service-number');
          // trim whitespace
          serviceId = serviceId.replace(/(^\s+|\s+$)/g, '');
          // insert space every two characters
          serviceId = serviceId.replace(/(.{2})/g, '$1 ');
          domAttr.set(serviceNumberNode, { innerHTML: serviceId });
        }
      }
    };
    return serviceDialog;
  }(dojo__base_lang, dojo__base_window, dojo_on, dojo_query, dojo_dom, dojo_dom_construct, dojo_dom_attr, dojo_dom_style, dojo_string, i18next_loader, dojo_text_synchronite_integration_templates_EnterServiceIdDialoghtml, dojo_text_synchronite_integration_templates_ShowServiceIdDialoghtml);
  dojo_NodeList_data = function (dojo, query, lang, array, attr) {
    // module:
    //		dojo/NodeList-data
    /*=====
    	return function(){
    		// summary:
    		//		Adds data() and removeData() methods to NodeList, and returns NodeList constructor.
    	};
    	=====*/
    var NodeList = query.NodeList;
    var dataCache = {}, x = 0, dataattr = 'data-dojo-dataid', dopid = function (node) {
        // summary:
        //		Return a uniqueish ID for the passed node reference
        var pid = attr.get(node, dataattr);
        if (!pid) {
          pid = 'pid' + x++;
          attr.set(node, dataattr, pid);
        }
        return pid;
      };
        var dodata = dojo._nodeData = function (node, key, value) {
      // summary:
      //		Private helper for dojo/NodeList.data for single node data access. Refer to NodeList.data
      //		documentation for more information.
      //
      // node: String|DomNode
      //		The node to associate data with
      //
      // key: Object|String?
      //		If an object, act as a setter and iterate over said object setting data items as defined.
      //		If a string, and `value` present, set the data for defined `key` to `value`
      //		If a string, and `value` absent, act as a getter, returning the data associated with said `key`
      //
      // value: Anything?
      //		The value to set for said `key`, provided `key` is a string (and not an object)
      //
      var pid = dopid(node), r;
      if (!dataCache[pid]) {
        dataCache[pid] = {};
      }
      // API discrepency: calling with only a node returns the whole object. $.data throws
      if (arguments.length == 1) {
        return dataCache[pid];
      }
      if (typeof key == 'string') {
        // either getter or setter, based on `value` presence
        if (arguments.length > 2) {
          dataCache[pid][key] = value;
        } else {
          r = dataCache[pid][key];
        }
      } else {
        // must be a setter, mix `value` into data hash
        // API discrepency: using object as setter works here
        r = lang.mixin(dataCache[pid], key);
      }
      return r;  // Object|Anything|Nothing
    };
    var removeData = dojo._removeNodeData = function (node, key) {
      // summary:
      //		Remove some data from this node
      // node: String|DomNode
      //		The node reference to remove data from
      // key: String?
      //		If omitted, remove all data in this dataset.
      //		If passed, remove only the passed `key` in the associated dataset
      var pid = dopid(node);
      if (dataCache[pid]) {
        if (key) {
          delete dataCache[pid][key];
        } else {
          delete dataCache[pid];
        }
      }
    };
    NodeList._gcNodeData = dojo._gcNodeData = function () {
      // summary:
      //		super expensive: GC all data in the data for nodes that no longer exist in the dom.
      // description:
      //		super expensive: GC all data in the data for nodes that no longer exist in the dom.
      //		MUCH safer to do this yourself, manually, on a per-node basis (via `NodeList.removeData()`)
      //		provided as a stop-gap for exceptionally large/complex applications with constantly changing
      //		content regions (eg: a dijit/layout/ContentPane with replacing data)
      //		There is NO automatic GC going on. If you dojo.destroy() a node, you should _removeNodeData
      //		prior to destruction.
      var livePids = query('[' + dataattr + ']').map(dopid);
      for (var i in dataCache) {
        if (array.indexOf(livePids, i) < 0) {
          delete dataCache[i];
        }
      }
    };
    // make nodeData and removeNodeData public on dojo/NodeList:
    lang.extend(NodeList, {
      data: NodeList._adaptWithCondition(dodata, function (a) {
        return a.length === 0 || a.length == 1 && typeof a[0] == 'string';
      }),
      removeData: NodeList._adaptAsForEach(removeData)
    });
    /*=====
    	 lang.extend(NodeList, {
    		 data: function(key, value){
    			// summary:
    			//		stash or get some arbitrary data on/from these nodes.
    			//
    			// description:
    			//		Stash or get some arbitrary data on/from these nodes. This private _data function is
    			//		exposed publicly on `dojo/NodeList`, eg: as the result of a `dojo/query` call.
    			//		DIFFERS from jQuery.data in that when used as a getter, the entire list is ALWAYS
    			//		returned. EVEN WHEN THE LIST IS length == 1.
    			//
    			//		A single-node version of this function is provided as `dojo._nodeData`, which follows
    			//		the same signature, though expects a String ID or DomNode reference in the first
    			//		position, before key/value arguments.
    			//
    			// node: String|DomNode
    			//		The node to associate data with
    			//
    			// key: Object|String?
    			//		If an object, act as a setter and iterate over said object setting data items as defined.
    			//		If a string, and `value` present, set the data for defined `key` to `value`
    			//		If a string, and `value` absent, act as a getter, returning the data associated with said `key`
    			//
    			// value: Anything?
    			//		The value to set for said `key`, provided `key` is a string (and not an object)
    			//
    			// example:
    			//		Set a key `bar` to some data, then retrieve it.
    			//	|	require(["dojo/query", "dojo/NodeList-data"], function(query){
    			//	|		query(".foo").data("bar", "touched");
    			//	|		var touched = query(".foo").data("bar");
    			//	|		if(touched[0] == "touched"){ alert('win'); }
    			//	|	});
    			//
    			// example:
    			//		Get all the data items for a given node.
    			//	|	require(["dojo/query", "dojo/NodeList-data"], function(query){
    			//	|		var list = query(".foo").data();
    			//	|		var first = list[0];
    			//	|	});
    			//
    			// example:
    			//		Set the data to a complex hash. Overwrites existing keys with new value
    			//	|	require(["dojo/query", "dojo/NodeList-data"], function(query){
    			//	|		query(".foo").data({ bar:"baz", foo:"bar" });
    			//		Then get some random key:
    			//	|		query(".foo").data("foo"); // returns [`bar`]
    			//	|	});
    			//
    			// returns: Object|Anything|Nothing
    			//		When used as a setter via `dojo/NodeList`, a NodeList instance is returned
    			//		for further chaining. When used as a getter via `dojo/NodeList` an ARRAY
    			//		of items is returned. The items in the array correspond to the elements
    			//		in the original list. This is true even when the list length is 1, eg:
    			//		when looking up a node by ID (#foo)
    		 },
    
    		 removeData: function(key){
    			// summary:
    			//		Remove the data associated with these nodes.
    			// key: String?
    			//		If omitted, clean all data for this node.
    			//		If passed, remove the data item found at `key`
    		 }
    	 });
    	 =====*/
    // TODO: this is the basic implementation of adaptWithConditionAndWhenMappedConsiderLength, for lack of a better API name
    // it conflicts with the the `dojo/NodeList` way: always always return an arrayLike thinger. Consider for 2.0:
    //
    //	NodeList.prototype.data = function(key, value){
    //		var a = arguments, r;
    //		if(a.length === 0 || a.length == 1 && (typeof a[0] == "string")){
    //			r = this.map(function(node){
    //				return d._data(node, key);
    //			});
    //			if(r.length == 1){ r = r[0]; } // the offending line, and the diff on adaptWithCondition
    //		}else{
    //			r = this.forEach(function(node){
    //				d._data(node, key, value);
    //			});
    //		}
    //		return r; // NodeList|Array|SingleItem
    //	};
    return NodeList;
  }(dojo__base_kernel, dojo_query, dojo__base_lang, dojo__base_array, dojo_dom_attr);
  bootstrap_Support = function (query, lang, attr, domStyle, array, json, has, on) {
    var _transition = function () {
      var transitionEnd = function () {
        var el = document.createElement('bootstrap');
        var transEndEventNames = {
          'WebkitTransition': 'webkitTransitionEnd',
          'MozTransition': 'transitionend',
          'OTransition': 'oTransitionEnd',
          'transition': 'transitionend'
        };
        for (var name in transEndEventNames) {
          if (el.style[name] !== undefined) {
            return transEndEventNames[name];
          }
        }
      }();
      return transitionEnd && { end: transitionEnd };
    }();
    var _loadData = function (node) {
      //load data attributes
      var elm = query(node)[0];
      if (elm) {
        var _this = this;
        var attrs = elm.attributes;
        array.forEach(attrs, function (attr) {
          if (attr.name.indexOf('data-') >= 0) {
            _this.setData(node, attr.name.substr(5), _attrValue(attr.value));
          }
        });
      }
    };
    var _attrValue = function (val) {
      if (!val) {
        return;
      }
      if (val.indexOf('{') === 0 && val.indexOf('}') === val.length - 1) {
        return json.parse(val);
      } else if (val.indexOf('[') === 0 && val.indexOf(']') === val.length - 1) {
        return json.parse(val);
      } else {
        return val;
      }
    };
    var TAGNAMES = {
      'select': 'input',
      'change': 'input',
      'submit': 'form',
      'reset': 'form',
      'error': 'img',
      'load': 'img',
      'abort': 'img'
    };
    var setOffset = function (elem, options, i) {
      var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = domStyle.get(elem, 'position'), curElem = query(elem), props = {};
      // Set position first, in-case top/left are set even on static elem
      if (position === 'static') {
        elem.style.position = 'relative';
      }
      curOffset = curElem.offset();
      curCSSTop = domStyle.get(elem, 'top');
      curCSSLeft = domStyle.get(elem, 'left');
      calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).toString().indexOf('auto') > -1;
      // Need to be able to calculate position if either top or left is auto and position is either absolute or fixed
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.y;
        curLeft = curPosition.x;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (typeof options === 'function') {
        options = options.call(elem, i, curOffset);
      }
      if (options.y !== null) {
        props.y = options.y - curOffset.y + curTop;
      }
      if (options.x !== null) {
        props.x = options.x - curOffset.x + curLeft;
      }
      if ('using' in options) {
        options.using.call(elem, props);
      } else {
        domStyle.set(elem, {
          top: props.y + 'px',
          left: props.x + 'px'
        });
      }
    };
    function getWindow(elem) {
      return elem !== null && elem === elem.window ? elem : elem.nodeType === 9 && elem.defaultView;
    }
    function isEventSupported(element, eventName) {
      element = element || document.createElement(TAGNAMES[eventName] || 'div');
      eventName = 'on' + eventName;
      // When using `setAttribute`, IE skips "unload", WebKit skips "unload" and "resize", whereas `in` "catches" those
      var isSupported = eventName in element;
      if (!isSupported) {
        // If it has no `setAttribute` (i.e. doesn't implement Node interface), try generic element
        if (!element.setAttribute) {
          element = document.createElement('div');
        }
        if (element.setAttribute && element.removeAttribute) {
          element.setAttribute(eventName, '');
          isSupported = typeof element[eventName] === 'function';
          // If property was created, "remove it" (by setting value to `undefined`)
          if (typeof element[eventName] !== 'undefined') {
            element[eventName] = undefined;
          }
          element.removeAttribute(eventName);
        }
      }
      element = null;
      return isSupported;
    }
    //http://blog.alexmaccaw.com/css-transitions
    function emulateTransitionEnd(element, duration) {
      var called = false;
      on.once(element, _transition.end, function () {
        called = true;
      });
      var callback = function () {
        if (!called) {
          on.emit(element, _transition.end, {
            bubbles: true,
            cancelable: true
          });
        }
      };
      setTimeout(callback, duration);
    }
    lang.extend(query.NodeList, {
      show: function () {
        return this.forEach(function (node) {
          node.style.display = 'block';
        });
      },
      hide: function () {
        return this.forEach(function (node) {
          node.style.display = 'none';
        });
      },
      offset: function (options) {
        if (arguments.length) {
          return options === undefined ? this : this.forEach(function (elm, i) {
            setOffset(elm, options, i);
          });
        }
        var docElem, win, elem = this[0], box = {
            y: 0,
            x: 0
          }, doc = elem && elem.ownerDocument;
        if (!doc) {
          return;
        }
        docElem = doc.documentElement;
        // Make sure it's not a disconnected DOM node
        if (query(elem, docElem).length === 0) {
          return box;
        }
        // If we don't have gBCR, just use 0,0 rather than error
        // BlackBerry 5, iOS 3 (original iPhone)
        if (typeof elem.getBoundingClientRect === 'function') {
          var rect = elem.getBoundingClientRect();
          box = {
            y: rect.top,
            x: rect.left
          };
        }
        win = getWindow(doc);
        // PATCHED START (KSK on IE8)
        var xOffset = win && win.pageXOffset || 0, yOffset = win && win.pageYOffset || 0;
        // PATCHED END (KSK on IE8)
        return {
          y: box.y + xOffset - docElem.clientTop,
          x: box.x + yOffset - docElem.clientLeft
        };
      }
    });
    return {
      trans: _transition,
      getData: function (node, key, def) {
        key = key || undefined;
        def = def || undefined;
        if (key !== undefined && lang.isString(key)) {
          var data = query(node).data(key);
          if (data && data[0] === undefined) {
            if (query(node)[0]) {
              data = attr.get(query(node)[0], 'data-' + key);
            }
            if (data !== undefined) {
              data = _attrValue(data);
            }
            if (data === undefined && def !== undefined) {
              data = this.setData(node, key, def);
            }
          }
          return lang.isArray(data) && data.length > 0 ? data[0] : data;
        } else {
          _loadData.call(this, node);
          return query(node).data()[0];
        }
      },
      setData: function (node, key, value) {
        var data = query(node).data(key, value);
        return value;
      },
      removeData: function (node, key) {
        return query(node).removeData(key);
      },
      toCamel: function (str) {
        return str.replace(/(\-[a-z])/g, function ($1) {
          return $1.toUpperCase().replace('-', '');
        });
      },
      toDash: function (str) {
        return str.replace(/([A-Z])/g, function ($1) {
          return '-' + $1.toLowerCase();
        });
      },
      toUnderscore: function (str) {
        return str.replace(/([A-Z])/g, function ($1) {
          return '_' + $1.toLowerCase();
        });
      },
      hrefValue: function (element) {
        var href = attr.get(element, 'href');
        if (href !== null) {
          href = href.replace(/.*(?=#[^\s]+$)/, '');  //strip for ie7
        }
        return href || '';
      },
      eventSupported: isEventSupported,
      emulateTransitionEnd: emulateTransitionEnd,
      setOffset: setOffset
    };
  }(dojo_query, dojo__base_lang, dojo_dom_attr, dojo_dom_style, dojo__base_array, dojo_json, dojo_has, dojo_on);
  dojo__base_declare = function (dojo, has, lang) {
    // module:
    //		dojo/_base/declare
    var mix = lang.mixin, op = Object.prototype, opts = op.toString, counter = 0, cname = 'constructor';
    function err(msg, cls) {
      throw new Error('declare' + (cls ? ' ' + cls : '') + ': ' + msg);
    }
    // C3 Method Resolution Order (see http://www.python.org/download/releases/2.3/mro/)
    function c3mro(bases, className) {
      var result = [], roots = [{
            cls: 0,
            refs: []
          }], nameMap = {}, clsCount = 1, l = bases.length, i = 0, j, lin, base, top, proto, rec, name, refs;
      // build a list of bases naming them if needed
      for (; i < l; ++i) {
        base = bases[i];
        if (!base) {
          err('mixin #' + i + ' is unknown. Did you use dojo.require to pull it in?', className);
        } else if (opts.call(base) != '[object Function]') {
          err('mixin #' + i + ' is not a callable constructor.', className);
        }
        lin = base._meta ? base._meta.bases : [base];
        top = 0;
        // add bases to the name map
        for (j = lin.length - 1; j >= 0; --j) {
          proto = lin[j].prototype;
          if (!proto.hasOwnProperty('declaredClass')) {
            proto.declaredClass = 'uniqName_' + counter++;
          }
          name = proto.declaredClass;
          if (!nameMap.hasOwnProperty(name)) {
            nameMap[name] = {
              count: 0,
              refs: [],
              cls: lin[j]
            };
            ++clsCount;
          }
          rec = nameMap[name];
          if (top && top !== rec) {
            rec.refs.push(top);
            ++top.count;
          }
          top = rec;
        }
        ++top.count;
        roots[0].refs.push(top);
      }
      // remove classes without external references recursively
      while (roots.length) {
        top = roots.pop();
        result.push(top.cls);
        --clsCount;
        // optimization: follow a single-linked chain
        while (refs = top.refs, refs.length == 1) {
          top = refs[0];
          if (!top || --top.count) {
            // branch or end of chain => do not end to roots
            top = 0;
            break;
          }
          result.push(top.cls);
          --clsCount;
        }
        if (top) {
          // branch
          for (i = 0, l = refs.length; i < l; ++i) {
            top = refs[i];
            if (!--top.count) {
              roots.push(top);
            }
          }
        }
      }
      if (clsCount) {
        err('can\'t build consistent linearization', className);
      }
      // calculate the superclass offset
      base = bases[0];
      result[0] = base ? base._meta && base === result[result.length - base._meta.bases.length] ? base._meta.bases.length : 1 : 0;
      return result;
    }
    function inherited(args, a, f) {
      var name, chains, bases, caller, meta, base, proto, opf, pos, cache = this._inherited = this._inherited || {};
      // crack arguments
      if (typeof args == 'string') {
        name = args;
        args = a;
        a = f;
      }
      f = 0;
      caller = args.callee;
      name = name || caller.nom;
      if (!name) {
        err('can\'t deduce a name to call inherited()', this.declaredClass);
      }
      meta = this.constructor._meta;
      bases = meta.bases;
      pos = cache.p;
      if (name != cname) {
        // method
        if (cache.c !== caller) {
          // cache bust
          pos = 0;
          base = bases[0];
          meta = base._meta;
          if (meta.hidden[name] !== caller) {
            // error detection
            chains = meta.chains;
            if (chains && typeof chains[name] == 'string') {
              err('calling chained method with inherited: ' + name, this.declaredClass);
            }
            // find caller
            do {
              meta = base._meta;
              proto = base.prototype;
              if (meta && (proto[name] === caller && proto.hasOwnProperty(name) || meta.hidden[name] === caller)) {
                break;
              }
            } while (base = bases[++pos]);
            // intentional assignment
            pos = base ? pos : -1;
          }
        }
        // find next
        base = bases[++pos];
        if (base) {
          proto = base.prototype;
          if (base._meta && proto.hasOwnProperty(name)) {
            f = proto[name];
          } else {
            opf = op[name];
            do {
              proto = base.prototype;
              f = proto[name];
              if (f && (base._meta ? proto.hasOwnProperty(name) : f !== opf)) {
                break;
              }
            } while (base = bases[++pos]);  // intentional assignment
          }
        }
        f = base && f || op[name];
      } else {
        // constructor
        if (cache.c !== caller) {
          // cache bust
          pos = 0;
          meta = bases[0]._meta;
          if (meta && meta.ctor !== caller) {
            // error detection
            chains = meta.chains;
            if (!chains || chains.constructor !== 'manual') {
              err('calling chained constructor with inherited', this.declaredClass);
            }
            // find caller
            while (base = bases[++pos]) {
              // intentional assignment
              meta = base._meta;
              if (meta && meta.ctor === caller) {
                break;
              }
            }
            pos = base ? pos : -1;
          }
        }
        // find next
        while (base = bases[++pos]) {
          // intentional assignment
          meta = base._meta;
          f = meta ? meta.ctor : base;
          if (f) {
            break;
          }
        }
        f = base && f;
      }
      // cache the found super method
      cache.c = f;
      cache.p = pos;
      // now we have the result
      if (f) {
        return a === true ? f : f.apply(this, a || args);
      }  // intentionally no return if a super method was not found
    }
    function getInherited(name, args) {
      if (typeof name == 'string') {
        return this.__inherited(name, args, true);
      }
      return this.__inherited(name, true);
    }
    function inherited__debug(args, a1, a2) {
      var f = this.getInherited(args, a1);
      if (f) {
        return f.apply(this, a2 || a1 || args);
      }  // intentionally no return if a super method was not found
    }
    var inheritedImpl = dojo.config.isDebug ? inherited__debug : inherited;
    // emulation of "instanceof"
    function isInstanceOf(cls) {
      var bases = this.constructor._meta.bases;
      for (var i = 0, l = bases.length; i < l; ++i) {
        if (bases[i] === cls) {
          return true;
        }
      }
      return this instanceof cls;
    }
    function mixOwn(target, source) {
      // add props adding metadata for incoming functions skipping a constructor
      for (var name in source) {
        if (name != cname && source.hasOwnProperty(name)) {
          target[name] = source[name];
        }
      }
      if (has('bug-for-in-skips-shadowed')) {
        for (var extraNames = lang._extraNames, i = extraNames.length; i;) {
          name = extraNames[--i];
          if (name != cname && source.hasOwnProperty(name)) {
            target[name] = source[name];
          }
        }
      }
    }
    // implementation of safe mixin function
    function safeMixin(target, source) {
      // summary:
      //		Mix in properties skipping a constructor and decorating functions
      //		like it is done by declare().
      // target: Object
      //		Target object to accept new properties.
      // source: Object
      //		Source object for new properties.
      // description:
      //		This function is used to mix in properties like lang.mixin does,
      //		but it skips a constructor property and decorates functions like
      //		declare() does.
      //
      //		It is meant to be used with classes and objects produced with
      //		declare. Functions mixed in with dojo.safeMixin can use
      //		this.inherited() like normal methods.
      //
      //		This function is used to implement extend() method of a constructor
      //		produced with declare().
      //
      // example:
      //	|	var A = declare(null, {
      //	|		m1: function(){
      //	|			console.log("A.m1");
      //	|		},
      //	|		m2: function(){
      //	|			console.log("A.m2");
      //	|		}
      //	|	});
      //	|	var B = declare(A, {
      //	|		m1: function(){
      //	|			this.inherited(arguments);
      //	|			console.log("B.m1");
      //	|		}
      //	|	});
      //	|	B.extend({
      //	|		m2: function(){
      //	|			this.inherited(arguments);
      //	|			console.log("B.m2");
      //	|		}
      //	|	});
      //	|	var x = new B();
      //	|	dojo.safeMixin(x, {
      //	|		m1: function(){
      //	|			this.inherited(arguments);
      //	|			console.log("X.m1");
      //	|		},
      //	|		m2: function(){
      //	|			this.inherited(arguments);
      //	|			console.log("X.m2");
      //	|		}
      //	|	});
      //	|	x.m2();
      //	|	// prints:
      //	|	// A.m1
      //	|	// B.m1
      //	|	// X.m1
      var name, t;
      // add props adding metadata for incoming functions skipping a constructor
      for (name in source) {
        t = source[name];
        if ((t !== op[name] || !(name in op)) && name != cname) {
          if (opts.call(t) == '[object Function]') {
            // non-trivial function method => attach its name
            t.nom = name;
          }
          target[name] = t;
        }
      }
      if (has('bug-for-in-skips-shadowed')) {
        for (var extraNames = lang._extraNames, i = extraNames.length; i;) {
          name = extraNames[--i];
          t = source[name];
          if ((t !== op[name] || !(name in op)) && name != cname) {
            if (opts.call(t) == '[object Function]') {
              // non-trivial function method => attach its name
              t.nom = name;
            }
            target[name] = t;
          }
        }
      }
      return target;
    }
    function extend(source) {
      declare.safeMixin(this.prototype, source);
      return this;
    }
    function createSubclass(mixins, props) {
      // crack parameters
      if (!(mixins instanceof Array || typeof mixins == 'function')) {
        props = mixins;
        mixins = undefined;
      }
      props = props || {};
      mixins = mixins || [];
      return declare([this].concat(mixins), props);
    }
    // chained constructor compatible with the legacy declare()
    function chainedConstructor(bases, ctorSpecial) {
      return function () {
        var a = arguments, args = a, a0 = a[0], f, i, m, l = bases.length, preArgs;
        if (!(this instanceof a.callee)) {
          // not called via new, so force it
          return applyNew(a);
        }
        //this._inherited = {};
        // perform the shaman's rituals of the original declare()
        // 1) call two types of the preamble
        if (ctorSpecial && (a0 && a0.preamble || this.preamble)) {
          // full blown ritual
          preArgs = new Array(bases.length);
          // prepare parameters
          preArgs[0] = a;
          for (i = 0;;) {
            // process the preamble of the 1st argument
            a0 = a[0];
            if (a0) {
              f = a0.preamble;
              if (f) {
                a = f.apply(this, a) || a;
              }
            }
            // process the preamble of this class
            f = bases[i].prototype;
            f = f.hasOwnProperty('preamble') && f.preamble;
            if (f) {
              a = f.apply(this, a) || a;
            }
            // one peculiarity of the preamble:
            // it is called if it is not needed,
            // e.g., there is no constructor to call
            // let's watch for the last constructor
            // (see ticket #9795)
            if (++i == l) {
              break;
            }
            preArgs[i] = a;
          }
        }
        // 2) call all non-trivial constructors using prepared arguments
        for (i = l - 1; i >= 0; --i) {
          f = bases[i];
          m = f._meta;
          f = m ? m.ctor : f;
          if (f) {
            f.apply(this, preArgs ? preArgs[i] : a);
          }
        }
        // 3) continue the original ritual: call the postscript
        f = this.postscript;
        if (f) {
          f.apply(this, args);
        }
      };
    }
    // chained constructor compatible with the legacy declare()
    function singleConstructor(ctor, ctorSpecial) {
      return function () {
        var a = arguments, t = a, a0 = a[0], f;
        if (!(this instanceof a.callee)) {
          // not called via new, so force it
          return applyNew(a);
        }
        //this._inherited = {};
        // perform the shaman's rituals of the original declare()
        // 1) call two types of the preamble
        if (ctorSpecial) {
          // full blown ritual
          if (a0) {
            // process the preamble of the 1st argument
            f = a0.preamble;
            if (f) {
              t = f.apply(this, t) || t;
            }
          }
          f = this.preamble;
          if (f) {
            // process the preamble of this class
            f.apply(this, t);  // one peculiarity of the preamble:
                               // it is called even if it is not needed,
                               // e.g., there is no constructor to call
                               // let's watch for the last constructor
                               // (see ticket #9795)
          }
        }
        // 2) call a constructor
        if (ctor) {
          ctor.apply(this, a);
        }
        // 3) continue the original ritual: call the postscript
        f = this.postscript;
        if (f) {
          f.apply(this, a);
        }
      };
    }
    // plain vanilla constructor (can use inherited() to call its base constructor)
    function simpleConstructor(bases) {
      return function () {
        var a = arguments, i = 0, f, m;
        if (!(this instanceof a.callee)) {
          // not called via new, so force it
          return applyNew(a);
        }
        //this._inherited = {};
        // perform the shaman's rituals of the original declare()
        // 1) do not call the preamble
        // 2) call the top constructor (it can use this.inherited())
        for (; f = bases[i]; ++i) {
          // intentional assignment
          m = f._meta;
          f = m ? m.ctor : f;
          if (f) {
            f.apply(this, a);
            break;
          }
        }
        // 3) call the postscript
        f = this.postscript;
        if (f) {
          f.apply(this, a);
        }
      };
    }
    function chain(name, bases, reversed) {
      return function () {
        var b, m, f, i = 0, step = 1;
        if (reversed) {
          i = bases.length - 1;
          step = -1;
        }
        for (; b = bases[i]; i += step) {
          // intentional assignment
          m = b._meta;
          f = (m ? m.hidden : b.prototype)[name];
          if (f) {
            f.apply(this, arguments);
          }
        }
      };
    }
    // forceNew(ctor)
    // return a new object that inherits from ctor.prototype but
    // without actually running ctor on the object.
    function forceNew(ctor) {
    }
    // applyNew(args)
    // just like 'new ctor()' except that the constructor and its arguments come
    // from args, which must be an array or an arguments object
    function applyNew(args) {
      // create an object with ctor's prototype but without
      // calling ctor on it.
      var ctor = args.callee, t = forceNew(ctor);
      // execute the real constructor on the new object
      ctor.apply(t, args);
      return t;
    }
    function declare(className, superclass, props) {
      // summary:
      //		Create a feature-rich constructor from compact notation.
      // className: String?
      //		The optional name of the constructor (loosely, a "class")
      //		stored in the "declaredClass" property in the created prototype.
      //		It will be used as a global name for a created constructor.
      // superclass: Function|Function[]
      //		May be null, a Function, or an Array of Functions. This argument
      //		specifies a list of bases (the left-most one is the most deepest
      //		base).
      // props: Object
      //		An object whose properties are copied to the created prototype.
      //		Add an instance-initialization function by making it a property
      //		named "constructor".
      // returns: dojo/_base/declare.__DeclareCreatedObject
      //		New constructor function.
      // description:
      //		Create a constructor using a compact notation for inheritance and
      //		prototype extension.
      //
      //		Mixin ancestors provide a type of multiple inheritance.
      //		Prototypes of mixin ancestors are copied to the new class:
      //		changes to mixin prototypes will not affect classes to which
      //		they have been mixed in.
      //
      //		Ancestors can be compound classes created by this version of
      //		declare(). In complex cases all base classes are going to be
      //		linearized according to C3 MRO algorithm
      //		(see http://www.python.org/download/releases/2.3/mro/ for more
      //		details).
      //
      //		"className" is cached in "declaredClass" property of the new class,
      //		if it was supplied. The immediate super class will be cached in
      //		"superclass" property of the new class.
      //
      //		Methods in "props" will be copied and modified: "nom" property
      //		(the declared name of the method) will be added to all copied
      //		functions to help identify them for the internal machinery. Be
      //		very careful, while reusing methods: if you use the same
      //		function under different names, it can produce errors in some
      //		cases.
      //
      //		It is possible to use constructors created "manually" (without
      //		declare()) as bases. They will be called as usual during the
      //		creation of an instance, their methods will be chained, and even
      //		called by "this.inherited()".
      //
      //		Special property "-chains-" governs how to chain methods. It is
      //		a dictionary, which uses method names as keys, and hint strings
      //		as values. If a hint string is "after", this method will be
      //		called after methods of its base classes. If a hint string is
      //		"before", this method will be called before methods of its base
      //		classes.
      //
      //		If "constructor" is not mentioned in "-chains-" property, it will
      //		be chained using the legacy mode: using "after" chaining,
      //		calling preamble() method before each constructor, if available,
      //		and calling postscript() after all constructors were executed.
      //		If the hint is "after", it is chained as a regular method, but
      //		postscript() will be called after the chain of constructors.
      //		"constructor" cannot be chained "before", but it allows
      //		a special hint string: "manual", which means that constructors
      //		are not going to be chained in any way, and programmer will call
      //		them manually using this.inherited(). In the latter case
      //		postscript() will be called after the construction.
      //
      //		All chaining hints are "inherited" from base classes and
      //		potentially can be overridden. Be very careful when overriding
      //		hints! Make sure that all chained methods can work in a proposed
      //		manner of chaining.
      //
      //		Once a method was chained, it is impossible to unchain it. The
      //		only exception is "constructor". You don't need to define a
      //		method in order to supply a chaining hint.
      //
      //		If a method is chained, it cannot use this.inherited() because
      //		all other methods in the hierarchy will be called automatically.
      //
      //		Usually constructors and initializers of any kind are chained
      //		using "after" and destructors of any kind are chained as
      //		"before". Note that chaining assumes that chained methods do not
      //		return any value: any returned value will be discarded.
      //
      // example:
      //	|	declare("my.classes.bar", my.classes.foo, {
      //	|		// properties to be added to the class prototype
      //	|		someValue: 2,
      //	|		// initialization function
      //	|		constructor: function(){
      //	|			this.myComplicatedObject = new ReallyComplicatedObject();
      //	|		},
      //	|		// other functions
      //	|		someMethod: function(){
      //	|			doStuff();
      //	|		}
      //	|	});
      //
      // example:
      //	|	var MyBase = declare(null, {
      //	|		// constructor, properties, and methods go here
      //	|		// ...
      //	|	});
      //	|	var MyClass1 = declare(MyBase, {
      //	|		// constructor, properties, and methods go here
      //	|		// ...
      //	|	});
      //	|	var MyClass2 = declare(MyBase, {
      //	|		// constructor, properties, and methods go here
      //	|		// ...
      //	|	});
      //	|	var MyDiamond = declare([MyClass1, MyClass2], {
      //	|		// constructor, properties, and methods go here
      //	|		// ...
      //	|	});
      //
      // example:
      //	|	var F = function(){ console.log("raw constructor"); };
      //	|	F.prototype.method = function(){
      //	|		console.log("raw method");
      //	|	};
      //	|	var A = declare(F, {
      //	|		constructor: function(){
      //	|			console.log("A.constructor");
      //	|		},
      //	|		method: function(){
      //	|			console.log("before calling F.method...");
      //	|			this.inherited(arguments);
      //	|			console.log("...back in A");
      //	|		}
      //	|	});
      //	|	new A().method();
      //	|	// will print:
      //	|	// raw constructor
      //	|	// A.constructor
      //	|	// before calling F.method...
      //	|	// raw method
      //	|	// ...back in A
      //
      // example:
      //	|	var A = declare(null, {
      //	|		"-chains-": {
      //	|			destroy: "before"
      //	|		}
      //	|	});
      //	|	var B = declare(A, {
      //	|		constructor: function(){
      //	|			console.log("B.constructor");
      //	|		},
      //	|		destroy: function(){
      //	|			console.log("B.destroy");
      //	|		}
      //	|	});
      //	|	var C = declare(B, {
      //	|		constructor: function(){
      //	|			console.log("C.constructor");
      //	|		},
      //	|		destroy: function(){
      //	|			console.log("C.destroy");
      //	|		}
      //	|	});
      //	|	new C().destroy();
      //	|	// prints:
      //	|	// B.constructor
      //	|	// C.constructor
      //	|	// C.destroy
      //	|	// B.destroy
      //
      // example:
      //	|	var A = declare(null, {
      //	|		"-chains-": {
      //	|			constructor: "manual"
      //	|		}
      //	|	});
      //	|	var B = declare(A, {
      //	|		constructor: function(){
      //	|			// ...
      //	|			// call the base constructor with new parameters
      //	|			this.inherited(arguments, [1, 2, 3]);
      //	|			// ...
      //	|		}
      //	|	});
      //
      // example:
      //	|	var A = declare(null, {
      //	|		"-chains-": {
      //	|			m1: "before"
      //	|		},
      //	|		m1: function(){
      //	|			console.log("A.m1");
      //	|		},
      //	|		m2: function(){
      //	|			console.log("A.m2");
      //	|		}
      //	|	});
      //	|	var B = declare(A, {
      //	|		"-chains-": {
      //	|			m2: "after"
      //	|		},
      //	|		m1: function(){
      //	|			console.log("B.m1");
      //	|		},
      //	|		m2: function(){
      //	|			console.log("B.m2");
      //	|		}
      //	|	});
      //	|	var x = new B();
      //	|	x.m1();
      //	|	// prints:
      //	|	// B.m1
      //	|	// A.m1
      //	|	x.m2();
      //	|	// prints:
      //	|	// A.m2
      //	|	// B.m2
      // crack parameters
      if (typeof className != 'string') {
        props = superclass;
        superclass = className;
        className = '';
      }
      props = props || {};
      var proto, i, t, ctor, name, bases, chains, mixins = 1, parents = superclass;
      // build a prototype
      if (opts.call(superclass) == '[object Array]') {
        // C3 MRO
        bases = c3mro(superclass, className);
        t = bases[0];
        mixins = bases.length - t;
        superclass = bases[mixins];
      } else {
        bases = [0];
        if (superclass) {
          if (opts.call(superclass) == '[object Function]') {
            t = superclass._meta;
            bases = bases.concat(t ? t.bases : superclass);
          } else {
            err('base class is not a callable constructor.', className);
          }
        } else if (superclass !== null) {
          err('unknown base class. Did you use dojo.require to pull it in?', className);
        }
      }
      if (superclass) {
        for (i = mixins - 1;; --i) {
          proto = forceNew(superclass);
          if (!i) {
            // stop if nothing to add (the last base)
            break;
          }
          // mix in properties
          t = bases[i];
          (t._meta ? mixOwn : mix)(proto, t.prototype);
          // chain in new constructor
          ctor = new Function();
          ctor.superclass = superclass;
          ctor.prototype = proto;
          superclass = proto.constructor = ctor;
        }
      } else {
        proto = {};
      }
      // add all properties
      declare.safeMixin(proto, props);
      // add constructor
      t = props.constructor;
      if (t !== op.constructor) {
        t.nom = cname;
        proto.constructor = t;
      }
      // collect chains and flags
      for (i = mixins - 1; i; --i) {
        // intentional assignment
        t = bases[i]._meta;
        if (t && t.chains) {
          chains = mix(chains || {}, t.chains);
        }
      }
      if (proto['-chains-']) {
        chains = mix(chains || {}, proto['-chains-']);
      }
      // build ctor
      t = !chains || !chains.hasOwnProperty(cname);
      bases[0] = ctor = chains && chains.constructor === 'manual' ? simpleConstructor(bases) : bases.length == 1 ? singleConstructor(props.constructor, t) : chainedConstructor(bases, t);
      // add meta information to the constructor
      ctor._meta = {
        bases: bases,
        hidden: props,
        chains: chains,
        parents: parents,
        ctor: props.constructor
      };
      ctor.superclass = superclass && superclass.prototype;
      ctor.extend = extend;
      ctor.createSubclass = createSubclass;
      ctor.prototype = proto;
      proto.constructor = ctor;
      // add "standard" methods to the prototype
      proto.getInherited = getInherited;
      proto.isInstanceOf = isInstanceOf;
      proto.inherited = inheritedImpl;
      proto.__inherited = inherited;
      // add name if specified
      if (className) {
        proto.declaredClass = className;
        lang.setObject(className, ctor);
      }
      // build chains and add them to the prototype
      if (chains) {
        for (name in chains) {
          if (proto[name] && typeof chains[name] == 'string' && name != cname) {
            t = proto[name] = chain(name, bases, chains[name] === 'after');
            t.nom = name;
          }
        }
      }
      // chained methods do not return values
      // no need to chain "invisible" functions
      return ctor;  // Function
    }
    /*=====
    	declare.__DeclareCreatedObject = {
    		// summary:
    		//		dojo/_base/declare() returns a constructor `C`.   `new C()` returns an Object with the following
    		//		methods, in addition to the methods and properties specified via the arguments passed to declare().
    
    		inherited: function(name, args, newArgs){
    			// summary:
    			//		Calls a super method.
    			// name: String?
    			//		The optional method name. Should be the same as the caller's
    			//		name. Usually "name" is specified in complex dynamic cases, when
    			//		the calling method was dynamically added, undecorated by
    			//		declare(), and it cannot be determined.
    			// args: Arguments
    			//		The caller supply this argument, which should be the original
    			//		"arguments".
    			// newArgs: Object?
    			//		If "true", the found function will be returned without
    			//		executing it.
    			//		If Array, it will be used to call a super method. Otherwise
    			//		"args" will be used.
    			// returns:
    			//		Whatever is returned by a super method, or a super method itself,
    			//		if "true" was specified as newArgs.
    			// description:
    			//		This method is used inside method of classes produced with
    			//		declare() to call a super method (next in the chain). It is
    			//		used for manually controlled chaining. Consider using the regular
    			//		chaining, because it is faster. Use "this.inherited()" only in
    			//		complex cases.
    			//
    			//		This method cannot me called from automatically chained
    			//		constructors including the case of a special (legacy)
    			//		constructor chaining. It cannot be called from chained methods.
    			//
    			//		If "this.inherited()" cannot find the next-in-chain method, it
    			//		does nothing and returns "undefined". The last method in chain
    			//		can be a default method implemented in Object, which will be
    			//		called last.
    			//
    			//		If "name" is specified, it is assumed that the method that
    			//		received "args" is the parent method for this call. It is looked
    			//		up in the chain list and if it is found the next-in-chain method
    			//		is called. If it is not found, the first-in-chain method is
    			//		called.
    			//
    			//		If "name" is not specified, it will be derived from the calling
    			//		method (using a methoid property "nom").
    			//
    			// example:
    			//	|	var B = declare(A, {
    			//	|		method1: function(a, b, c){
    			//	|			this.inherited(arguments);
    			//	|		},
    			//	|		method2: function(a, b){
    			//	|			return this.inherited(arguments, [a + b]);
    			//	|		}
    			//	|	});
    			//	|	// next method is not in the chain list because it is added
    			//	|	// manually after the class was created.
    			//	|	B.prototype.method3 = function(){
    			//	|		console.log("This is a dynamically-added method.");
    			//	|		this.inherited("method3", arguments);
    			//	|	};
    			// example:
    			//	|	var B = declare(A, {
    			//	|		method: function(a, b){
    			//	|			var super = this.inherited(arguments, true);
    			//	|			// ...
    			//	|			if(!super){
    			//	|				console.log("there is no super method");
    			//	|				return 0;
    			//	|			}
    			//	|			return super.apply(this, arguments);
    			//	|		}
    			//	|	});
    			return	{};	// Object
    		},
    
    		getInherited: function(name, args){
    			// summary:
    			//		Returns a super method.
    			// name: String?
    			//		The optional method name. Should be the same as the caller's
    			//		name. Usually "name" is specified in complex dynamic cases, when
    			//		the calling method was dynamically added, undecorated by
    			//		declare(), and it cannot be determined.
    			// args: Arguments
    			//		The caller supply this argument, which should be the original
    			//		"arguments".
    			// returns:
    			//		Returns a super method (Function) or "undefined".
    			// description:
    			//		This method is a convenience method for "this.inherited()".
    			//		It uses the same algorithm but instead of executing a super
    			//		method, it returns it, or "undefined" if not found.
    			//
    			// example:
    			//	|	var B = declare(A, {
    			//	|		method: function(a, b){
    			//	|			var super = this.getInherited(arguments);
    			//	|			// ...
    			//	|			if(!super){
    			//	|				console.log("there is no super method");
    			//	|				return 0;
    			//	|			}
    			//	|			return super.apply(this, arguments);
    			//	|		}
    			//	|	});
    			return	{};	// Object
    		},
    
    		isInstanceOf: function(cls){
    			// summary:
    			//		Checks the inheritance chain to see if it is inherited from this
    			//		class.
    			// cls: Function
    			//		Class constructor.
    			// returns:
    			//		"true", if this object is inherited from this class, "false"
    			//		otherwise.
    			// description:
    			//		This method is used with instances of classes produced with
    			//		declare() to determine of they support a certain interface or
    			//		not. It models "instanceof" operator.
    			//
    			// example:
    			//	|	var A = declare(null, {
    			//	|		// constructor, properties, and methods go here
    			//	|		// ...
    			//	|	});
    			//	|	var B = declare(null, {
    			//	|		// constructor, properties, and methods go here
    			//	|		// ...
    			//	|	});
    			//	|	var C = declare([A, B], {
    			//	|		// constructor, properties, and methods go here
    			//	|		// ...
    			//	|	});
    			//	|	var D = declare(A, {
    			//	|		// constructor, properties, and methods go here
    			//	|		// ...
    			//	|	});
    			//	|
    			//	|	var a = new A(), b = new B(), c = new C(), d = new D();
    			//	|
    			//	|	console.log(a.isInstanceOf(A)); // true
    			//	|	console.log(b.isInstanceOf(A)); // false
    			//	|	console.log(c.isInstanceOf(A)); // true
    			//	|	console.log(d.isInstanceOf(A)); // true
    			//	|
    			//	|	console.log(a.isInstanceOf(B)); // false
    			//	|	console.log(b.isInstanceOf(B)); // true
    			//	|	console.log(c.isInstanceOf(B)); // true
    			//	|	console.log(d.isInstanceOf(B)); // false
    			//	|
    			//	|	console.log(a.isInstanceOf(C)); // false
    			//	|	console.log(b.isInstanceOf(C)); // false
    			//	|	console.log(c.isInstanceOf(C)); // true
    			//	|	console.log(d.isInstanceOf(C)); // false
    			//	|
    			//	|	console.log(a.isInstanceOf(D)); // false
    			//	|	console.log(b.isInstanceOf(D)); // false
    			//	|	console.log(c.isInstanceOf(D)); // false
    			//	|	console.log(d.isInstanceOf(D)); // true
    			return	{};	// Object
    		},
    
    		extend: function(source){
    			// summary:
    			//		Adds all properties and methods of source to constructor's
    			//		prototype, making them available to all instances created with
    			//		constructor. This method is specific to constructors created with
    			//		declare().
    			// source: Object
    			//		Source object which properties are going to be copied to the
    			//		constructor's prototype.
    			// description:
    			//		Adds source properties to the constructor's prototype. It can
    			//		override existing properties.
    			//
    			//		This method is similar to dojo.extend function, but it is specific
    			//		to constructors produced by declare(). It is implemented
    			//		using dojo.safeMixin, and it skips a constructor property,
    			//		and properly decorates copied functions.
    			//
    			// example:
    			//	|	var A = declare(null, {
    			//	|		m1: function(){},
    			//	|		s1: "Popokatepetl"
    			//	|	});
    			//	|	A.extend({
    			//	|		m1: function(){},
    			//	|		m2: function(){},
    			//	|		f1: true,
    			//	|		d1: 42
    			//	|	});
    		},
    
    		createSubclass: function(mixins, props){
    			// summary:
    			//		Create a subclass of the declared class from a list of base classes.
    			// mixins: Function[]
    			//		Specifies a list of bases (the left-most one is the most deepest
    			//		base).
    			// props: Object?
    			//		An optional object whose properties are copied to the created prototype.
    			// returns: dojo/_base/declare.__DeclareCreatedObject
    			//		New constructor function.
    			// description:
    			//		Create a constructor using a compact notation for inheritance and
    			//		prototype extension.
    			//
    			//		Mixin ancestors provide a type of multiple inheritance.
    			//		Prototypes of mixin ancestors are copied to the new class:
    			//		changes to mixin prototypes will not affect classes to which
    			//		they have been mixed in.
    			//
    			// example:
    			//	|	var A = declare(null, {
    			//	|		m1: function(){},
    			//	|		s1: "bar"
    			//	|	});
    			//	|	var B = declare(null, {
    			//	|		m2: function(){},
    			//	|		s2: "foo"
    			//	|	});
    			//	|	var C = declare(null, {
    			//	|	});
    			//	|	var D1 = A.createSubclass([B, C], {
    			//	|		m1: function(){},
    			//	|		d1: 42
    			//	|	});
    			//	|	var d1 = new D1();
    			//	|
    			//	|	// this is equivalent to:
    			//	|	var D2 = declare([A, B, C], {
    			//	|		m1: function(){},
    			//	|		d1: 42
    			//	|	});
    			//	|	var d2 = new D2();
    		}
    	};
    	=====*/
    // For back-compat, remove for 2.0
    dojo.safeMixin = declare.safeMixin = safeMixin;
    dojo.declare = declare;
    return declare;
  }(dojo__base_kernel, dojo_has, dojo__base_lang);
  dojo_dom_class = function (lang, array, dom) {
    // module:
    //		dojo/dom-class
    var className = 'className';
    /* Part I of classList-based implementation is preserved here for posterity
    	var classList = "classList";
    	has.add("dom-classList", function(){
    		return classList in document.createElement("p");
    	});
    	*/
    // =============================
    // (CSS) Class Functions
    // =============================
    var cls,
      // exports object
      spaces = /\s+/, a1 = [''];
    function str2array(s) {
      if (typeof s == 'string' || s instanceof String) {
        if (s && !spaces.test(s)) {
          a1[0] = s;
          return a1;
        }
        var a = s.split(spaces);
        if (a.length && !a[0]) {
          a.shift();
        }
        if (a.length && !a[a.length - 1]) {
          a.pop();
        }
        return a;
      }
      // assumed to be an array
      if (!s) {
        return [];
      }
      return array.filter(s, function (x) {
        return x;
      });
    }
    /* Part II of classList-based implementation is preserved here for posterity
    	if(has("dom-classList")){
    		// new classList version
    		cls = {
    			contains: function containsClass(node, classStr){
    				var clslst = classStr && dom.byId(node)[classList];
    				return clslst && clslst.contains(classStr); // Boolean
    			},
    
    			add: function addClass(node, classStr){
    				node = dom.byId(node);
    				classStr = str2array(classStr);
    				for(var i = 0, len = classStr.length; i < len; ++i){
    					node[classList].add(classStr[i]);
    				}
    			},
    
    			remove: function removeClass(node, classStr){
    				node = dom.byId(node);
    				if(classStr === undefined){
    					node[className] = "";
    				}else{
    					classStr = str2array(classStr);
    					for(var i = 0, len = classStr.length; i < len; ++i){
    						node[classList].remove(classStr[i]);
    					}
    				}
    			},
    
    			replace: function replaceClass(node, addClassStr, removeClassStr){
    				node = dom.byId(node);
    				if(removeClassStr === undefined){
    					node[className] = "";
    				}else{
    					removeClassStr = str2array(removeClassStr);
    					for(var i = 0, len = removeClassStr.length; i < len; ++i){
    						node[classList].remove(removeClassStr[i]);
    					}
    				}
    				addClassStr = str2array(addClassStr);
    				for(i = 0, len = addClassStr.length; i < len; ++i){
    					node[classList].add(addClassStr[i]);
    				}
    			},
    
    			toggle: function toggleClass(node, classStr, condition){
    				node = dom.byId(node);
    				if(condition === undefined){
    					classStr = str2array(classStr);
    					for(var i = 0, len = classStr.length; i < len; ++i){
    						node[classList].toggle(classStr[i]);
    					}
    				}else{
    					cls[condition ? "add" : "remove"](node, classStr);
    				}
    				return condition;   // Boolean
    			}
    		}
    	}
    	*/
    // regular DOM version
    var fakeNode = {};
    // for effective replacement
    cls = {
      // summary:
      //		This module defines the core dojo DOM class API.
      contains: function containsClass(node, classStr) {
        // summary:
        //		Returns whether or not the specified classes are a portion of the
        //		class list currently applied to the node.
        // node: String|DOMNode
        //		String ID or DomNode reference to check the class for.
        // classStr: String
        //		A string class name to look for.
        // example:
        //		Do something if a node with id="someNode" has class="aSillyClassName" present
        //	|	if(dojo.hasClass("someNode","aSillyClassName")){ ... }
        return (' ' + dom.byId(node)[className] + ' ').indexOf(' ' + classStr + ' ') >= 0;  // Boolean
      },
      add: function addClass(node, classStr) {
        // summary:
        //		Adds the specified classes to the end of the class list on the
        //		passed node. Will not re-apply duplicate classes.
        //
        // node: String|DOMNode
        //		String ID or DomNode reference to add a class string too
        //
        // classStr: String|Array
        //		A String class name to add, or several space-separated class names,
        //		or an array of class names.
        //
        // example:
        //		Add a class to some node:
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.add("someNode", "anewClass");
        //	|	});
        //
        // example:
        //		Add two classes at once:
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.add("someNode", "firstClass secondClass");
        //	|	});
        //
        // example:
        //		Add two classes at once (using array):
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.add("someNode", ["firstClass", "secondClass"]);
        //	|	});
        //
        // example:
        //		Available in `dojo/NodeList` for multiple additions
        //	|	require(["dojo/query"], function(query){
        //	|		query("ul > li").addClass("firstLevel");
        //	|	});
        node = dom.byId(node);
        classStr = str2array(classStr);
        var cls = node[className], oldLen;
        cls = cls ? ' ' + cls + ' ' : ' ';
        oldLen = cls.length;
        for (var i = 0, len = classStr.length, c; i < len; ++i) {
          c = classStr[i];
          if (c && cls.indexOf(' ' + c + ' ') < 0) {
            cls += c + ' ';
          }
        }
        if (oldLen < cls.length) {
          node[className] = cls.substr(1, cls.length - 2);
        }
      },
      remove: function removeClass(node, classStr) {
        // summary:
        //		Removes the specified classes from node. No `contains()`
        //		check is required.
        //
        // node: String|DOMNode
        //		String ID or DomNode reference to remove the class from.
        //
        // classStr: String|Array
        //		An optional String class name to remove, or several space-separated
        //		class names, or an array of class names. If omitted, all class names
        //		will be deleted.
        //
        // example:
        //		Remove a class from some node:
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.remove("someNode", "firstClass");
        //	|	});
        //
        // example:
        //		Remove two classes from some node:
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.remove("someNode", "firstClass secondClass");
        //	|	});
        //
        // example:
        //		Remove two classes from some node (using array):
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.remove("someNode", ["firstClass", "secondClass"]);
        //	|	});
        //
        // example:
        //		Remove all classes from some node:
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.remove("someNode");
        //	|	});
        //
        // example:
        //		Available in `dojo/NodeList` for multiple removal
        //	|	require(["dojo/query"], function(query){
        //	|		query("ul > li").removeClass("foo");
        //	|	});
        node = dom.byId(node);
        var cls;
        if (classStr !== undefined) {
          classStr = str2array(classStr);
          cls = ' ' + node[className] + ' ';
          for (var i = 0, len = classStr.length; i < len; ++i) {
            cls = cls.replace(' ' + classStr[i] + ' ', ' ');
          }
          cls = lang.trim(cls);
        } else {
          cls = '';
        }
        if (node[className] != cls) {
          node[className] = cls;
        }
      },
      replace: function replaceClass(node, addClassStr, removeClassStr) {
        // summary:
        //		Replaces one or more classes on a node if not present.
        //		Operates more quickly than calling dojo.removeClass and dojo.addClass
        //
        // node: String|DOMNode
        //		String ID or DomNode reference to remove the class from.
        //
        // addClassStr: String|Array
        //		A String class name to add, or several space-separated class names,
        //		or an array of class names.
        //
        // removeClassStr: String|Array?
        //		A String class name to remove, or several space-separated class names,
        //		or an array of class names.
        //
        // example:
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.replace("someNode", "add1 add2", "remove1 remove2");
        //	|	});
        //
        // example:
        //	Replace all classes with addMe
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.replace("someNode", "addMe");
        //	|	});
        //
        // example:
        //	Available in `dojo/NodeList` for multiple toggles
        //	|	require(["dojo/query"], function(query){
        //	|		query(".findMe").replaceClass("addMe", "removeMe");
        //	|	});
        node = dom.byId(node);
        fakeNode[className] = node[className];
        cls.remove(fakeNode, removeClassStr);
        cls.add(fakeNode, addClassStr);
        if (node[className] !== fakeNode[className]) {
          node[className] = fakeNode[className];
        }
      },
      toggle: function toggleClass(node, classStr, condition) {
        // summary:
        //		Adds a class to node if not present, or removes if present.
        //		Pass a boolean condition if you want to explicitly add or remove.
        //		Returns the condition that was specified directly or indirectly.
        //
        // node: String|DOMNode
        //		String ID or DomNode reference to toggle a class string
        //
        // classStr: String|Array
        //		A String class name to toggle, or several space-separated class names,
        //		or an array of class names.
        //
        // condition:
        //		If passed, true means to add the class, false means to remove.
        //		Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.
        //
        // example:
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.toggle("someNode", "hovered");
        //	|	});
        //
        // example:
        //		Forcefully add a class
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.toggle("someNode", "hovered", true);
        //	|	});
        //
        // example:
        //		Available in `dojo/NodeList` for multiple toggles
        //	|	require(["dojo/query"], function(query){
        //	|		query(".toggleMe").toggleClass("toggleMe");
        //	|	});
        node = dom.byId(node);
        if (condition === undefined) {
          classStr = str2array(classStr);
          for (var i = 0, len = classStr.length, c; i < len; ++i) {
            c = classStr[i];
            cls[cls.contains(node, c) ? 'remove' : 'add'](node, c);
          }
        } else {
          cls[condition ? 'add' : 'remove'](node, classStr);
        }
        return condition;  // Boolean
      }
    };
    return cls;
  }(dojo__base_lang, dojo__base_array, dojo_dom);
  dojo_NodeList_dom = function (dojo, query, array, lang, domCls, domCtr, domGeom, domAttr, domStyle) {
    // module:
    //		dojo/NodeList-dom.js
    /*=====
    return function(){
     // summary:
     //		Adds DOM related methods to NodeList, and returns NodeList constructor.
    };
    =====*/
    var magicGuard = function (a) {
      // summary:
      //		the guard function for dojo/dom-attr() and dojo/dom-style()
      return a.length == 1 && typeof a[0] == 'string';  // inline'd type check
    };
    var orphan = function (node) {
      // summary:
      //		function to orphan nodes
      var p = node.parentNode;
      if (p) {
        p.removeChild(node);
      }
    };
    // FIXME: should we move orphan() to dojo/_base/html?
    var NodeList = query.NodeList, awc = NodeList._adaptWithCondition, aafe = NodeList._adaptAsForEach, aam = NodeList._adaptAsMap;
    function getSet(module) {
      return function (node, name, value) {
        if (arguments.length == 2) {
          return module[typeof name == 'string' ? 'get' : 'set'](node, name);
        }
        // setter
        return module.set(node, name, value);
      };
    }
    lang.extend(NodeList, {
      _normalize: function (content, refNode) {
        // summary:
        //		normalizes data to an array of items to insert.
        // description:
        //		If content is an object, it can have special properties "template" and
        //		"parse". If "template" is defined, then the template value is run through
        //		dojo/string.substitute (if dojo/string.substitute() has been required elsewhere),
        //		or if templateFunc is a function on the content, that function will be used to
        //		transform the template into a final string to be used for for passing to dojo/dom-construct.toDom().
        //		If content.parse is true, then it is remembered for later, for when the content
        //		nodes are inserted into the DOM. At that point, the nodes will be parsed for widgets
        //		(if dojo/parser has been required elsewhere).
        //Wanted to just use a DocumentFragment, but for the array/NodeList
        //case that meant using cloneNode, but we may not want that.
        //Cloning should only happen if the node operations span
        //multiple refNodes. Also, need a real array, not a NodeList from the
        //DOM since the node movements could change those NodeLists.
        var parse = content.parse === true;
        //Do we have an object that needs to be run through a template?
        if (typeof content.template == 'string') {
          var templateFunc = content.templateFunc || dojo.string && dojo.string.substitute;
          content = templateFunc ? templateFunc(content.template, content) : content;
        }
        var type = typeof content;
        if (type == 'string' || type == 'number') {
          content = domCtr.toDom(content, refNode && refNode.ownerDocument);
          if (content.nodeType == 11) {
            //DocumentFragment. It cannot handle cloneNode calls, so pull out the children.
            content = lang._toArray(content.childNodes);
          } else {
            content = [content];
          }
        } else if (!lang.isArrayLike(content)) {
          content = [content];
        } else if (!lang.isArray(content)) {
          //To get to this point, content is array-like, but
          //not an array, which likely means a DOM NodeList. Convert it now.
          content = lang._toArray(content);
        }
        //Pass around the parse info
        if (parse) {
          content._runParse = true;
        }
        return content;  //Array
      },
      _cloneNode: function (node) {
        // summary:
        //		private utility to clone a node. Not very interesting in the vanilla
        //		dojo/NodeList case, but delegates could do interesting things like
        //		clone event handlers if that is derivable from the node.
        return node.cloneNode(true);
      },
      _place: function (ary, refNode, position, useClone) {
        // summary:
        //		private utility to handle placing an array of nodes relative to another node.
        // description:
        //		Allows for cloning the nodes in the array, and for
        //		optionally parsing widgets, if ary._runParse is true.
        //Avoid a disallowed operation if trying to do an innerHTML on a non-element node.
        if (refNode.nodeType != 1 && position == 'only') {
          return;
        }
        var rNode = refNode, tempNode;
        //Always cycle backwards in case the array is really a
        //DOM NodeList and the DOM operations take it out of the live collection.
        var length = ary.length;
        for (var i = length - 1; i >= 0; i--) {
          var node = useClone ? this._cloneNode(ary[i]) : ary[i];
          //If need widget parsing, use a temp node, instead of waiting after inserting into
          //real DOM because we need to start widget parsing at one node up from current node,
          //which could cause some already parsed widgets to be parsed again.
          if (ary._runParse && dojo.parser && dojo.parser.parse) {
            if (!tempNode) {
              tempNode = rNode.ownerDocument.createElement('div');
            }
            tempNode.appendChild(node);
            dojo.parser.parse(tempNode);
            node = tempNode.firstChild;
            while (tempNode.firstChild) {
              tempNode.removeChild(tempNode.firstChild);
            }
          }
          if (i == length - 1) {
            domCtr.place(node, rNode, position);
          } else {
            rNode.parentNode.insertBefore(node, rNode);
          }
          rNode = node;
        }
      },
      position: aam(domGeom.position),
      /*=====
      		position: function(){
      			// summary:
      			//		Returns border-box objects (x/y/w/h) of all elements in a node list
      			//		as an Array (*not* a NodeList). Acts like `dojo/dom-geometry-position`, though
      			//		assumes the node passed is each node in this list.
      
      			return dojo.map(this, dojo.position); // Array
      		},
      		=====*/
      attr: awc(getSet(domAttr), magicGuard),
      /*=====
      attr: function(property, value){
      	// summary:
      	//		gets or sets the DOM attribute for every element in the
      	//		NodeList. See also `dojo/dom-attr`
      	// property: String
      	//		the attribute to get/set
      	// value: String?
      	//		optional. The value to set the property to
      	// returns:
      	//		if no value is passed, the result is an array of attribute values
      	//		If a value is passed, the return is this NodeList
      	// example:
      	//		Make all nodes with a particular class focusable:
      	//	|	require(["dojo/query", "dojo/NodeList-dom"], function(query){
      	//	|		query(".focusable").attr("tabIndex", -1);
      	//	|	});
      	// example:
      	//		Disable a group of buttons:
      	//	|	require(["dojo/query", "dojo/NodeList-dom"], function(query){
      	//	|		query("button.group").attr("disabled", true);
      	//	|	});
      	// example:
      	//		innerHTML can be assigned or retrieved as well:
      	//	|	// get the innerHTML (as an array) for each list item
      	//	|	require(["dojo/query", "dojo/NodeList-dom"], function(query){
      	//	|		var ih = query("li.replaceable").attr("innerHTML");
      	//	|	});
      	return; // dojo/NodeList|Array
      },
      =====*/
      style: awc(getSet(domStyle), magicGuard),
      /*=====
      style: function(property, value){
      	// summary:
      	//		gets or sets the CSS property for every element in the NodeList
      	// property: String
      	//		the CSS property to get/set, in JavaScript notation
      	//		("lineHieght" instead of "line-height")
      	// value: String?
      	//		optional. The value to set the property to
      	// returns:
      	//		if no value is passed, the result is an array of strings.
      	//		If a value is passed, the return is this NodeList
      	return; // dojo/NodeList
      	return; // Array
      },
      =====*/
      addClass: aafe(domCls.add),
      /*=====
      addClass: function(className){
      	// summary:
      	//		adds the specified class to every node in the list
      	// className: String|Array
      	//		A String class name to add, or several space-separated class names,
      	//		or an array of class names.
      	return; // dojo/NodeList
      },
      =====*/
      removeClass: aafe(domCls.remove),
      /*=====
      removeClass: function(className){
      	// summary:
      	//		removes the specified class from every node in the list
      	// className: String|Array?
      	//		An optional String class name to remove, or several space-separated
      	//		class names, or an array of class names. If omitted, all class names
      	//		will be deleted.
      	// returns:
      	//		this list
      	return; // dojo/NodeList
      },
      =====*/
      toggleClass: aafe(domCls.toggle),
      /*=====
      toggleClass: function(className, condition){
      	// summary:
      	//		Adds a class to node if not present, or removes if present.
      	//		Pass a boolean condition if you want to explicitly add or remove.
      	// condition: Boolean?
      	//		If passed, true means to add the class, false means to remove.
      	// className: String
      	//		the CSS class to add
      	return; // dojo/NodeList
      },
      =====*/
      replaceClass: aafe(domCls.replace),
      /*=====
      replaceClass: function(addClassStr, removeClassStr){
      	// summary:
      	//		Replaces one or more classes on a node if not present.
      	//		Operates more quickly than calling `removeClass()` and `addClass()`
      	// addClassStr: String|Array
      	//		A String class name to add, or several space-separated class names,
      	//		or an array of class names.
      	// removeClassStr: String|Array?
      	//		A String class name to remove, or several space-separated class names,
      	//		or an array of class names.
      	return; // dojo/NodeList
       },
       =====*/
      empty: aafe(domCtr.empty),
      /*=====
      empty: function(){
      	// summary:
      	//		clears all content from each node in the list. Effectively
      	//		equivalent to removing all child nodes from every item in
      	//		the list.
      	return this.forEach("item.innerHTML='';"); // dojo/NodeList
      	// FIXME: should we be checking for and/or disposing of widgets below these nodes?
      },
      =====*/
      removeAttr: aafe(domAttr.remove),
      /*=====
       removeAttr: function(name){
      	// summary:
      	//		Removes an attribute from each node in the list.
      	// name: String
      	//		the name of the attribute to remove
      	return;		// dojo/NodeList
      },
      =====*/
      marginBox: aam(domGeom.getMarginBox),
      /*=====
      marginBox: function(){
      	// summary:
      	//		Returns margin-box size of nodes
       	return; // dojo/NodeList
       },
       =====*/
      // FIXME: connectPublisher()? connectRunOnce()?
      /*
      destroy: function(){
      	// summary:
      	//		destroys every item in the list.
      	this.forEach(d.destroy);
      	// FIXME: should we be checking for and/or disposing of widgets below these nodes?
      },
      */
      place: function (queryOrNode, position) {
        // summary:
        //		places elements of this node list relative to the first element matched
        //		by queryOrNode. Returns the original NodeList. See: `dojo/dom-construct.place`
        // queryOrNode:
        //		may be a string representing any valid CSS3 selector or a DOM node.
        //		In the selector case, only the first matching element will be used
        //		for relative positioning.
        // position:
        //		can be one of:
        //
        //		-	"last" (default)
        //		-	"first"
        //		-	"before"
        //		-	"after"
        //		-	"only"
        //		-	"replace"
        //
        //		or an offset in the childNodes property
        var item = query(queryOrNode)[0];
        return this.forEach(function (node) {
          domCtr.place(node, item, position);
        });  // dojo/NodeList
      },
      orphan: function (filter) {
        // summary:
        //		removes elements in this list that match the filter
        //		from their parents and returns them as a new NodeList.
        // filter:
        //		CSS selector like ".foo" or "div > span"
        // returns:
        //		NodeList containing the orphaned elements
        return (filter ? query._filterResult(this, filter) : this).forEach(orphan);  // dojo/NodeList
      },
      adopt: function (queryOrListOrNode, position) {
        // summary:
        //		places any/all elements in queryOrListOrNode at a
        //		position relative to the first element in this list.
        //		Returns a dojo/NodeList of the adopted elements.
        // queryOrListOrNode:
        //		a DOM node or a query string or a query result.
        //		Represents the nodes to be adopted relative to the
        //		first element of this NodeList.
        // position:
        //		can be one of:
        //
        //		-	"last" (default)
        //		-	"first"
        //		-	"before"
        //		-	"after"
        //		-	"only"
        //		-	"replace"
        //
        //		or an offset in the childNodes property
        return query(queryOrListOrNode).place(this[0], position)._stash(this);  // dojo/NodeList
      },
      // FIXME: do we need this?
      query: function (queryStr) {
        // summary:
        //		Returns a new list whose members match the passed query,
        //		assuming elements of the current NodeList as the root for
        //		each search.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div id="foo">
        //	|		<p>
        //	|			bacon is tasty, <span>dontcha think?</span>
        //	|		</p>
        //	|	</div>
        //	|	<div id="bar">
        //	|		<p>great comedians may not be funny <span>in person</span></p>
        //	|	</div>
        //		If we are presented with the following definition for a NodeList:
        //	|	require(["dojo/dom", "dojo/query", "dojo/NodeList-dom"
        //	|	], function(dom, query){
        //	|		var l = new NodeList(dom.byId("foo"), dom.byId("bar"));
        //		it's possible to find all span elements under paragraphs
        //		contained by these elements with this sub-query:
        //	|		var spans = l.query("p span");
        //	|	});
        // FIXME: probably slow
        if (!queryStr) {
          return this;
        }
        var ret = new NodeList();
        this.map(function (node) {
          // FIXME: why would we ever get undefined here?
          query(queryStr, node).forEach(function (subNode) {
            if (subNode !== undefined) {
              ret.push(subNode);
            }
          });
        });
        return ret._stash(this);  // dojo/NodeList
      },
      filter: function (filter) {
        // summary:
        //		"masks" the built-in javascript filter() method (supported
        //		in Dojo via `dojo.filter`) to support passing a simple
        //		string filter in addition to supporting filtering function
        //		objects.
        // filter:
        //		If a string, a CSS rule like ".thinger" or "div > span".
        // example:
        //		"regular" JS filter syntax as exposed in dojo.filter:
        //	|	require(["dojo/query", "dojo/NodeList-dom"
        //	|	], function(query){
        //	|		query("*").filter(function(item){
        //	|			// highlight every paragraph
        //	|			return (item.nodeName == "p");
        //	|		}).style("backgroundColor", "yellow");
        //	|	});
        // example:
        //	the same filtering using a CSS selector
        //	|	require(["dojo/query", "dojo/NodeList-dom"
        //	|	], function(query){
        //	|		query("*").filter("p").styles("backgroundColor", "yellow");
        //	|	});
        var a = arguments, items = this, start = 0;
        if (typeof filter == 'string') {
          // inline'd type check
          items = query._filterResult(this, a[0]);
          if (a.length == 1) {
            // if we only got a string query, pass back the filtered results
            return items._stash(this);  // dojo/NodeList
          }
          // if we got a callback, run it over the filtered items
          start = 1;
        }
        return this._wrap(array.filter(items, a[start], a[start + 1]), this);  // dojo/NodeList
      },
      /*
      // FIXME: should this be "copyTo" and include parenting info?
      clone: function(){
      	// summary:
      	//		creates node clones of each element of this list
      	//		and returns a new list containing the clones
      },
      */
      addContent: function (content, position) {
        // summary:
        //		add a node, NodeList or some HTML as a string to every item in the
        //		list.  Returns the original list.
        // description:
        //		a copy of the HTML content is added to each item in the
        //		list, with an optional position argument. If no position
        //		argument is provided, the content is appended to the end of
        //		each item.
        // content:
        //		DOM node, HTML in string format, a NodeList or an Object. If a DOM node or
        //		NodeList, the content will be cloned if the current NodeList has more than one
        //		element. Only the DOM nodes are cloned, no event handlers. If it is an Object,
        //		it should be an object with at "template" String property that has the HTML string
        //		to insert. If dojo.string has already been dojo.required, then dojo.string.substitute
        //		will be used on the "template" to generate the final HTML string. Other allowed
        //		properties on the object are: "parse" if the HTML
        //		string should be parsed for widgets (dojo.require("dojo.parser") to get that
        //		option to work), and "templateFunc" if a template function besides dojo.string.substitute
        //		should be used to transform the "template".
        // position:
        //		can be one of:
        //
        //		-	"last"||"end" (default)
        //		-	"first||"start"
        //		-	"before"
        //		-	"after"
        //		-	"replace" (replaces nodes in this NodeList with new content)
        //		-	"only" (removes other children of the nodes so new content is the only child)
        //
        //		or an offset in the childNodes property
        // example:
        //		appends content to the end if the position is omitted
        //	|	require(["dojo/query", "dojo/NodeList-dom"
        //	|	], function(query){
        //	|		query("h3 > p").addContent("hey there!");
        //	|	});
        // example:
        //		add something to the front of each element that has a
        //		"thinger" property:
        //	|	require(["dojo/query", "dojo/NodeList-dom"
        //	|	], function(query){
        //	|		query("[thinger]").addContent("...", "first");
        //	|	});
        // example:
        //		adds a header before each element of the list
        //	|	require(["dojo/query", "dojo/NodeList-dom"
        //	|	], function(query){
        //	|		query(".note").addContent("<h4>NOTE:</h4>", "before");
        //	|	});
        // example:
        //		add a clone of a DOM node to the end of every element in
        //		the list, removing it from its existing parent.
        //	|	require(["dojo/dom", "dojo/query", "dojo/NodeList-dom"
        //	|	], function(dom, query){
        //	|		query(".note").addContent(dom.byId("foo"));
        //	|	});
        // example:
        //		Append nodes from a templatized string.
        //	|	require(["dojo/string", "dojo/query", "dojo/NodeList-dom"
        //	|	], function(string, query){
        //	|		query(".note").addContent({
        //	|			template: '<b>${id}: </b><span>${name}</span>',
        //	|			id: "user332",
        //	|			name: "Mr. Anderson"
        //	|		});
        //	|	});
        // example:
        //		Append nodes from a templatized string that also has widgets parsed.
        //	|	require(["dojo/string", "dojo/parser", "dojo/query", "dojo/NodeList-dom"
        //	|	], function(string, parser, query){
        //	|		var notes = query(".note").addContent({
        //	|			template: '<button dojoType="dijit/form/Button">${text}</button>',
        //	|			parse: true,
        //	|			text: "Send"
        //	|		});
        //	|	});
        content = this._normalize(content, this[0]);
        for (var i = 0, node; node = this[i]; i++) {
          if (content.length) {
            this._place(content, node, position, i > 0);
          } else {
            // if it is an empty array, we empty the target node
            domCtr.empty(node);
          }
        }
        return this;  // dojo/NodeList
      }
    });
    return NodeList;
  }(dojo__base_kernel, dojo_query, dojo__base_array, dojo__base_lang, dojo_dom_class, dojo_dom_construct, dojo_dom_geometry, dojo_dom_attr, dojo_dom_style);
  dojo_NodeList_traverse = function (dquery, lang, array) {
    // module:
    //		dojo/NodeList-traverse
    /*=====
    return function(){
    	// summary:
    	//		Adds chainable methods to dojo/query() / NodeList instances for traversing the DOM
    };
    =====*/
    var NodeList = dquery.NodeList;
    lang.extend(NodeList, {
      _buildArrayFromCallback: function (callback) {
        // summary:
        //		builds a new array of possibly differing size based on the input list.
        //		Since the returned array is likely of different size than the input array,
        //		the array's map function cannot be used.
        var ary = [];
        for (var i = 0; i < this.length; i++) {
          var items = callback.call(this[i], this[i], ary);
          if (items) {
            ary = ary.concat(items);
          }
        }
        return ary;  //Array
      },
      _getUniqueAsNodeList: function (nodes) {
        // summary:
        //		given a list of nodes, make sure only unique
        //		elements are returned as our NodeList object.
        //		Does not call _stash().
        var ary = [];
        //Using for loop for better speed.
        for (var i = 0, node; node = nodes[i]; i++) {
          //Should be a faster way to do this. dojo/query has a private
          //_zip function that may be inspirational, but there are pathways
          //in query that force nozip?
          if (node.nodeType == 1 && array.indexOf(ary, node) == -1) {
            ary.push(node);
          }
        }
        return this._wrap(ary, null, this._NodeListCtor);  // dojo/NodeList
      },
      _getUniqueNodeListWithParent: function (nodes, query) {
        // summary:
        //		gets unique element nodes, filters them further
        //		with an optional query and then calls _stash to track parent NodeList.
        var ary = this._getUniqueAsNodeList(nodes);
        ary = query ? dquery._filterResult(ary, query) : ary;
        return ary._stash(this);  // dojo/NodeList
      },
      _getRelatedUniqueNodes: function (query, callback) {
        // summary:
        //		cycles over all the nodes and calls a callback
        //		to collect nodes for a possible inclusion in a result.
        //		The callback will get two args: callback(node, ary),
        //		where ary is the array being used to collect the nodes.
        return this._getUniqueNodeListWithParent(this._buildArrayFromCallback(callback), query);  // dojo/NodeList
      },
      children: function (query) {
        // summary:
        //		Returns all immediate child elements for nodes in this dojo/NodeList.
        //		Optionally takes a query to filter the child elements.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // query:
        //		a CSS selector.
        // returns:
        //		all immediate child elements for the nodes in this dojo/NodeList.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		Some Text
        // 	|		<div class="blue">Blue One</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".container").children();
        //	|	});
        //		returns the four divs that are children of the container div.
        //		Running this code:
        //	|	dojo.query(".container").children(".red");
        //		returns the two divs that have the class "red".
        return this._getRelatedUniqueNodes(query, function (node, ary) {
          return lang._toArray(node.childNodes);
        });  // dojo/NodeList
      },
      closest: function (query, root) {
        // summary:
        //		Returns closest parent that matches query, including current node in this
        //		dojo/NodeList if it matches the query.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // query:
        //		a CSS selector.
        // root:
        //		If specified, query is relative to "root" rather than document body.
        // returns:
        //		the closest parent that matches the query, including the current
        //		node in this dojo/NodeList if it matches the query.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        //	|		<div class="red">Red One</div>
        //	|		Some Text
        //	|		<div class="blue">Blue One</div>
        //	|		<div class="red">Red Two</div>
        //	|		<div class="blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".red").closest(".container");
        //	|	});
        //		returns the div with class "container".
        return this._getRelatedUniqueNodes(null, function (node, ary) {
          do {
            if (dquery._filterResult([node], query, root).length) {
              return node;
            }
          } while (node != root && (node = node.parentNode) && node.nodeType == 1);
          return null;  //To make rhino strict checking happy.
        });  // dojo/NodeList
      },
      parent: function (query) {
        // summary:
        //		Returns immediate parent elements for nodes in this dojo/NodeList.
        //		Optionally takes a query to filter the parent elements.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // query:
        //		a CSS selector.
        // returns:
        //		immediate parent elements for nodes in this dojo/NodeList.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		<div class="blue first"><span class="text">Blue One</span></div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue"><span class="text">Blue Two</span></div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".text").parent();
        //	|	});
        //		returns the two divs with class "blue".
        //		Running this code:
        //	|		query(".text").parent(".first");
        //		returns the one div with class "blue" and "first".
        return this._getRelatedUniqueNodes(query, function (node, ary) {
          return node.parentNode;
        });  // dojo/NodeList
      },
      parents: function (query) {
        // summary:
        //		Returns all parent elements for nodes in this dojo/NodeList.
        //		Optionally takes a query to filter the child elements.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // query:
        //		a CSS selector.
        // returns:
        //		all parent elements for nodes in this dojo/NodeList.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		<div class="blue first"><span class="text">Blue One</span></div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue"><span class="text">Blue Two</span></div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".text").parents();
        //	|	});
        //		returns the two divs with class "blue", the div with class "container",
        // 	|	the body element and the html element.
        //		Running this code:
        //	|		query(".text").parents(".container");
        //		returns the one div with class "container".
        return this._getRelatedUniqueNodes(query, function (node, ary) {
          var pary = [];
          while (node.parentNode) {
            node = node.parentNode;
            pary.push(node);
          }
          return pary;
        });  // dojo/NodeList
      },
      siblings: function (query) {
        // summary:
        //		Returns all sibling elements for nodes in this dojo/NodeList.
        //		Optionally takes a query to filter the sibling elements.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // query:
        //		a CSS selector.
        // returns:
        //		all sibling elements for nodes in this dojo/NodeList.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		Some Text
        // 	|		<div class="blue first">Blue One</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".first").siblings();
        //	|	});
        //		returns the two divs with class "red" and the other div
        // 	|	with class "blue" that does not have "first".
        //		Running this code:
        //	|		query(".first").siblings(".red");
        //		returns the two div with class "red".
        return this._getRelatedUniqueNodes(query, function (node, ary) {
          var pary = [];
          var nodes = node.parentNode && node.parentNode.childNodes;
          for (var i = 0; i < nodes.length; i++) {
            if (nodes[i] != node) {
              pary.push(nodes[i]);
            }
          }
          return pary;
        });  // dojo/NodeList
      },
      next: function (query) {
        // summary:
        //		Returns the next element for nodes in this dojo/NodeList.
        //		Optionally takes a query to filter the next elements.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // query:
        //		a CSS selector.
        // returns:
        //		the next element for nodes in this dojo/NodeList.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		Some Text
        // 	|		<div class="blue first">Blue One</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue last">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".first").next();
        //	|	});
        //		returns the div with class "red" and has innerHTML of "Red Two".
        //		Running this code:
        //	|	dojo.query(".last").next(".red");
        //		does not return any elements.
        return this._getRelatedUniqueNodes(query, function (node, ary) {
          var next = node.nextSibling;
          while (next && next.nodeType != 1) {
            next = next.nextSibling;
          }
          return next;
        });  // dojo/NodeList
      },
      nextAll: function (query) {
        // summary:
        //		Returns all sibling elements that come after the nodes in this dojo/NodeList.
        //		Optionally takes a query to filter the sibling elements.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // query:
        //		a CSS selector.
        // returns:
        //		all sibling elements that come after the nodes in this dojo/NodeList.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		Some Text
        // 	|		<div class="blue first">Blue One</div>
        // 	|		<div class="red next">Red Two</div>
        // 	|		<div class="blue next">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".first").nextAll();
        //	|	});
        //		returns the two divs with class of "next".
        //		Running this code:
        //	|		query(".first").nextAll(".red");
        //		returns the one div with class "red" and innerHTML "Red Two".
        return this._getRelatedUniqueNodes(query, function (node, ary) {
          var pary = [];
          var next = node;
          while (next = next.nextSibling) {
            if (next.nodeType == 1) {
              pary.push(next);
            }
          }
          return pary;
        });  // dojo/NodeList
      },
      prev: function (query) {
        // summary:
        //		Returns the previous element for nodes in this dojo/NodeList.
        //		Optionally takes a query to filter the previous elements.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // query:
        //		a CSS selector.
        // returns:
        //		the previous element for nodes in this dojo/NodeList.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		Some Text
        // 	|		<div class="blue first">Blue One</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".first").prev();
        //	|	});
        //		returns the div with class "red" and has innerHTML of "Red One".
        //		Running this code:
        //	|		query(".first").prev(".blue");
        //		does not return any elements.
        return this._getRelatedUniqueNodes(query, function (node, ary) {
          var prev = node.previousSibling;
          while (prev && prev.nodeType != 1) {
            prev = prev.previousSibling;
          }
          return prev;
        });  // dojo/NodeList
      },
      prevAll: function (query) {
        // summary:
        //		Returns all sibling elements that come before the nodes in this dojo/NodeList.
        //		Optionally takes a query to filter the sibling elements.
        // description:
        //		The returned nodes will be in reverse DOM order -- the first node in the list will
        //		be the node closest to the original node/NodeList.
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // query:
        //		a CSS selector.
        // returns:
        //		all sibling elements that come before the nodes in this dojo/NodeList.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red prev">Red One</div>
        // 	|		Some Text
        // 	|		<div class="blue prev">Blue One</div>
        // 	|		<div class="red second">Red Two</div>
        // 	|		<div class="blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".second").prevAll();
        //	|	});
        //		returns the two divs with class of "prev".
        //		Running this code:
        //	|		query(".first").prevAll(".red");
        //		returns the one div with class "red prev" and innerHTML "Red One".
        return this._getRelatedUniqueNodes(query, function (node, ary) {
          var pary = [];
          var prev = node;
          while (prev = prev.previousSibling) {
            if (prev.nodeType == 1) {
              pary.push(prev);
            }
          }
          return pary;
        });  // dojo/NodeList
      },
      andSelf: function () {
        // summary:
        //		Adds the nodes from the previous dojo/NodeList to the current dojo/NodeList.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red prev">Red One</div>
        // 	|		Some Text
        // 	|		<div class="blue prev">Blue One</div>
        // 	|		<div class="red second">Red Two</div>
        // 	|		<div class="blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".second").prevAll().andSelf();
        //	|	});
        //		returns the two divs with class of "prev", as well as the div with class "second".
        return this.concat(this._parent);  // dojo/NodeList
      },
      //Alternate methods for the :first/:last/:even/:odd pseudos.
      first: function () {
        // summary:
        //		Returns the first node in this dojo/NodeList as a dojo/NodeList.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // returns:
        //		the first node in this dojo/NodeList
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		<div class="blue first">Blue One</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue last">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".blue").first();
        //	|	});
        //		returns the div with class "blue" and "first".
        return this._wrap(this[0] && [this[0]] || [], this);  // dojo/NodeList
      },
      last: function () {
        // summary:
        //		Returns the last node in this dojo/NodeList as a dojo/NodeList.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // returns:
        //		the last node in this dojo/NodeList
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		<div class="blue first">Blue One</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue last">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|	query(".blue").last();
        //	|	});
        //		returns the last div with class "blue",
        return this._wrap(this.length ? [this[this.length - 1]] : [], this);  // dojo/NodeList
      },
      even: function () {
        // summary:
        //		Returns the even nodes in this dojo/NodeList as a dojo/NodeList.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // returns:
        //		the even nodes in this dojo/NodeList
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="interior red">Red One</div>
        // 	|		<div class="interior blue">Blue One</div>
        // 	|		<div class="interior red">Red Two</div>
        // 	|		<div class="interior blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".interior").even();
        //	|	});
        //		returns the two divs with class "blue"
        return this.filter(function (item, i) {
          return i % 2 != 0;
        });  // dojo/NodeList
      },
      odd: function () {
        // summary:
        //		Returns the odd nodes in this dojo/NodeList as a dojo/NodeList.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // returns:
        //		the odd nodes in this dojo/NodeList
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="interior red">Red One</div>
        // 	|		<div class="interior blue">Blue One</div>
        // 	|		<div class="interior red">Red Two</div>
        // 	|		<div class="interior blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".interior").odd();
        //	|	});
        //		returns the two divs with class "red"
        return this.filter(function (item, i) {
          return i % 2 == 0;
        });  // dojo/NodeList
      }
    });
    return NodeList;
  }(dojo_query, dojo__base_lang, dojo__base_array);
  dojo_NodeList_manipulate = function (dquery, lang, array, construct, attr) {
    // module:
    //		dojo/NodeList-manipulate
    /*=====
    	return function(){
    		// summary:
    		//		Adds chainable methods to dojo.query() / NodeList instances for manipulating HTML
    		//		and DOM nodes and their properties.
    	};
    	=====*/
    var NodeList = dquery.NodeList;
    //TODO: add a way to parse for widgets in the injected markup?
    function getWrapInsertion(node) {
      // summary:
      //		finds the innermost element to use for wrap insertion.
      //Make it easy, assume single nesting, no siblings.
      while (node.childNodes[0] && node.childNodes[0].nodeType == 1) {
        node = node.childNodes[0];
      }
      return node;  //DOMNode
    }
    function makeWrapNode(html, refNode) {
      // summary:
      //		convert HTML into nodes if it is not already a node.
      if (typeof html == 'string') {
        html = construct.toDom(html, refNode && refNode.ownerDocument);
        if (html.nodeType == 11) {
          //DocumentFragment cannot handle cloneNode, so choose first child.
          html = html.childNodes[0];
        }
      } else if (html.nodeType == 1 && html.parentNode) {
        //This element is already in the DOM clone it, but not its children.
        html = html.cloneNode(false);
      }
      return html;  /*DOMNode*/
    }
    lang.extend(NodeList, {
      _placeMultiple: function (query, position) {
        // summary:
        //		private method for inserting queried nodes into all nodes in this NodeList
        //		at different positions. Differs from NodeList.place because it will clone
        //		the nodes in this NodeList if the query matches more than one element.
        var nl2 = typeof query == 'string' || query.nodeType ? dquery(query) : query;
        var toAdd = [];
        for (var i = 0; i < nl2.length; i++) {
          //Go backwards in DOM to make dom insertions easier via insertBefore
          var refNode = nl2[i];
          var length = this.length;
          for (var j = length - 1, item; item = this[j]; j--) {
            if (i > 0) {
              //Need to clone the item. This also means
              //it needs to be added to the current NodeList
              //so it can also be the target of other chaining operations.
              item = this._cloneNode(item);
              toAdd.unshift(item);
            }
            if (j == length - 1) {
              construct.place(item, refNode, position);
            } else {
              refNode.parentNode.insertBefore(item, refNode);
            }
            refNode = item;
          }
        }
        if (toAdd.length) {
          //Add the toAdd items to the current NodeList. Build up list of args
          //to pass to splice.
          toAdd.unshift(0);
          toAdd.unshift(this.length - 1);
          Array.prototype.splice.apply(this, toAdd);
        }
        return this;  // dojo/NodeList
      },
      innerHTML: function (value) {
        // summary:
        //		allows setting the innerHTML of each node in the NodeList,
        //		if there is a value passed in, otherwise, reads the innerHTML value of the first node.
        // description:
        //		This method is simpler than the dojo/NodeList.html() method provided by
        //		`dojo/NodeList-html`. This method just does proper innerHTML insertion of HTML fragments,
        //		and it allows for the innerHTML to be read for the first node in the node list.
        //		Since dojo/NodeList-html already took the "html" name, this method is called
        //		"innerHTML". However, if dojo/NodeList-html has not been loaded yet, this
        //		module will define an "html" method that can be used instead. Be careful if you
        //		are working in an environment where it is possible that dojo/NodeList-html could
        //		have been loaded, since its definition of "html" will take precedence.
        //		The nodes represented by the value argument will be cloned if more than one
        //		node is in this NodeList. The nodes in this NodeList are returned in the "set"
        //		usage of this method, not the HTML that was inserted.
        // returns:
        //		if no value is passed, the result is String, the innerHTML of the first node.
        //		If a value is passed, the return is this dojo/NodeList
        // example:
        //		assume a DOM created by this markup:
        //	|	<div id="foo"></div>
        //	|	<div id="bar"></div>
        //		This code inserts `<p>Hello World</p>` into both divs:
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		query("div").innerHTML("<p>Hello World</p>");
        //	| 	});
        // example:
        //		assume a DOM created by this markup:
        //	|	<div id="foo"><p>Hello Mars</p></div>
        //	|	<div id="bar"><p>Hello World</p></div>
        //		This code returns `<p>Hello Mars</p>`:
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		var message = query("div").innerHTML();
        //	| 	});
        if (arguments.length) {
          return this.addContent(value, 'only');  // dojo/NodeList
        } else {
          return this[0].innerHTML;  //String
        }
      },
      /*=====
      html: function(value){
      	// summary:
      	//		see the information for "innerHTML". "html" is an alias for "innerHTML", but is
      	//		only defined if dojo/NodeList-html has not been loaded.
      	// description:
      	//		An alias for the "innerHTML" method, but only defined if there is not an existing
      	//		"html" method on dojo/NodeList. Be careful if you are working in an environment
      	//		where it is possible that dojo/NodeList-html could have been loaded, since its
      	//		definition of "html" will take precedence. If you are not sure if dojo/NodeList-html
      	//		could be loaded, use the "innerHTML" method.
      	// value: String|DOMNode|NodeList?
      	//		The HTML fragment to use as innerHTML. If value is not passed, then the innerHTML
      	//		of the first element in this NodeList is returned.
      	// returns:
      	//		if no value is passed, the result is String, the innerHTML of the first node.
      	//		If a value is passed, the return is this dojo/NodeList
      	return; // dojo/NodeList|String
      },
      =====*/
      text: function (value) {
        // summary:
        //		allows setting the text value of each node in the NodeList,
        //		if there is a value passed in, otherwise, returns the text value for all the
        //		nodes in the NodeList in one string.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div id="foo"></div>
        //	|	<div id="bar"></div>
        //		This code inserts "Hello World" into both divs:
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		query("div").text("Hello World");
        //	| 	});
        // example:
        //		assume a DOM created by this markup:
        //	|	<div id="foo"><p>Hello Mars <span>today</span></p></div>
        //	|	<div id="bar"><p>Hello World</p></div>
        //		This code returns "Hello Mars today":
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		var message = query("div").text();
        //	| 	});
        // returns:
        //		if no value is passed, the result is String, the text value of the first node.
        //		If a value is passed, the return is this dojo/NodeList
        if (arguments.length) {
          for (var i = 0, node; node = this[i]; i++) {
            if (node.nodeType == 1) {
              attr.set(node, 'textContent', value);
            }
          }
          return this;  // dojo/NodeList
        } else {
          var result = '';
          for (i = 0; node = this[i]; i++) {
            result += attr.get(node, 'textContent');
          }
          return result;  //String
        }
      },
      val: function (value) {
        // summary:
        //		If a value is passed, allows seting the value property of form elements in this
        //		NodeList, or properly selecting/checking the right value for radio/checkbox/select
        //		elements. If no value is passed, the value of the first node in this NodeList
        //		is returned.
        // returns:
        //		if no value is passed, the result is String or an Array, for the value of the
        //		first node.
        //		If a value is passed, the return is this dojo/NodeList
        // example:
        //		assume a DOM created by this markup:
        //	|	<input type="text" value="foo">
        //	|	<select multiple>
        //	|		<option value="red" selected>Red</option>
        //	|		<option value="blue">Blue</option>
        //	|		<option value="yellow" selected>Yellow</option>
        //	|	</select>
        //		This code gets and sets the values for the form fields above:
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		query('[type="text"]').val(); //gets value foo
        //	|		query('[type="text"]').val("bar"); //sets the input's value to "bar"
        // 	|		query("select").val() //gets array value ["red", "yellow"]
        // 	|		query("select").val(["blue", "yellow"]) //Sets the blue and yellow options to selected.
        //	| 	});
        //Special work for input elements.
        if (arguments.length) {
          var isArray = lang.isArray(value);
          for (var index = 0, node; node = this[index]; index++) {
            var name = node.nodeName.toUpperCase();
            var type = node.type;
            var newValue = isArray ? value[index] : value;
            if (name == 'SELECT') {
              var opts = node.options;
              for (var i = 0; i < opts.length; i++) {
                var opt = opts[i];
                if (node.multiple) {
                  opt.selected = array.indexOf(value, opt.value) != -1;
                } else {
                  opt.selected = opt.value == newValue;
                }
              }
            } else if (type == 'checkbox' || type == 'radio') {
              node.checked = node.value == newValue;
            } else {
              node.value = newValue;
            }
          }
          return this;  // dojo/NodeList
        } else {
          //node already declared above.
          node = this[0];
          if (!node || node.nodeType != 1) {
            return undefined;
          }
          value = node.value || '';
          if (node.nodeName.toUpperCase() == 'SELECT' && node.multiple) {
            //A multivalued selectbox. Do the pain.
            value = [];
            //opts declared above in if block.
            opts = node.options;
            //i declared above in if block;
            for (i = 0; i < opts.length; i++) {
              //opt declared above in if block
              opt = opts[i];
              if (opt.selected) {
                value.push(opt.value);
              }
            }
            if (!value.length) {
              value = null;
            }
          }
          return value;  //String||Array
        }
      },
      append: function (content) {
        // summary:
        //		appends the content to every node in the NodeList.
        // description:
        //		The content will be cloned if the length of NodeList
        //		is greater than 1. Only the DOM nodes are cloned, not
        //		any attached event handlers.
        // returns:
        //		dojo/NodeList, the nodes currently in this NodeList will be returned,
        //		not the appended content.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div id="foo"><p>Hello Mars</p></div>
        //	|	<div id="bar"><p>Hello World</p></div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		query("div").append("<span>append</span>");
        //	| 	});
        //		Results in this DOM structure:
        //	|	<div id="foo"><p>Hello Mars</p><span>append</span></div>
        //	|	<div id="bar"><p>Hello World</p><span>append</span></div>
        return this.addContent(content, 'last');  // dojo/NodeList
      },
      appendTo: function (query) {
        // summary:
        //		appends nodes in this NodeList to the nodes matched by
        //		the query passed to appendTo.
        // description:
        //		The nodes in this NodeList will be cloned if the query
        //		matches more than one element. Only the DOM nodes are cloned, not
        //		any attached event handlers.
        // returns:
        //		dojo/NodeList, the nodes currently in this NodeList will be returned,
        //		not the matched nodes from the query.
        // example:
        //		assume a DOM created by this markup:
        //	|	<span>append</span>
        //	|	<p>Hello Mars</p>
        //	|	<p>Hello World</p>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		query("span").appendTo("p");
        //	| 	});
        //		Results in this DOM structure:
        //	|	<p>Hello Mars<span>append</span></p>
        //	|	<p>Hello World<span>append</span></p>
        return this._placeMultiple(query, 'last');  // dojo/NodeList
      },
      prepend: function (content) {
        // summary:
        //		prepends the content to every node in the NodeList.
        // description:
        //		The content will be cloned if the length of NodeList
        //		is greater than 1. Only the DOM nodes are cloned, not
        //		any attached event handlers.
        // returns:
        //		dojo/NodeList, the nodes currently in this NodeList will be returned,
        //		not the appended content.
        //		assume a DOM created by this markup:
        //	|	<div id="foo"><p>Hello Mars</p></div>
        //	|	<div id="bar"><p>Hello World</p></div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		query("div").prepend("<span>prepend</span>");
        //	| 	});
        //		Results in this DOM structure:
        //	|	<div id="foo"><span>prepend</span><p>Hello Mars</p></div>
        //	|	<div id="bar"><span>prepend</span><p>Hello World</p></div>
        return this.addContent(content, 'first');  // dojo/NodeList
      },
      prependTo: function (query) {
        // summary:
        //		prepends nodes in this NodeList to the nodes matched by
        //		the query passed to prependTo.
        // description:
        //		The nodes in this NodeList will be cloned if the query
        //		matches more than one element. Only the DOM nodes are cloned, not
        //		any attached event handlers.
        // returns:
        //		dojo/NodeList, the nodes currently in this NodeList will be returned,
        //		not the matched nodes from the query.
        // example:
        //		assume a DOM created by this markup:
        //	|	<span>prepend</span>
        //	|	<p>Hello Mars</p>
        //	|	<p>Hello World</p>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		query("span").prependTo("p");
        //	| 	});
        //		Results in this DOM structure:
        //	|	<p><span>prepend</span>Hello Mars</p>
        //	|	<p><span>prepend</span>Hello World</p>
        return this._placeMultiple(query, 'first');  // dojo/NodeList
      },
      after: function (content) {
        // summary:
        //		Places the content after every node in the NodeList.
        // description:
        //		The content will be cloned if the length of NodeList
        //		is greater than 1. Only the DOM nodes are cloned, not
        //		any attached event handlers.
        // returns:
        //		dojo/NodeList, the nodes currently in this NodeList will be returned,
        //		not the appended content.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div id="foo"><p>Hello Mars</p></div>
        //	|	<div id="bar"><p>Hello World</p></div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		query("div").after("<span>after</span>");
        //	| 	});
        //		Results in this DOM structure:
        //	|	<div id="foo"><p>Hello Mars</p></div><span>after</span>
        //	|	<div id="bar"><p>Hello World</p></div><span>after</span>
        return this.addContent(content, 'after');  // dojo/NodeList
      },
      insertAfter: function (query) {
        // summary:
        //		The nodes in this NodeList will be placed after the nodes
        //		matched by the query passed to insertAfter.
        // description:
        //		The nodes in this NodeList will be cloned if the query
        //		matches more than one element. Only the DOM nodes are cloned, not
        //		any attached event handlers.
        // returns:
        //		dojo/NodeList, the nodes currently in this NodeList will be returned,
        //		not the matched nodes from the query.
        // example:
        //		assume a DOM created by this markup:
        //	|	<span>after</span>
        //	|	<p>Hello Mars</p>
        //	|	<p>Hello World</p>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		query("span").insertAfter("p");
        //	| 	});
        //		Results in this DOM structure:
        //	|	<p>Hello Mars</p><span>after</span>
        //	|	<p>Hello World</p><span>after</span>
        return this._placeMultiple(query, 'after');  // dojo/NodeList
      },
      before: function (content) {
        // summary:
        //		Places the content before every node in the NodeList.
        // description:
        //		The content will be cloned if the length of NodeList
        //		is greater than 1. Only the DOM nodes are cloned, not
        //		any attached event handlers.
        // returns:
        //		dojo/NodeList, the nodes currently in this NodeList will be returned,
        //		not the appended content.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div id="foo"><p>Hello Mars</p></div>
        //	|	<div id="bar"><p>Hello World</p></div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		query("div").before("<span>before</span>");
        //	| 	});
        //		Results in this DOM structure:
        //	|	<span>before</span><div id="foo"><p>Hello Mars</p></div>
        //	|	<span>before</span><div id="bar"><p>Hello World</p></div>
        return this.addContent(content, 'before');  // dojo/NodeList
      },
      insertBefore: function (query) {
        // summary:
        //		The nodes in this NodeList will be placed after the nodes
        //		matched by the query passed to insertAfter.
        // description:
        //		The nodes in this NodeList will be cloned if the query
        //		matches more than one element. Only the DOM nodes are cloned, not
        //		any attached event handlers.
        // returns:
        //		dojo/NodeList, the nodes currently in this NodeList will be returned,
        //		not the matched nodes from the query.
        // example:
        //		assume a DOM created by this markup:
        //	|	<span>before</span>
        //	|	<p>Hello Mars</p>
        //	|	<p>Hello World</p>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		query("span").insertBefore("p");
        //	| 	});
        //		Results in this DOM structure:
        //	|	<span>before</span><p>Hello Mars</p>
        //	|	<span>before</span><p>Hello World</p>
        return this._placeMultiple(query, 'before');  // dojo/NodeList
      },
      /*=====
      		remove: function(simpleFilter){
      			// summary:
      			//		alias for dojo/NodeList's orphan method. Removes elements
      			//		in this list that match the simple filter from their parents
      			//		and returns them as a new NodeList.
      			// simpleFilter: String
      			//		single-expression CSS rule. For example, ".thinger" or
      			//		"#someId[attrName='value']" but not "div > span". In short,
      			//		anything which does not invoke a descent to evaluate but
      			//		can instead be used to test a single node is acceptable.
      
      			return; // dojo/NodeList
      		},
      		=====*/
      remove: NodeList.prototype.orphan,
      wrap: function (html) {
        // summary:
        //		Wrap each node in the NodeList with html passed to wrap.
        // description:
        //		html will be cloned if the NodeList has more than one
        //		element. Only DOM nodes are cloned, not any attached
        //		event handlers.
        // returns:
        //		the nodes in the current NodeList will be returned,
        //		not the nodes from html argument.
        // example:
        //		assume a DOM created by this markup:
        //	|	<b>one</b>
        //	|	<b>two</b>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		query("b").wrap("<div><span></span></div>");
        //	| 	});
        //		Results in this DOM structure:
        //	|	<div><span><b>one</b></span></div>
        //	|	<div><span><b>two</b></span></div>
        if (this[0]) {
          html = makeWrapNode(html, this[0]);
          //Now cycle through the elements and do the insertion.
          for (var i = 0, node; node = this[i]; i++) {
            //Always clone because if html is used to hold one of
            //the "this" nodes, then on the clone of html it will contain
            //that "this" node, and that would be bad.
            var clone = this._cloneNode(html);
            if (node.parentNode) {
              node.parentNode.replaceChild(clone, node);
            }
            //Find deepest element and insert old node in it.
            var insertion = getWrapInsertion(clone);
            insertion.appendChild(node);
          }
        }
        return this;  // dojo/NodeList
      },
      wrapAll: function (html) {
        // summary:
        //		Insert html where the first node in this NodeList lives, then place all
        //		nodes in this NodeList as the child of the html.
        // returns:
        //		the nodes in the current NodeList will be returned,
        //		not the nodes from html argument.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		<div class="blue">Blue One</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		query(".red").wrapAll('<div class="allRed"></div>');
        //	| 	});
        //		Results in this DOM structure:
        //	|	<div class="container">
        // 	|		<div class="allRed">
        // 	|			<div class="red">Red One</div>
        // 	|			<div class="red">Red Two</div>
        // 	|		</div>
        // 	|		<div class="blue">Blue One</div>
        // 	|		<div class="blue">Blue Two</div>
        //	|	</div>
        if (this[0]) {
          html = makeWrapNode(html, this[0]);
          //Place the wrap HTML in place of the first node.
          this[0].parentNode.replaceChild(html, this[0]);
          //Now cycle through the elements and move them inside
          //the wrap.
          var insertion = getWrapInsertion(html);
          for (var i = 0, node; node = this[i]; i++) {
            insertion.appendChild(node);
          }
        }
        return this;  // dojo/NodeList
      },
      wrapInner: function (html) {
        // summary:
        //		For each node in the NodeList, wrap all its children with the passed in html.
        // description:
        //		html will be cloned if the NodeList has more than one
        //		element. Only DOM nodes are cloned, not any attached
        //		event handlers.
        // returns:
        //		the nodes in the current NodeList will be returned,
        //		not the nodes from html argument.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		<div class="blue">Blue One</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		query(".red").wrapInner('<span class="special"></span>');
        //	| 	});
        //		Results in this DOM structure:
        //	|	<div class="container">
        // 	|		<div class="red"><span class="special">Red One</span></div>
        // 	|		<div class="blue">Blue One</div>
        // 	|		<div class="red"><span class="special">Red Two</span></div>
        // 	|		<div class="blue">Blue Two</div>
        //	|	</div>
        if (this[0]) {
          html = makeWrapNode(html, this[0]);
          for (var i = 0; i < this.length; i++) {
            //Always clone because if html is used to hold one of
            //the "this" nodes, then on the clone of html it will contain
            //that "this" node, and that would be bad.
            var clone = this._cloneNode(html);
            //Need to convert the childNodes to an array since wrapAll modifies the
            //DOM and can change the live childNodes NodeList.
            this._wrap(lang._toArray(this[i].childNodes), null, this._NodeListCtor).wrapAll(clone);
          }
        }
        return this;  // dojo/NodeList
      },
      replaceWith: function (content) {
        // summary:
        //		Replaces each node in ths NodeList with the content passed to replaceWith.
        // description:
        //		The content will be cloned if the length of NodeList
        //		is greater than 1. Only the DOM nodes are cloned, not
        //		any attached event handlers.
        // returns:
        //		The nodes currently in this NodeList will be returned, not the replacing content.
        //		Note that the returned nodes have been removed from the DOM.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		<div class="blue">Blue One</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		query(".red").replaceWith('<div class="green">Green</div>');
        //	| 	});
        //		Results in this DOM structure:
        //	|	<div class="container">
        // 	|		<div class="green">Green</div>
        // 	|		<div class="blue">Blue One</div>
        // 	|		<div class="green">Green</div>
        // 	|		<div class="blue">Blue Two</div>
        //	|	</div>
        content = this._normalize(content, this[0]);
        for (var i = 0, node; node = this[i]; i++) {
          this._place(content, node, 'before', i > 0);
          node.parentNode.removeChild(node);
        }
        return this;  // dojo/NodeList
      },
      replaceAll: function (query) {
        // summary:
        //		replaces nodes matched by the query passed to replaceAll with the nodes
        //		in this NodeList.
        // description:
        //		The nodes in this NodeList will be cloned if the query
        //		matches more than one element. Only the DOM nodes are cloned, not
        //		any attached event handlers.
        // returns:
        //		The nodes currently in this NodeList will be returned, not the matched nodes
        //		from the query. The nodes currently in this NodeLIst could have
        //		been cloned, so the returned NodeList will include the cloned nodes.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="spacer">___</div>
        // 	|		<div class="red">Red One</div>
        // 	|		<div class="spacer">___</div>
        // 	|		<div class="blue">Blue One</div>
        // 	|		<div class="spacer">___</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="spacer">___</div>
        // 	|		<div class="blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		query(".red").replaceAll(".blue");
        //	| 	});
        //		Results in this DOM structure:
        //	|	<div class="container">
        // 	|		<div class="spacer">___</div>
        // 	|		<div class="spacer">___</div>
        // 	|		<div class="red">Red One</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="spacer">___</div>
        // 	|		<div class="spacer">___</div>
        // 	|		<div class="red">Red One</div>
        // 	|		<div class="red">Red Two</div>
        //	|	</div>
        var nl = dquery(query);
        var content = this._normalize(this, this[0]);
        for (var i = 0, node; node = nl[i]; i++) {
          this._place(content, node, 'before', i > 0);
          node.parentNode.removeChild(node);
        }
        return this;  // dojo/NodeList
      },
      clone: function () {
        // summary:
        //		Clones all the nodes in this NodeList and returns them as a new NodeList.
        // description:
        //		Only the DOM nodes are cloned, not any attached event handlers.
        // returns:
        //		a cloned set of the original nodes.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		<div class="blue">Blue One</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-manipulate"
        //	|	], function(query){
        //	|		query(".red").clone().appendTo(".container");
        //	| 	});
        //		Results in this DOM structure:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		<div class="blue">Blue One</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue">Blue Two</div>
        // 	|		<div class="red">Red One</div>
        // 	|		<div class="red">Red Two</div>
        //	|	</div>
        //TODO: need option to clone events?
        var ary = [];
        for (var i = 0; i < this.length; i++) {
          ary.push(this._cloneNode(this[i]));
        }
        return this._wrap(ary, this, this._NodeListCtor);  // dojo/NodeList
      }
    });
    //set up html method if one does not exist
    if (!NodeList.prototype.html) {
      NodeList.prototype.html = NodeList.prototype.innerHTML;
    }
    return NodeList;
  }(dojo_query, dojo__base_lang, dojo__base_array, dojo_dom_construct, dojo_dom_attr);
  bootstrap_Modal = function (support, declare, query, lang, win, on, domClass, domConstruct, domAttr, domStyle, request) {
    var toggleSelector = '[data-toggle=modal]';
    var dismissSelector = '[data-dismiss=modal]';
    var Modal = declare([], {
      defaultOptions: {
        backdrop: true,
        keyboard: true,
        show: true
      },
      constructor: function (element, options) {
        this.options = lang.mixin(lang.clone(this.defaultOptions), options || {});
        var elm = this.domNode = element;
        on(this.domNode, on.selector(dismissSelector, 'click'), lang.hitch(this, this.hide));
        if (this.options.remote) {
          request(this.options.remote).then(function (html) {
            query('.modal-body', elm).html(html);
          });
        }
      },
      toggle: function () {
        return this[!this.isShown ? 'show' : 'hide']();
      },
      show: function (e) {
        var _this = this;
        on.emit(this.domNode, 'show.bs.modal', {
          bubbles: false,
          cancelable: false
        });
        if (this.isShown && e.defaultPrevented) {
          return;
        }
        this.isShown = true;
        _escape.call(this);
        _backdrop.call(this, function () {
          var transition = support.trans && domClass.contains(_this.domNode, 'fade');
          if (!query(_this.domNode).parent().length) {
            domConstruct.place(_this.domNode, win.body());
          }
          domStyle.set(_this.domNode, 'display', 'block');
          if (transition) {
            _this._offsetWidth = _this.domNode.offsetWidth;
          }
          domClass.add(_this.domNode, 'in');
          domAttr.set(_this.domNode, 'aria-hidden', false);
          _enforceFocus.call(_this);
          if (transition) {
            on.once(_this.domNode, support.trans.end, function () {
              _this.domNode.focus();
              on.emit(_this.domNode, 'shown.bs.modal', {
                bubbles: false,
                cancelable: false
              });
            });
          } else {
            _this.domNode.focus();
            on.emit(_this.domNode, 'shown.bs.modal', {
              bubbles: false,
              cancelable: false
            });
          }
        });
      },
      hide: function (e) {
        var _this = this;
        on.emit(this.domNode, 'hide.bs.modal', {
          bubbles: false,
          cancelable: false
        });
        if (e) {
          e.preventDefault();
        }
        if (!this.isShown && e.defaultPrevented) {
          return;
        }
        this.isShown = false;
        _escape.call(this);
        if (this.focusInEvent) {
          this.focusInEvent.remove();
        }
        domClass.remove(this.domNode, 'in');
        domAttr.set(_this.domNode, 'aria-hidden', true);
        if (support.trans && domClass.contains(this.domNode, 'fade')) {
          _hideWithTransition.call(this);
        } else {
          _hideModal.call(this);
        }
      }
    });
    function _getTargetSelector(node) {
      var selector = domAttr.get(node, 'data-target');
      if (!selector) {
        selector = support.hrefValue(node);
      }
      return !selector ? '' : selector;
    }
    function _hideWithTransition() {
      var _this = this;
      var timeout = setTimeout(function () {
        if (_this.hideEvent) {
          _this.hideEvent.remove();
        }
        _hideModal.call(_this);
      }, 500);
      _this.hideEvent = support.trans ? on.once(_this.domNode, support.trans.end, function () {
        clearTimeout(timeout);
        _hideModal.call(_this);
      }) : null;
    }
    function _hideModal() {
      var _this = this;
      domStyle.set(_this.domNode, 'display', 'none');
      on.emit(_this.domNode, 'hidden.bs.modal', {
        bubbles: false,
        cancelable: false
      });
      _backdrop.call(_this);
    }
    function _backdrop(callback) {
      var _this = this;
      var animate = domClass.contains(_this.domNode, 'fade') ? 'fade' : '';
      if (_this.isShown && _this.options.backdrop) {
        var doAnimate = support.trans && animate;
        _this.backdropNode = domConstruct.place('<div class="modal-backdrop ' + animate + '" />', win.body());
        on(_this.backdropNode, 'click', _this.options.backdrop !== 'static' ? lang.hitch(_this.domNode, 'focus') : lang.hitch(_this, 'hide'));
        if (doAnimate) {
          _this.backdropNode.offsetWidth;
        }
        domClass.add(_this.backdropNode, 'in');
        if (doAnimate) {
          on.once(_this.backdropNode, support.trans.end, callback);
        } else {
          callback();
        }
      } else if (!_this.isShown && _this.backdropNode) {
        domClass.remove(_this.backdropNode, 'in');
        if (support.trans && domClass.contains(_this.domNode, 'fade')) {
          on.once(_this.backdropNode, support.trans.end, lang.hitch(_this, _removeBackdrop));
        } else {
          _removeBackdrop.call(_this);
        }
      } else if (callback) {
        callback();
      }
    }
    function _removeBackdrop() {
      var _this = this;
      domConstruct.destroy(_this.backdropNode);
      _this.backdropNode = null;
    }
    function _escape() {
      var _this = this;
      if (_this.isShown && _this.options.keyboard) {
        _this.keyupEvent = on(win.body(), 'keyup', function (e) {
          if (e.which === 27) {
            _this.hide();
          }
        });
      } else if (!_this.isShown) {
        if (_this.keyupEvent) {
          _this.keyupEvent.remove();
        }
      }
    }
    function _enforceFocus() {
      var _this = this;
      // PATCHED: replaced document with win.body() to avoid errors submitted dojo bug https://bugs.dojotoolkit.org/ticket/18457
      _this.focusInEvent = on(win.body(), on.selector('.modal', 'focusin'), function (e) {
        if (_this.domNode !== this && !query(this, _this.domNode).length) {
          _this.domNode.focus();
        }
      });
    }
    lang.extend(query.NodeList, {
      modal: function (option) {
        return this.forEach(function (node) {
          var options = lang.mixin({}, lang.mixin(support.getData(node), lang.isObject(option) && option));
          var data = support.getData(node, 'modal');
          if (!data) {
            support.setData(node, 'modal', data = new Modal(node, options));
          }
          if (lang.isString(option)) {
            data[option].call(data);
          } else if (data && data.options.show) {
            data.show();
          }
        });
      }
    });
    //PATCHED don't add eventlisteners to modal elements on page load. if the page already uses bootstrap, this will cause conflicts.
    //    on(win.body(), on.selector(toggleSelector, 'click'), function (e) {
    //        var target = query(_getTargetSelector(this));
    //        if (target[0] !== undefined) {
    //            var href = domAttr.get(this, "href");
    //            var option = support.getData(target, 'modal') ? 'toggle' : lang.mixin({ remote: !/#/.test(href) && href}, lang.mixin(support.getData(target), support.getData(this)));
    //            if (option === 'toggle') {
    //              lang.mixin(support.getData(target, 'modal').options, support.getData(this));
    //            }
    //            target.modal(option);
    //            on.once(target[0], 'hide', function () {
    //                target[0].focus();
    //            });
    //        }
    //        if (e) {
    //            e.preventDefault();
    //        }
    //    });
    return Modal;
  }(bootstrap_Support, dojo__base_declare, dojo_query, dojo__base_lang, dojo__base_window, dojo_on, dojo_dom_class, dojo_dom_construct, dojo_dom_attr, dojo_dom_style, dojo_request);
  synchronite_integration_main = function (dom, lang, baseEvent, Deferred, on, aspect, visitorInfo, io, ajaxStatus, trackingLoader, synchState, session, dialogService, sessionLink, microDom, Modal, getLocale) {
    var win = window;
    var synchroniteAPI = 'synchronite API';
    var config = win.synchroniteConfig;
    var integrationConfig = config.integration;
    var DIALOG_REQUEST_SUPPORT = 'dialog-request-support';
    var after = aspect.after;
    // These variables hold global references to modules that are lazy loaded
    // on-demand
    var liveButton, supportDialog, serviceDialog, Chat;
    // emits a "statusChange" event and offers a method checkStatus to check the status/
    // availability of support agents.
    var statusSignaler;
    ////////////////////////////////////////////////////////////
    // PRIVATE VARIABLES WILL BE OBFUSCATED
    ////////////////////////////////////////////////////////////
    var tenantId = config.tenantId;
    var STEP_SUPPORT_UNAVAILABLE = -1,
      /*STEP0 = 0, */
      STEP1 = 1, STEP2 = 2, STEP3 = 3,
      /*, STEP_SHOW_SERVICEID = 4,*/
      cometConnect,
      //comet module
      termsOfService = integrationConfig && integrationConfig.termsOfService, skipEnterDetailsWhenVisitorIsKnown = config.skipEnterDetailsWhenVisitorIsKnown;
    ////////////////////////////////////////////////////////////
    // PRIVATE FUNCTIONS WILL BE OBFUSCATED
    ////////////////////////////////////////////////////////////
    var supportStatusChange = function (availObj) {
      if (liveButton) {
        // synchronite liveButton is loaded
        liveButton.toggleVisibility(availObj.availability);
      } else if (availObj.availability && integrationConfig && integrationConfig.enableLiveButton) {
        // agents are available and the synchronite liveButton should be loaded and visible
        initializeLiveSupportButton(availObj.availability);
      } else {
        console.info('No support agents available and no live support button has been created yet.');
      }
      // Signal to API
      main.emit('statusChange', availObj);
    };
    var initializeSupportDialog = function (showDialog, callback) {
      (function (_supportDialog) {
        // set global reference used by other modules
        main.supportDialog = _supportDialog;
        supportDialog = _supportDialog;
        // Create support dialog
        _supportDialog.create(showDialog, main, visitorInfo).then(callback);
      }(synchronite_integration_dialog_support));
    };
    var initializeLiveSupportButton = function (status) {
      (function (integrationButton) {
        // Set global references used by other modules
        main.liveButton = integrationButton;
        liveButton = integrationButton;
        // Create and init button
        integrationButton.create(lang.hitch(main, main.onLiveButtonClick));
        integrationButton.toggleVisibility(status);
      }(synchronite_integration_button));
    };
    var initializeAjaxModule = function () {
      //set global module reference
      statusSignaler = ajaxStatus;
      if (config.checkAgentAvailability) {
        ajaxStatus.checkAgentStatus(tenantId);
      }
      ajaxStatus.on('statusChange', supportStatusChange);  // event fires when support status was checked.
    };
    var prepareDialog = function (isSupportAvailable) {
      var dialogDomNode = dom.byId(DIALOG_REQUEST_SUPPORT);
      var doWhenInitialized = function (dialog) {
        dialog = dialog || supportDialog;
        // Use existing username or if null try to extract username from portal site
        var visitorFullName = visitorInfo.fullname(true);
        if (isSupportAvailable) {
          // FIXED: Only send support request immediately, when terms of service do not
          //        need to be accepted.
          var termsMayBeSkipped = termsOfService !== 'accept' || visitorInfo.termsAccepted();
          if (visitorFullName && skipEnterDetailsWhenVisitorIsKnown && termsMayBeSkipped) {
            dialog.prepare(STEP2);
            cometConnect.publishSupportRequest();
          } else {
            dialog.prepare(STEP1);
          }
        } else {
          // Display support unavailable dialog
          dialog.prepare(STEP_SUPPORT_UNAVAILABLE);
          console.debug('gui Display the no support available dialog.');
        }
        dialog.show();
      };
      // Create support dialog
      if (dialogDomNode) {
        // synchronous call
        doWhenInitialized(supportDialog);
      } else {
        //asynchronous call
        initializeSupportDialog(false, doWhenInitialized);
      }
    };
    var insertNode = function (tagName, props) {
        var node = document.createElement(tagName);
        lang.mixin(node, props);
        document.getElementsByTagName('head')[0].appendChild(node);
      }, insertCss = function (url) {
        insertNode('link', {
          href: url,
          type: 'text/css',
          rel: 'stylesheet'
        });
      }, loadCss = function (serverUrl) {
        var tenantSpecificCss = serverUrl + '/css/integration.css';
        if (config.isDebug) {
          tenantSpecificCss = tenantSpecificCss.replace('.css', '.less');
          window.less = {
            env: 'development',
            errorReporting: 'console',
            logLevel: 1
          };
          insertNode('link', {
            href: tenantSpecificCss,
            type: 'text/css',
            rel: 'stylesheet/less'
          });
          if (!String.prototype.trim) {
            // load shim to support old browsers
            insertNode('script', {
              src: serverUrl + '/js/libs/es5-shim.js',
              type: 'text/javascript'
            });
          }
          insertNode('script', {
            src: serverUrl + '/js/less/less.js',
            type: 'text/javascript'
          });
        } else {
          insertCss(tenantSpecificCss);
        }
      };
    //##########################
    //     cometd methods
    //##########################
    var defaultSessionOfferedSignal, defaultSessionStartSignal;
    function _enodeUserParam(param) {
      if (param) {
        return encodeURIComponent(param);
      } else {
        return null;
      }
    }
    function defaultCobrowseStart(params) {
      if (main.serviceDialog && main.serviceDialog.hide) {
        main.serviceDialog.hide();
      }
      var cobrowseEngine = config.cobrowseEngine || 'proxybased';
      var ticket = params.ticket;
      var url = params.url;
      url = url.replace(/&/g, '%26');
      //char escape
      // function(profile, ticket, targetURL, username, chat)
      var sessionUrl = params.sessionUrl || sessionLink.getLink('engage', ticket, url, _enodeUserParam(visitorInfo.fullname(true)), config.chatEnabled, getLocale());
      visitorInfo.connectedAgentAlias = null;
      //clear the support username
      visitorInfo.clearServiceID();
      //clear the support id
      if (cobrowseEngine === 'proxyless') {
        var sid = params.sid;
        io.cometCleanUp();
        var cacheBust = config && config.cacheBust || 1;
        var scriptUrl = 'https://' + config.tenantHost + '/js/synchronite/proxyless/run.js?cacheBust=' + encodeURIComponent(cacheBust);
        window.proxylessConfig = {
          ticket: ticket,
          master: true,
          comet: io._getCometd(),
          sid: sid
        };
        var uniqueId = 'cobrowse-proxyless-run' + ~~(Math.random() * 10000);
        microDom.loadScript(document, 'script', scriptUrl, uniqueId, function (event) {
          console.log('STARTING PROXYLESS SOLUTION - PROXYLESS RUN SCRIPT LOADED');
        });
      } else {
        // FIXED: Open Session in topmost window, not in current window
        window.setTimeout(function () {
          top.location = sessionUrl;
        }, 25);
      }
    }
    var initializeCometModule = function () {
      var promise = new Deferred();
      var isDisconnected = !cometConnect || cometConnect.isDisconnected();
      var isHandshaking = cometConnect && cometConnect.getStatus() == 'handshaking';
      console.info('initializeCometModule: isDisconnected=' + isDisconnected + ', isHandshaking=' + isHandshaking);
      if (isDisconnected) {
        //set global module reference
        main.io = io;
        cometConnect = io;
        statusSignaler = io;
        cometConnect.on('statusChange', supportStatusChange);
        cometConnect.initializeComet(main, visitorInfo).then(function () {
          promise.resolve(cometConnect);
        }, function (err) {
          console.error('Error resolving promise');
          console.error(err);
        });
        var defaultChatOffered = function (params) {
          console.info('Chat offered.');
          cometConnect.prepareTicket(params.type);
        };
        var defaultCobrowseOffered = function (params) {
          // If the supportDialog is shown and the visitor
          //  - is not required to confirm the support offer
          //  - and the vistor's name is known or it is not required
          // then start the session instantly.
          // else show support dialog
          // hide service number dialog if shown
          if (main.serviceDialog && main.serviceDialog.hide) {
            main.serviceDialog.hide();
          }
          console.log('defaultCobrowseOffered ' + JSON.stringify(params));
          if (config.skipVisitorConfirmation && (visitorInfo.fullname(true) || !config.visitorNameRequired)) {
            // only skip step when user initiated request
            cometConnect.prepareTicket({ type: 'cobrowse' });
          } else {
            initializeSupportDialog(true, function () {
              // initialize support dialog, then show step 3
              supportDialog.prepare(STEP3);
            });
          }
        };
        defaultSessionOfferedSignal = main.on('sessionOffered', function (params) {
          // When an agent offers proactive support we need to make sure, that
          // the support dialog is shown.
          var supportType = params.type;
          if (supportType == 'chat') {
            defaultChatOffered(params);
          } else {
            defaultCobrowseOffered(params);
          }
        });
        var defaultChatStart = function (params) {
          var chatParams = {};
          chatParams.chatId = params.ticket;
          Chat.start(chatParams);
          console.info('Chat session started.');
        };
        defaultSessionStartSignal = main.on(session.START, function (params) {
          // When an agent offers proactive support we need to make sure, that
          // the support dialog is shown.
          visitorInfo.persist();
          var supportType = params.type;
          if (supportType == 'chat') {
            defaultChatStart(params);
          } else {
            defaultCobrowseStart(params);
          }
        });
      } else {
        if (isHandshaking) {
          // wait for handshake completion
          cometConnect.onSuccessfulHandshake.push(promise);
        } else {
          promise.resolve(cometConnect);
        }
      }
      return promise;
    };
    // show dialog only after the corect text has been prepared
    //##########################
    //    support methods
    //##########################
    var _setupServiceKey = function (keyCode, meta, duration) {
      var pressTime;
      var keydown = function (event) {
        if (!meta || event[meta]) {
          if (event.keyCode != keyCode) {
            //"s"
            return;
          }
          var now = new Date().getTime();
          if (duration === 0 || pressTime) {
            //console.debug("Pressing key for : " + (now-pressTime));
            if (duration === 0 || now - pressTime > duration) {
              if (!(main.serviceDialog && main.serviceDialog.isShown())) {
                pressTime = 0;
                var action = config.quickstartAction;
                if (action == 'receive') {
                  main.enterServiceId();
                } else {
                  // "connect"
                  main.showServiceId();
                }
              }
            }
          } else {
            pressTime = now;
          }
        }
      };
      var keyup = function (event) {
        if (event.keyCode == keyCode) {
          //"s"
          //console.debug("Releasing key for : " +event.which);
          pressTime = 0;
        }
      };
      on(document, 'keydown', keydown);
      on(document, 'keyup', keyup);
    };
    var preconfiguredKeys = {
      s: {
        key: 'S',
        duration: 3000
      },
      n: {
        key: 'N',
        duration: 3000
      },
      h: {
        key: 'H',
        duration: 3000
      },
      v: {
        key: 'V',
        duration: 3000
      },
      ctrl: {
        keyCode: 13,
        duration: 0,
        meta: 'ctrlKey'
      }
    };
    var triggerServiceKey = integrationConfig && integrationConfig.serviceKey;
    if (triggerServiceKey) {
      triggerServiceKey = preconfiguredKeys[triggerServiceKey];
      if (triggerServiceKey) {
        //triggerServiceKey = json.parse(triggerServiceKey);
        var keyCode = triggerServiceKey.keyCode || triggerServiceKey.key.charCodeAt(0);
        _setupServiceKey(keyCode, triggerServiceKey.meta, triggerServiceKey.duration);
      }
    }
    /////////////////////////////////////////////////////////
    // PUBLIC FUNCTIONS WILL NOT BE OBFUSCATED
    ////////////////////////////////////////////////////////
    var eventAPI = {
      sessionOffered: function () {
      },
      sessionRequested: function () {
      },
      sessionStart: function () {
      },
      sessionEnd: function () {
      },
      liveSupportButtonClicked: function () {
      }
    };
    var _startSupportDialog = function () {
      if (!config.customSupportDialog) {
        // Make sure, support is available
        if (config.realtimeTracking) {
          // Assume support agents are always available when support
          // button is shown in comet mode.
          prepareDialog(true);  //prepareDialog(isSupportAvailable)
        } else {
          // otherwise check agent availability first
          var availabilityCheck = ajaxStatus.checkAgentStatus(tenantId);
          availabilityCheck.then(lang.hitch(function (data) {
            // prepare dialog depending on support agents' availability
            prepareDialog(data.result);
          }));
        }
      }
    };
    var safeIsFunction = function (object) {
      // summary:
      //		Return true if it is a Function
      //		Use this instead of (typeof xy == "function"), to
      //		avoid IE cross browser bug.
      // it: anything
      //		Item to test.
      return !!(object && object.constructor && object.call && object.apply);
    };
    var triggerSupportRequest = function (paramsOrCallback, callback) {
      //API
      var params;
      var serviceId;
      if (arguments.length === 0) {
        throw {
          name: synchroniteAPI,
          message: 'At least one argument expected.'
        };
      }
      // Beware of IE cross window type of bug that strikes when
      // calling this function from a popup.
      // http://www.kilometer0.com/blog/code/internet-explorer-ie-cross-window-javascript-object-typeof-bug/
      if (arguments.length === 1) {
        if (safeIsFunction(paramsOrCallback)) {
          callback = paramsOrCallback;
        } else {
          throw {
            name: synchroniteAPI,
            message: 'When using one parameter it should be a function.'
          };
        }
      } else if (arguments.length >= 2) {
        params = paramsOrCallback;
        if (!safeIsFunction(callback)) {
          throw {
            name: synchroniteAPI,
            message: 'When using two parameters, the second should be a function.'
          };
        }
      }
      // check if parameters are correct
      if (typeof params === 'string') {
        visitorInfo.setFullname(params);
      } else if (params) {
        serviceId = params.serviceId || params.agentServiceId || params.sI || params.id;
        if (params.fullname) {
          visitorInfo.setFullname(params.fullname);
        }
      }
      initializeCometModule().then(function (cometConnect) {
        console.log('integration/main - triggerSupportRequest');
        // remove default event listeners
        main.removeDefaultFlow();
        if (!config.customFlow) {
          on.once(main, session.OFFERED, function (params) {
            console.log('sessionOffered ' + params);
            cometConnect.prepareTicket({ type: 'cobrowse' });  // Send local state to server
          });
          on.once(main, session.REJECTED, function (params) {
            console.log('sessionRejected' + params);
            callback(null);  // error situation
          });
          on.once(main, session.START, function (params) {
            callback(params);  // params.sessionUrl contains start url
          });
        }
        if (serviceId) {
          serviceId = ('' + serviceId).replace(/\s/gi, '');
          // convert to string and remove whitespace
          cometConnect.publishSupportRequest({
            sI: serviceId  //The serviceId of the agent that should offer support
          });
        } else {
          cometConnect.publishSupportRequest();
        }
      }, function (err) {
        console.error('triggerSupportRequest: Error resolving promise');
        console.error(err);
      });
    };
    var main = {
      on: function (type, listener) {
        return on.parse(this, type, listener, function (target, type) {
          return after(target, 'on' + type, listener, true);
        });
      },
      emit: function (type, event) {
        console.debug('synchronite.emit(' + type + ', ' + JSON.stringify(event));
        var args = [this];
        args.push.apply(args, arguments);
        return on.emit.apply(on, args);
      },
      once: function (type, listener) {
        // summary:
        //		This function acts the same as on(), but will only call the listener once. The
        //		listener will be called for the first
        //		event that takes place and then listener will automatically be removed.
        var signal = this.on(type, function () {
          // remove this listener
          signal.remove();
          // proceed to call the listener
          return listener.apply(this, arguments);
        });
        return signal;
      },
      io: null,
      liveButton: null,
      supportDialog: null,
      serviceDialog: null,
      visitorInfo: visitorInfo,
      initialize: function () {
        console.debug('Initializing the synchronite integration...');
        // Initialize tracking API
        trackingLoader.setupTracker(window, config.trackingAPI, this);
        console.debug('Checking if there is any state from the last session...');
        try {
          // Read the stored state from the stored windowName or if that is not set
          // from window.name
          var state = synchState.loadStateFromWindow(window, config.windowName);
          if (state) {
            console.info('Restoring state - Start.');
            // FIXME: delay tracking by 2 seconds so that sessionEnd event is tracked
            //        This is not an optimal solution...
            // IS ALREADY TRIGGERED DURING THE SESSION in Core-Comet.js
            //var triggerDelayedSessionEnd = function () {
            //  var info = visitorInfo.event();
            //  info.ticket = state.ticket;
            //
            //  var durationMillis = state.duration;
            //  if (durationMillis) {
            //    info.duration = parseInt(durationMillis / 1000, 10);
            //  }
            //
            //  setTimeout(lang.hitch(main, main.emit, "sessionEnd", info), 2000);
            //};
            //
            //if (document.readyState && document.readyState == "complete") {
            //  // trigger now
            //  triggerDelayedSessionEnd();
            //} else {
            //  // trigger after onload to ensure listeners are registered
            //  on(window, "load", triggerDelayedSessionEnd);
            //}
            //                            if ((typeof window.localStorage != "undefined") && window.localStorage) { //localStorage might be undefined or null
            //                                // Check if we have stored the session history
            //                                var tenantId = synchroniteConfig.tenantId;
            //                                var ticketId = state.ticket;
            //                                var key = tenantId + ticketId + "History";
            //
            //                                var storedHistory = localStorage.getItem(key);
            //                                if (storedHistory) {
            //                                    // session history is present so use that to override the window history
            //                                    require("synchronite/integration/history", function(historyOverride) {
            //                                        historyOverride.start(historyOverride);
            //                                    });
            //                                    localStorage.removeItem(key);
            //                                }
            //                            }
            synchState.applyState(state.state);
            console.info('Restoring state - Done.');
          } else {
            console.info('Restoring state - No State found.');
          }
        } catch (e) {
          console.warn('Error restoring session state.', e);
        }
        var protocol = 'https:';
        if (!config.tenantHost) {
          if (config.tenantId && config.proxyHost) {
            config.tenantHost = config.tenantId + '.' + config.proxyHost;
          }
        }
        var serverUrl = protocol + '//' + config.tenantHost;
        config.serverUrl = serverUrl;
        console.debug('loading Loading all gui elements done.');
        // check if username can be extracted from portal.
        // do not remove, this initializes visitorInfo.
        visitorInfo.fullname();
        // Lazy load the javascript modules only when needed
        // this saves bandwidth and speeds up performance
        if (config.realtimeTracking) {
          console.debug('Loading comet modules.');
          // delay this so it does not defer the onload event
          initializeCometModule();  //setTimeout(lang.hitch(this, initializeCometModule), 10000); // This saves 30 KB
        } else {
          console.debug('Loading ajax modules.');
          initializeAjaxModule();  // This saves 1 KB
        }
        // The disableCss option cannot be set via the configuration, but must be set via the onSynchroniteLoad
        // function
        if (!config.hasCustomUI) {
          loadCss(serverUrl);
        }
        if (config.customFlow) {
          // remove default event listeners
          this.removeDefaultFlow();
        }  // Legacy integration based on operator alert.
           //if (typeof lpMTagConfig !== "undefined") {
           //    // Load LivePerson Plugin
           //    require(["synchronite/integration/plugins/liveperson"], function (liveperson) {
           //        console.info("LIVEPERSON PLUGIN LOADED " + liveperson);
           //    });
           //}
      },
      iSD: initializeSupportDialog,
      iCM: initializeCometModule,
      createServiceId: lang.hitch(visitorInfo, visitorInfo.createServiceId),
      //API
      getServiceId: lang.hitch(visitorInfo, visitorInfo.createServiceId),
      //API
      clearServiceId: lang.hitch(visitorInfo, visitorInfo.clearServiceID),
      setServiceId: function (serviceIdOrCallback, callback) {
        initializeCometModule().then(function () {
          visitorInfo.createServiceId(serviceIdOrCallback, callback);
        }, function (err) {
          console.error('initializeCometModule: Error resolving promise');
          console.error(err);
        });
      },
      //API
      setFullname: lang.hitch(visitorInfo, visitorInfo.setFullname),
      //API
      setCustomVar: function (name, value) {
        //API
        if (visitorInfo) {
          return visitorInfo.setCustomVar(name, value);
        }
        return false;
      },
      showServiceId: function () {
        // Show service dialog, to increase the "felt" performance
        serviceDialog = dialogService.openShowDialog();
        main.serviceDialog = dialogService;
        // Asynchronously generate serviceId and display in service
        // dialog, once available
        var createServiceIdCallback = function (serviceId) {
          dialogService.showServiceNumber(serviceId);
          initializeCometModule();
          initializeSupportDialog(false);
        };
        // Asynchronous call to server in order to generate serviceId
        visitorInfo.createServiceId(createServiceIdCallback);
      },
      verifyServiceId: function () {
      },
      defaultCobrowseStart: defaultCobrowseStart,
      // Method to start cobrowse session regardless of underlying cobrowse engine
      enterServiceId: function (serviceNumberCallback) {
        //API
        var enterServiceIdCallback;
        if (!serviceNumberCallback) {
          enterServiceIdCallback = function (serviceId) {
            initializeCometModule().then(function (cometConnect) {
              cometConnect.publishSupportRequest({
                sI: serviceId  //The serviceId of the agent that should offer support
              });
            });
          };
        }
        // Show service dialog, to increase the perceived performance
        serviceDialog = dialogService.openEnterDialog(enterServiceIdCallback);
        main.serviceDialog = dialogService;
      },
      removeDefaultFlow: function () {
        if (defaultSessionOfferedSignal && defaultSessionOfferedSignal.remove) {
          // unregister default sessionOffered listener, because the visitor seems to be
          // using the API.
          defaultSessionOfferedSignal.remove();
        }
        if (defaultSessionStartSignal && defaultSessionStartSignal.remove) {
          defaultSessionStartSignal.remove();
        }
      },
      triggerSupportRequest: triggerSupportRequest,
      requestSupport: triggerSupportRequest,
      checkAgentStatus: function () {
        if (statusSignaler) {
          return statusSignaler.checkAgentStatus();
        } else {
          throw {
            name: synchroniteAPI,
            message: 'synchronite API not fully initialized yet.'
          };
        }
      },
      // will be set during runtime
      /* should be called declineSupportOffer */
      cancelSupportOffer: function (params) {
        // params.serviceId
        // params.visitorAlias
        initializeCometModule().then(function (cometConnect) {
          cometConnect.publishDeclineSupport(params);
        });
      },
      acceptSupportOffer: function (params, removeDefaultFlow) {
        // params:
        // serviceId
        // channelSegment / agentAlias
        params = params || {};
        var that = this;
        initializeCometModule().then(function (cometConnect) {
          cometConnect.prepareTicket(params);
          if (removeDefaultFlow) {
            that.removeDefaultFlow();
          }
        });
      },
      startSupportDialog: _startSupportDialog,
      onLiveButtonClick: function (event) {
        baseEvent.stop(event);
        main.emit('liveSupportButtonClicked', visitorInfo.event());
        //                if (buttonConfig && buttonConfig.requests === "chat") {
        //                    _startChat();
        //                } else {
        _startSupportDialog();  //                }
      },
      getComet: function () {
        return io._getCometd();
      },
      isValidSN: function (host, tenantId, serviceId, callback) {
        host = host || config.serverUrl;
        tenantId = tenantId || config.tenantId;
        ajaxStatus.checkSNisValid(host, tenantId, serviceId).then(callback);
      },
      cometCleanUp: io.cometCleanUp
    };
    lang.mixin(main, eventAPI);
    cometConnect = main.io;
    return main;  // return object with public methods
  }(dojo_dom, dojo__base_lang, dojo__base_event, dojo_Deferred, dojo_on, dojo_aspect, synchronite_integration_visitor_info, synchronite_integration_io, synchronite_integration_ajax_status, synchronite_integration_tracking_loader, synchronite__base_state, synchronite_integration_session, synchronite_integration_dialog_service, synchronite__base_session_link, synchronite_micro_dom, bootstrap_Modal, synchronite__base_locale);
  synchronite_integration_button = function (lang, dojoDom, domStyle, domConstruct, domClass, baseWindow, dojoHas, dojoOn) {
    var config = synchroniteConfig, SYNCHRONITE_BUTTON_ID = 'synchronite-button',
      // Default ID of the button DOMNode
      buttonNode = null, buttonClickHandlerRef = null;
    // A reference to the dojo/on click event listener
    var MARKUP_FILTER = /(<|>)/gi;
    var isUnsupportedBrowser = function () {
      return dojoHas('ie') <= 6;
    };
    //////////////////////////////
    // PUBLIC FUNCTIONS
    /////////////////////////////
    var buttonConfig = config.button;
    var button = {
      create: function (buttonClickHandler, paramConfig) {
        //summary: Adds the live support button
        // buttonConfig = paramConfig || buttonConfig;
        // FIXED: Correctly mixin properties
        if (paramConfig) {
          buttonConfig = lang.mixin(buttonConfig, paramConfig);
        }
        buttonNode = dojoDom.byId(SYNCHRONITE_BUTTON_ID);
        if (!buttonNode) {
          // Config Parameter
          // buttonClass
          // buttonPosition
          // buttonLabel
          // buttonBackgroundColor
          // buttonFontColor
          // buttonBorderColor
          // buttonFont
          var buttonClasses = 'synchronite-' + buttonConfig.position;
          if (buttonConfig.cssClass) {
            buttonClasses += ' ' + buttonConfig.cssClass;
          }
          var buttonStyle = {
            backgroundColor: buttonConfig.backgroundColor,
            color: buttonConfig.fontColor,
            borderColor: buttonConfig.borderColor,
            fontFamily: buttonConfig.font,
            visibility: 'hidden'
          };
          var buttonLabel = buttonConfig.label;
          var safeButtonLabel = buttonLabel.replace(MARKUP_FILTER, '');
          buttonNode = domConstruct.create('div', {
            id: SYNCHRONITE_BUTTON_ID,
            innerHTML: '<span>' + safeButtonLabel + '</span>',
            unselectable: 'on',
            style: buttonStyle,
            'class': buttonClasses
          }, baseWindow.body());
          // Calculate the transform margins before the button is rotated.
          if (/left|right/i.test(buttonConfig.position) && dojoHas('ie') <= 8) {
            var w = buttonNode.offsetWidth, h = buttonNode.offsetHeight;
            domClass.add(buttonNode, 'ie8');
            if (buttonConfig.position == 'left') {
              domStyle.set(buttonNode, { marginTop: -(h / 2) + 'px' });
            } else if (buttonConfig.position == 'right') {
              domStyle.set(buttonNode, {
                marginTop: -(h / 2) + 'px',
                marginRight: -w + h + 'px'
              });
            }
          }
          domStyle.set(buttonNode, {
            visibility: '',
            display: 'none'
          });
          console.debug('Added the default support button=' + buttonNode);
        }
        // Register event handler
        if (buttonClickHandlerRef) {
          buttonClickHandlerRef.remove();  //disconnect replacement
        }
        buttonClickHandlerRef = dojoOn(buttonNode, 'click', buttonClickHandler);
      },
      show: function () {
        if (isUnsupportedBrowser()) {
          return;
        }
        // do not show in IE<=6
        domStyle.set(buttonNode, { display: 'block' });
      },
      hide: function () {
        domStyle.set(buttonNode, { display: 'none' });
      },
      toggleVisibility: function (show) {
        if (isUnsupportedBrowser()) {
          return;
        }
        if (show) {
          this.show();
        } else {
          this.hide();
        }
      }
    };
    return button;
  }(dojo__base_lang, dojo_dom, dojo_dom_style, dojo_dom_construct, dojo_dom_class, dojo__base_window, dojo_has, dojo_on);
  dojo__base_Color = function (dojo, lang, ArrayUtil, config) {
    var Color = dojo.Color = function (color) {
      // summary:
      //		Takes a named string, hex string, array of rgb or rgba values,
      //		an object with r, g, b, and a properties, or another `Color` object
      //		and creates a new Color instance to work from.
      //
      // example:
      //		Work with a Color instance:
      //	|	require(["dojo/_base/color"], function(Color){
      //	|		var c = new Color();
      //	|		c.setColor([0,0,0]); // black
      //	|		var hex = c.toHex(); // #000000
      //	|	});
      //
      // example:
      //		Work with a node's color:
      //	| 
      //	|	require(["dojo/_base/color", "dojo/dom-style"], function(Color, domStyle){
      //	|		var color = domStyle("someNode", "backgroundColor");
      //	|		var n = new Color(color);
      //	|		// adjust the color some
      //	|		n.r *= .5;
      //	|		console.log(n.toString()); // rgb(128, 255, 255);
      //	|	});
      if (color) {
        this.setColor(color);
      }
    };
    // FIXME:
    // there's got to be a more space-efficient way to encode or discover
    // these!! Use hex?
    Color.named = {
      // summary:
      //		Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.
      'black': [
        0,
        0,
        0
      ],
      'silver': [
        192,
        192,
        192
      ],
      'gray': [
        128,
        128,
        128
      ],
      'white': [
        255,
        255,
        255
      ],
      'maroon': [
        128,
        0,
        0
      ],
      'red': [
        255,
        0,
        0
      ],
      'purple': [
        128,
        0,
        128
      ],
      'fuchsia': [
        255,
        0,
        255
      ],
      'green': [
        0,
        128,
        0
      ],
      'lime': [
        0,
        255,
        0
      ],
      'olive': [
        128,
        128,
        0
      ],
      'yellow': [
        255,
        255,
        0
      ],
      'navy': [
        0,
        0,
        128
      ],
      'blue': [
        0,
        0,
        255
      ],
      'teal': [
        0,
        128,
        128
      ],
      'aqua': [
        0,
        255,
        255
      ],
      'transparent': config.transparentColor || [
        0,
        0,
        0,
        0
      ]
    };
    lang.extend(Color, {
      r: 255,
      g: 255,
      b: 255,
      a: 1,
      _set: function (r, g, b, a) {
        var t = this;
        t.r = r;
        t.g = g;
        t.b = b;
        t.a = a;
      },
      setColor: function (color) {
        // summary:
        //		Takes a named string, hex string, array of rgb or rgba values,
        //		an object with r, g, b, and a properties, or another `Color` object
        //		and sets this color instance to that value.
        //
        // example:
        //	|	require(["dojo/_base/color"], function(Color){
        //	|		var c = new Color(); // no color
        //	|		c.setColor("#ededed"); // greyish
        //	|	});
        if (lang.isString(color)) {
          Color.fromString(color, this);
        } else if (lang.isArray(color)) {
          Color.fromArray(color, this);
        } else {
          this._set(color.r, color.g, color.b, color.a);
          if (!(color instanceof Color)) {
            this.sanitize();
          }
        }
        return this;  // Color
      },
      sanitize: function () {
        // summary:
        //		Ensures the object has correct attributes
        // description:
        //		the default implementation does nothing, include dojo.colors to
        //		augment it with real checks
        return this;  // Color
      },
      toRgb: function () {
        // summary:
        //		Returns 3 component array of rgb values
        // example:
        //	|	require(["dojo/_base/color"], function(Color){
        //	|		var c = new Color("#000000");
        //	|		console.log(c.toRgb()); // [0,0,0]
        //	|	});
        var t = this;
        return [
          t.r,
          t.g,
          t.b
        ];  // Array
      },
      toRgba: function () {
        // summary:
        //		Returns a 4 component array of rgba values from the color
        //		represented by this object.
        var t = this;
        return [
          t.r,
          t.g,
          t.b,
          t.a
        ];  // Array
      },
      toHex: function () {
        // summary:
        //		Returns a CSS color string in hexadecimal representation
        // example:
        //	|	require(["dojo/_base/color"], function(Color){
        //	|		console.log(new Color([0,0,0]).toHex()); // #000000
        //	|	});
        var arr = ArrayUtil.map([
          'r',
          'g',
          'b'
        ], function (x) {
          var s = this[x].toString(16);
          return s.length < 2 ? '0' + s : s;
        }, this);
        return '#' + arr.join('');  // String
      },
      toCss: function (includeAlpha) {
        // summary:
        //		Returns a css color string in rgb(a) representation
        // example:
        //	|	require(["dojo/_base/color"], function(Color){
        //	|		var c = new Color("#FFF").toCss();
        //	|		console.log(c); // rgb('255','255','255')
        //	|	});
        var t = this, rgb = t.r + ', ' + t.g + ', ' + t.b;
        return (includeAlpha ? 'rgba(' + rgb + ', ' + t.a : 'rgb(' + rgb) + ')';  // String
      },
      toString: function () {
        // summary:
        //		Returns a visual representation of the color
        return this.toCss(true);  // String
      }
    });
    Color.blendColors = dojo.blendColors = function (start, end, weight, obj) {
      // summary:
      //		Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
      //		can reuse a previously allocated Color object for the result
      var t = obj || new Color();
      ArrayUtil.forEach([
        'r',
        'g',
        'b',
        'a'
      ], function (x) {
        t[x] = start[x] + (end[x] - start[x]) * weight;
        if (x != 'a') {
          t[x] = Math.round(t[x]);
        }
      });
      return t.sanitize();  // Color
    };
    Color.fromRgb = dojo.colorFromRgb = function (color, obj) {
      // summary:
      //		Returns a `Color` instance from a string of the form
      //		"rgb(...)" or "rgba(...)". Optionally accepts a `Color`
      //		object to update with the parsed value and return instead of
      //		creating a new object.
      // returns:
      //		A Color object. If obj is passed, it will be the return value.
      var m = color.toLowerCase().match(/^rgba?\(([\s\.,0-9]+)\)/);
      return m && Color.fromArray(m[1].split(/\s*,\s*/), obj);  // Color
    };
    Color.fromHex = dojo.colorFromHex = function (color, obj) {
      // summary:
      //		Converts a hex string with a '#' prefix to a color object.
      //		Supports 12-bit #rgb shorthand. Optionally accepts a
      //		`Color` object to update with the parsed value.
      //
      // returns:
      //		A Color object. If obj is passed, it will be the return value.
      //
      // example:
      //	|	require(["dojo/_base/color"], function(Color){
      //	|		var thing = new Color().fromHex("#ededed"); // grey, longhand
      //	|		var thing2 = new Color().fromHex("#000"); // black, shorthand
      //	|	});
      var t = obj || new Color(), bits = color.length == 4 ? 4 : 8, mask = (1 << bits) - 1;
      color = Number('0x' + color.substr(1));
      if (isNaN(color)) {
        return null;  // Color
      }
      ArrayUtil.forEach([
        'b',
        'g',
        'r'
      ], function (x) {
        var c = color & mask;
        color >>= bits;
        t[x] = bits == 4 ? 17 * c : c;
      });
      t.a = 1;
      return t;  // Color
    };
    Color.fromArray = dojo.colorFromArray = function (a, obj) {
      // summary:
      //		Builds a `Color` from a 3 or 4 element array, mapping each
      //		element in sequence to the rgb(a) values of the color.
      // example:
      //		|	require(["dojo/_base/color"], function(Color){
      //		|		var myColor = new Color().fromArray([237,237,237,0.5]); // grey, 50% alpha
      //		|	});
      // returns:
      //		A Color object. If obj is passed, it will be the return value.
      var t = obj || new Color();
      t._set(Number(a[0]), Number(a[1]), Number(a[2]), Number(a[3]));
      if (isNaN(t.a)) {
        t.a = 1;
      }
      return t.sanitize();  // Color
    };
    Color.fromString = dojo.colorFromString = function (str, obj) {
      // summary:
      //		Parses `str` for a color value. Accepts hex, rgb, and rgba
      //		style color values.
      // description:
      //		Acceptable input values for str may include arrays of any form
      //		accepted by dojo.colorFromArray, hex strings such as "#aaaaaa", or
      //		rgb or rgba strings such as "rgb(133, 200, 16)" or "rgba(10, 10,
      //		10, 50)"
      // returns:
      //		A Color object. If obj is passed, it will be the return value.
      var a = Color.named[str];
      return a && Color.fromArray(a, obj) || Color.fromRgb(str, obj) || Color.fromHex(str, obj);  // Color
    };
    return Color;
  }(dojo__base_kernel, dojo__base_lang, dojo__base_array, dojo__base_config);
  dojo__base_fx = function (dojo, config, lang, Evented, Color, aspect, has, dom, style) {
    // module:
    //		dojo/_base/fx
    // notes:
    //		Animation loosely package based on Dan Pupius' work, contributed under CLA; see
    //		http://pupius.co.uk/js/Toolkit.Drawing.js
    var _mixin = lang.mixin;
    // Module export
    var basefx = {};
    var _Line = basefx._Line = function (start, end) {
      // summary:
      //		Object used to generate values from a start value to an end value
      // start: int
      //		Beginning value for range
      // end: int
      //		Ending value for range
      this.start = start;
      this.end = end;
    };
    _Line.prototype.getValue = function (n) {
      // summary:
      //		Returns the point on the line
      // n:
      //		a floating point number greater than 0 and less than 1
      return (this.end - this.start) * n + this.start;  // Decimal
    };
    var Animation = basefx.Animation = function (args) {
      // summary:
      //		A generic animation class that fires callbacks into its handlers
      //		object at various states.
      // description:
      //		A generic animation class that fires callbacks into its handlers
      //		object at various states. Nearly all dojo animation functions
      //		return an instance of this method, usually without calling the
      //		.play() method beforehand. Therefore, you will likely need to
      //		call .play() on instances of `Animation` when one is
      //		returned.
      // args: Object
      //		The 'magic argument', mixing all the properties into this
      //		animation instance.
      _mixin(this, args);
      if (lang.isArray(this.curve)) {
        this.curve = new _Line(this.curve[0], this.curve[1]);
      }
    };
    Animation.prototype = new Evented();
    lang.extend(Animation, {
      // duration: Integer
      //		The time in milliseconds the animation will take to run
      duration: 350,
      /*=====
      		// curve: _Line|Array
      		//		A two element array of start and end values, or a `_Line` instance to be
      		//		used in the Animation.
      		curve: null,
      
      		// easing: Function?
      		//		A Function to adjust the acceleration (or deceleration) of the progress
      		//		across a _Line
      		easing: null,
      	=====*/
      // repeat: Integer?
      //		The number of times to loop the animation
      repeat: 0,
      // rate: Integer?
      //		the time in milliseconds to wait before advancing to next frame
      //		(used as a fps timer: 1000/rate = fps)
      rate: 20  /* 50 fps */,
      /*=====
      		// delay: Integer?
      		//		The time in milliseconds to wait before starting animation after it
      		//		has been .play()'ed
      		delay: null,
      
      		// beforeBegin: Event?
      		//		Synthetic event fired before a Animation begins playing (synchronous)
      		beforeBegin: null,
      
      		// onBegin: Event?
      		//		Synthetic event fired as a Animation begins playing (useful?)
      		onBegin: null,
      
      		// onAnimate: Event?
      		//		Synthetic event fired at each interval of the Animation
      		onAnimate: null,
      
      		// onEnd: Event?
      		//		Synthetic event fired after the final frame of the Animation
      		onEnd: null,
      
      		// onPlay: Event?
      		//		Synthetic event fired any time the Animation is play()'ed
      		onPlay: null,
      
      		// onPause: Event?
      		//		Synthetic event fired when the Animation is paused
      		onPause: null,
      
      		// onStop: Event
      		//		Synthetic event fires when the Animation is stopped
      		onStop: null,
      
      	=====*/
      _percent: 0,
      _startRepeatCount: 0,
      _getStep: function () {
        var _p = this._percent, _e = this.easing;
        return _e ? _e(_p) : _p;
      },
      _fire: function (evt, args) {
        // summary:
        //		Convenience function.  Fire event "evt" and pass it the
        //		arguments specified in "args".
        // description:
        //		Convenience function.  Fire event "evt" and pass it the
        //		arguments specified in "args".
        //		Fires the callback in the scope of this Animation
        //		instance.
        // evt:
        //		The event to fire.
        // args:
        //		The arguments to pass to the event.
        var a = args || [];
        if (this[evt]) {
          if (config.debugAtAllCosts) {
            this[evt].apply(this, a);
          } else {
            try {
              this[evt].apply(this, a);
            } catch (e) {
              console.error('exception in animation handler for:', evt);
              console.error(e);
            }
          }
        }
        return this;  // Animation
      },
      play: function (delay, gotoStart) {
        // summary:
        //		Start the animation.
        // delay:
        //		How many milliseconds to delay before starting.
        // gotoStart:
        //		If true, starts the animation from the beginning; otherwise,
        //		starts it from its current position.
        // returns: Animation
        //		The instance to allow chaining.
        var _t = this;
        if (_t._delayTimer) {
          _t._clearTimer();
        }
        if (gotoStart) {
          _t._stopTimer();
          _t._active = _t._paused = false;
          _t._percent = 0;
        } else if (_t._active && !_t._paused) {
          return _t;
        }
        _t._fire('beforeBegin', [_t.node]);
        var de = delay || _t.delay, _p = lang.hitch(_t, '_play', gotoStart);
        if (de > 0) {
          _t._delayTimer = setTimeout(_p, de);
          return _t;
        }
        _p();
        return _t;  // Animation
      },
      _play: function (gotoStart) {
        var _t = this;
        if (_t._delayTimer) {
          _t._clearTimer();
        }
        _t._startTime = new Date().valueOf();
        if (_t._paused) {
          _t._startTime -= _t.duration * _t._percent;
        }
        _t._active = true;
        _t._paused = false;
        var value = _t.curve.getValue(_t._getStep());
        if (!_t._percent) {
          if (!_t._startRepeatCount) {
            _t._startRepeatCount = _t.repeat;
          }
          _t._fire('onBegin', [value]);
        }
        _t._fire('onPlay', [value]);
        _t._cycle();
        return _t;  // Animation
      },
      pause: function () {
        // summary:
        //		Pauses a running animation.
        var _t = this;
        if (_t._delayTimer) {
          _t._clearTimer();
        }
        _t._stopTimer();
        if (!_t._active) {
          return _t;  /*Animation*/
        }
        _t._paused = true;
        _t._fire('onPause', [_t.curve.getValue(_t._getStep())]);
        return _t;  // Animation
      },
      gotoPercent: function (percent, andPlay) {
        // summary:
        //		Sets the progress of the animation.
        // percent:
        //		A percentage in decimal notation (between and including 0.0 and 1.0).
        // andPlay:
        //		If true, play the animation after setting the progress.
        var _t = this;
        _t._stopTimer();
        _t._active = _t._paused = true;
        _t._percent = percent;
        if (andPlay) {
          _t.play();
        }
        return _t;  // Animation
      },
      stop: function (gotoEnd) {
        // summary:
        //		Stops a running animation.
        // gotoEnd:
        //		If true, the animation will end.
        var _t = this;
        if (_t._delayTimer) {
          _t._clearTimer();
        }
        if (!_t._timer) {
          return _t;  /* Animation */
        }
        _t._stopTimer();
        if (gotoEnd) {
          _t._percent = 1;
        }
        _t._fire('onStop', [_t.curve.getValue(_t._getStep())]);
        _t._active = _t._paused = false;
        return _t;  // Animation
      },
      destroy: function () {
        // summary:
        //		cleanup the animation
        this.stop();
      },
      status: function () {
        // summary:
        //		Returns a string token representation of the status of
        //		the animation, one of: "paused", "playing", "stopped"
        if (this._active) {
          return this._paused ? 'paused' : 'playing';  // String
        }
        return 'stopped';  // String
      },
      _cycle: function () {
        var _t = this;
        if (_t._active) {
          var curr = new Date().valueOf();
          // Allow durations of 0 (instant) by setting step to 1 - see #13798
          var step = _t.duration === 0 ? 1 : (curr - _t._startTime) / _t.duration;
          if (step >= 1) {
            step = 1;
          }
          _t._percent = step;
          // Perform easing
          if (_t.easing) {
            step = _t.easing(step);
          }
          _t._fire('onAnimate', [_t.curve.getValue(step)]);
          if (_t._percent < 1) {
            _t._startTimer();
          } else {
            _t._active = false;
            if (_t.repeat > 0) {
              _t.repeat--;
              _t.play(null, true);
            } else if (_t.repeat == -1) {
              _t.play(null, true);
            } else {
              if (_t._startRepeatCount) {
                _t.repeat = _t._startRepeatCount;
                _t._startRepeatCount = 0;
              }
            }
            _t._percent = 0;
            _t._fire('onEnd', [_t.node]);
            !_t.repeat && _t._stopTimer();
          }
        }
        return _t;  // Animation
      },
      _clearTimer: function () {
        // summary:
        //		Clear the play delay timer
        clearTimeout(this._delayTimer);
        delete this._delayTimer;
      }
    });
    // the local timer, stubbed into all Animation instances
    var ctr = 0, timer = null, runner = {
        run: function () {
        }
      };
    lang.extend(Animation, {
      _startTimer: function () {
        if (!this._timer) {
          this._timer = aspect.after(runner, 'run', lang.hitch(this, '_cycle'), true);
          ctr++;
        }
        if (!timer) {
          timer = setInterval(lang.hitch(runner, 'run'), this.rate);
        }
      },
      _stopTimer: function () {
        if (this._timer) {
          this._timer.remove();
          this._timer = null;
          ctr--;
        }
        if (ctr <= 0) {
          clearInterval(timer);
          timer = null;
          ctr = 0;
        }
      }
    });
    var _makeFadeable = has('ie') ? function (node) {
      // only set the zoom if the "tickle" value would be the same as the
      // default
      var ns = node.style;
      // don't set the width to auto if it didn't already cascade that way.
      // We don't want to f anyones designs
      if (!ns.width.length && style.get(node, 'width') == 'auto') {
        ns.width = 'auto';
      }
    } : function () {
    };
    basefx._fade = function (args) {
      // summary:
      //		Returns an animation that will fade the node defined by
      //		args.node from the start to end values passed (args.start
      //		args.end) (end is mandatory, start is optional)
      args.node = dom.byId(args.node);
      var fArgs = _mixin({ properties: {} }, args), props = fArgs.properties.opacity = {};
      props.start = !('start' in fArgs) ? function () {
        return +style.get(fArgs.node, 'opacity') || 0;
      } : fArgs.start;
      props.end = fArgs.end;
      var anim = basefx.animateProperty(fArgs);
      aspect.after(anim, 'beforeBegin', lang.partial(_makeFadeable, fArgs.node), true);
      return anim;  // Animation
    };
    /*=====
    	var __FadeArgs = declare(null, {
    		// node: DOMNode|String
    		//		The node referenced in the animation
    		// duration: Integer?
    		//		Duration of the animation in milliseconds.
    		// easing: Function?
    		//		An easing function.
    	});
    	=====*/
    basefx.fadeIn = function (args) {
      // summary:
      //		Returns an animation that will fade node defined in 'args' from
      //		its current opacity to fully opaque.
      return basefx._fade(_mixin({ end: 1 }, args));  // Animation
    };
    basefx.fadeOut = function (args) {
      // summary:
      //		Returns an animation that will fade node defined in 'args'
      //		from its current opacity to fully transparent.
      return basefx._fade(_mixin({ end: 0 }, args));  // Animation
    };
    basefx._defaultEasing = function (n) {
      // summary:
      //		The default easing function for Animation(s)
      return 0.5 + Math.sin((n + 1.5) * Math.PI) / 2;  // Decimal
    };
    var PropLine = function (properties) {
      // PropLine is an internal class which is used to model the values of
      // an a group of CSS properties across an animation lifecycle. In
      // particular, the "getValue" function handles getting interpolated
      // values between start and end for a particular CSS value.
      this._properties = properties;
      for (var p in properties) {
        var prop = properties[p];
        if (prop.start instanceof Color) {
          // create a reusable temp color object to keep intermediate results
          prop.tempColor = new Color();
        }
      }
    };
    PropLine.prototype.getValue = function (r) {
      var ret = {};
      for (var p in this._properties) {
        var prop = this._properties[p], start = prop.start;
        if (start instanceof Color) {
          ret[p] = Color.blendColors(start, prop.end, r, prop.tempColor).toCss();
        } else if (!lang.isArray(start)) {
          ret[p] = (prop.end - start) * r + start + (p != 'opacity' ? prop.units || 'px' : 0);
        }
      }
      return ret;
    };
    /*=====
    	var __AnimArgs = declare(__FadeArgs, {
    		// properties: Object?
    		//		A hash map of style properties to Objects describing the transition,
    		//		such as the properties of _Line with an additional 'units' property
    		properties: {}
    
    		//TODOC: add event callbacks
    	});
    	=====*/
    basefx.animateProperty = function (args) {
      // summary:
      //		Returns an animation that will transition the properties of
      //		node defined in `args` depending how they are defined in
      //		`args.properties`
      //
      // description:
      //		Foundation of most `dojo/_base/fx`
      //		animations. It takes an object of "properties" corresponding to
      //		style properties, and animates them in parallel over a set
      //		duration.
      //
      // example:
      //		A simple animation that changes the width of the specified node.
      //	|	basefx.animateProperty({
      //	|		node: "nodeId",
      //	|		properties: { width: 400 },
      //	|	}).play();
      //		Dojo figures out the start value for the width and converts the
      //		integer specified for the width to the more expressive but
      //		verbose form `{ width: { end: '400', units: 'px' } }` which you
      //		can also specify directly. Defaults to 'px' if omitted.
      //
      // example:
      //		Animate width, height, and padding over 2 seconds... the
      //		pedantic way:
      //	|	basefx.animateProperty({ node: node, duration:2000,
      //	|		properties: {
      //	|			width: { start: '200', end: '400', units:"px" },
      //	|			height: { start:'200', end: '400', units:"px" },
      //	|			paddingTop: { start:'5', end:'50', units:"px" }
      //	|		}
      //	|	}).play();
      //		Note 'paddingTop' is used over 'padding-top'. Multi-name CSS properties
      //		are written using "mixed case", as the hyphen is illegal as an object key.
      //
      // example:
      //		Plug in a different easing function and register a callback for
      //		when the animation ends. Easing functions accept values between
      //		zero and one and return a value on that basis. In this case, an
      //		exponential-in curve.
      //	|	basefx.animateProperty({
      //	|		node: "nodeId",
      //	|		// dojo figures out the start value
      //	|		properties: { width: { end: 400 } },
      //	|		easing: function(n){
      //	|			return (n==0) ? 0 : Math.pow(2, 10 * (n - 1));
      //	|		},
      //	|		onEnd: function(node){
      //	|			// called when the animation finishes. The animation
      //	|			// target is passed to this function
      //	|		}
      //	|	}).play(500); // delay playing half a second
      //
      // example:
      //		Like all `Animation`s, animateProperty returns a handle to the
      //		Animation instance, which fires the events common to Dojo FX. Use `aspect.after`
      //		to access these events outside of the Animation definition:
      //	|	var anim = basefx.animateProperty({
      //	|		node:"someId",
      //	|		properties:{
      //	|			width:400, height:500
      //	|		}
      //	|	});
      //	|	aspect.after(anim, "onEnd", function(){
      //	|		console.log("animation ended");
      //	|	}, true);
      //	|	// play the animation now:
      //	|	anim.play();
      //
      // example:
      //		Each property can be a function whose return value is substituted along.
      //		Additionally, each measurement (eg: start, end) can be a function. The node
      //		reference is passed directly to callbacks.
      //	|	basefx.animateProperty({
      //	|		node:"mine",
      //	|		properties:{
      //	|			height:function(node){
      //	|				// shrink this node by 50%
      //	|				return domGeom.position(node).h / 2
      //	|			},
      //	|			width:{
      //	|				start:function(node){ return 100; },
      //	|				end:function(node){ return 200; }
      //	|			}
      //	|		}
      //	|	}).play();
      //
      var n = args.node = dom.byId(args.node);
      if (!args.easing) {
        args.easing = dojo._defaultEasing;
      }
      var anim = new Animation(args);
      aspect.after(anim, 'beforeBegin', lang.hitch(anim, function () {
        var pm = {};
        for (var p in this.properties) {
          // Make shallow copy of properties into pm because we overwrite
          // some values below. In particular if start/end are functions
          // we don't want to overwrite them or the functions won't be
          // called if the animation is reused.
          if (p == 'width' || p == 'height') {
            this.node.display = 'block';
          }
          var prop = this.properties[p];
          if (lang.isFunction(prop)) {
            prop = prop(n);
          }
          prop = pm[p] = _mixin({}, lang.isObject(prop) ? prop : { end: prop });
          if (lang.isFunction(prop.start)) {
            prop.start = prop.start(n);
          }
          if (lang.isFunction(prop.end)) {
            prop.end = prop.end(n);
          }
          var isColor = p.toLowerCase().indexOf('color') >= 0;
          function getStyle(node, p) {
            // domStyle.get(node, "height") can return "auto" or "" on IE; this is more reliable:
            var v = {
              height: node.offsetHeight,
              width: node.offsetWidth
            }[p];
            if (v !== undefined) {
              return v;
            }
            v = style.get(node, p);
            return p == 'opacity' ? +v : isColor ? v : parseFloat(v);
          }
          if (!('end' in prop)) {
            prop.end = getStyle(n, p);
          } else if (!('start' in prop)) {
            prop.start = getStyle(n, p);
          }
          if (isColor) {
            prop.start = new Color(prop.start);
            prop.end = new Color(prop.end);
          } else {
            prop.start = p == 'opacity' ? +prop.start : parseFloat(prop.start);
          }
        }
        this.curve = new PropLine(pm);
      }), true);
      aspect.after(anim, 'onAnimate', lang.hitch(style, 'set', anim.node), true);
      return anim;  // Animation
    };
    basefx.anim = function (node, properties, duration, easing, onEnd, delay) {
      // summary:
      //		A simpler interface to `animateProperty()`, also returns
      //		an instance of `Animation` but begins the animation
      //		immediately, unlike nearly every other Dojo animation API.
      // description:
      //		Simpler (but somewhat less powerful) version
      //		of `animateProperty`.  It uses defaults for many basic properties
      //		and allows for positional parameters to be used in place of the
      //		packed "property bag" which is used for other Dojo animation
      //		methods.
      //
      //		The `Animation` object returned will be already playing, so
      //		calling play() on it again is (usually) a no-op.
      // node:
      //		a DOM node or the id of a node to animate CSS properties on
      // duration:
      //		The number of milliseconds over which the animation
      //		should run. Defaults to the global animation default duration
      //		(350ms).
      // easing:
      //		An easing function over which to calculate acceleration
      //		and deceleration of the animation through its duration.
      //		A default easing algorithm is provided, but you may
      //		plug in any you wish. A large selection of easing algorithms
      //		are available in `dojo/fx/easing`.
      // onEnd:
      //		A function to be called when the animation finishes
      //		running.
      // delay:
      //		The number of milliseconds to delay beginning the
      //		animation by. The default is 0.
      // example:
      //		Fade out a node
      //	|	basefx.anim("id", { opacity: 0 });
      // example:
      //		Fade out a node over a full second
      //	|	basefx.anim("id", { opacity: 0 }, 1000);
      return basefx.animateProperty({
        // Animation
        node: node,
        duration: duration || Animation.prototype.duration,
        properties: properties,
        easing: easing,
        onEnd: onEnd
      }).play(delay || 0);
    };
    if (has('extend-dojo')) {
      _mixin(dojo, basefx);
      // Alias to drop come 2.0:
      dojo._Animation = Animation;
    }
    return basefx;
  }(dojo__base_kernel, dojo__base_config, dojo__base_lang, dojo_Evented, dojo__base_Color, dojo_aspect, dojo_sniff, dojo_dom, dojo_dom_style);
  dojo_text_synchronite_integration_templates_SupportDialoghtml = '<div class="modal fade" id="${DIALOG_REQUEST_SUPPORT}" tabindex="-1" role="dialog" aria-hidden="true">\n    <div class="modal-dialog" style="width:500px">\n        <div class="modal-content">\n        <div class="modal-header">\n            <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>\n       <h4 class="modal-title">${SUPPORT_DIALOG_TITLE}</h4>\n    </div>\n    <div class="modal-body">\n        <img class="agent" src="${supportDialogImage}" />\n        <h4 id="dialog-header">${SUPPORT_DIALOG_HEADER}</h4>\n        <p id="dialog-intro">${SUPPORT_DIALOG_INTRO}</p>\n        <div style="clear: both;"></div>\n\n        <div id="support-status-container" class="alert alert-info" style="margin-top: 10px; display:none;">\n            <span id="support-status"></span>\n            <span id="support-status-important"></span>\n        </div>\n\n        <div style="display: block;" id="processInfo">\n            <div style="height: 140px; clear: both; display:${flowContainerDisplay};" id="flow-container">\n                <div style=\'display:table-row;border-collapse: collapse;\'>\n                    <div style="display:table-cell;border-collapse: collapse;vertical-align:middle;width:${dialogWidth}px">\n                        ${flowChartTemplate}\n                    </div>\n                </div>\n            </div>\n\n            <div style="clear: both;"></div>\n            <div class="input-container">\n                <div id="name-group" class="form-group">\n                    <label class="control-label" for="username-input">${ENTER_USERNAME}</label>\n                    <input class="form-control" type="text" id="username-input" placeholder="${NAME}&hellip;"/>\n                </div>\n\n                <div class="form-group">\n                    <label class="control-label" for="mail-input">${EMAIL}</label>\n                    <input class="form-control" type="email" id="mail-input" placeholder="${EMAIL_PLACEHOLDER}&hellip;"/>\n                </div>\n\n                <div id="terms-group" class="control-group">\n                    <label class="checkbox">\n                        <input id="terms-checkbox" type="checkbox"/> ${ACCEPT_TERMS}\n                    </label>\n                    <a style="font-size:12px;" href="#">${SHOW_TERMS}</a>\n                </div>\n            </div>\n        </div>\n    </div>\n    <div class="modal-footer">\n        <button type="button" id="acceptButton" class="btn btn-success">${START}</button>\n        <button type="button" id="requestSupport" class="btn btn-primary">${SUPPORT_DIALOG_BTN_REQUEST}</button>\n        <button type="button" id="cancelButton" data-dismiss="modal" class="btn btn-default">${CLOSE}</button>\n    </div>\n    </div>\n    </div>\n</div>\n';
  synchronite_integration_dialog_support = function (baseFx, Deferred, baseWindow, on, dom, domConstruct, domStyle, domAttr, domClass, string, has, query, i18next, dialogTemplate, Modal) {
    ///////////////////////////
    // PRIVATE METHODS
    ///////////////////////////
    var visitorInfo, main;
    var config = synchroniteConfig, integrationConfig = synchroniteConfig.integration, CATEGORY_UI_SUPPORT_DIALOG = 'supportDialog';
    var STATE_NOTHING = 0;
    var containerNode;
    /////////////
    //widget ids
    /////////////
    var USERNAME_TEXT_BOX_ID = 'username-input', MAIL_INPUT_ID = 'mail-input', TERMS_CHECKBOX_ID = 'terms-checkbox',
      //the id of the session hand over dialog
      DIALOG_REQUEST_SUPPORT = 'dialog-request-support', SYNCHRONITE_WIDGETS = 'synchronite-widgets',
      //the id of the button to accept the support offer
      ACCEPT_BUTTON_ID = 'acceptButton', CANCEL_BUTTON_ID = 'cancelButton',
      //the id of the button to request the support
      REQUEST_BUTTON_ID = 'requestSupport',
      //the id of the span where the username of the support user is displayed
      SUPPORT_IMPORTANT_STATUS = 'support-status-important', SUPPORT_STATUS = 'support-status';
    var BS_FORM_CLASS = '.form-group';
    var STEP_SUPPORT_UNAVAILABLE = -1, STEP0 = 0, STEP1 = 1, STEP2 = 2, STEP3 = 3, skipEnterDetailsWhenVisitorIsKnown = config.skipEnterDetailsWhenVisitorIsKnown, skipVisitorConfirmation = config.skipVisitorConfirmation;
    var stepHead = '<span class=\'step${number} ${type}box\'>', stepContent = '<span style=\'width:${contentWidth}px\' class=\'box-content\'><div class=\'content-title\'>${number}. ${step}</div><span>${label}</span></span></span>', stepOuterArrow = '<span style=\'border-left-width:${arrowWidth}px\' class=\'step${number} outer-arrow borderdraw\'><!-- --></span>', stepInnerArrow = '<span style=\'border-left-width:${arrowWidth}px\' class=\'step${number} inner-arrow borderdraw\'></span>', DIALOG_WIDTH = skipVisitorConfirmation ? 400 : 500, STEP_PADDING = 10, DIALOG_PADDING = 30, DIALOG_INNER_WIDTH = DIALOG_WIDTH - DIALOG_PADDING, FLOW_ARROW_SIZE = 1 / 7, FLOW_INNER_STEPS = skipVisitorConfirmation ? 0 : 1, STEP_CONTENT_WIDTH = DIALOG_INNER_WIDTH / (2 + 2 * FLOW_ARROW_SIZE + 2 * FLOW_INNER_STEPS * FLOW_ARROW_SIZE + FLOW_INNER_STEPS), STEP_ARROW_WIDTH = STEP_CONTENT_WIDTH * FLOW_ARROW_SIZE, _createFlowChartStep = function (props) {
        // type = "first", "center", "last"
        // props = {number: 1, label: "I am the description of step x"}
        var type = props.type;
        props.contentWidth = Math.floor(STEP_CONTENT_WIDTH) - STEP_PADDING * 2;
        props.arrowWidth = Math.floor(STEP_ARROW_WIDTH);
        props.step = i18next.t('STEP');
        var stepHTML;
        if (type === 'first') {
          stepHTML = stepHead + stepContent + stepOuterArrow;
        } else if (type === 'center') {
          stepHTML = stepHead + stepInnerArrow + stepContent + stepOuterArrow;
        } else if (type === 'last') {
          stepHTML = stepHead + stepInnerArrow + stepContent;
        }
        return string.substitute(stepHTML, props);
      }, _showDialog = function () {
        if (!supportDialog.isShown()) {
          var containerNode = dom.byId(DIALOG_REQUEST_SUPPORT);
          var _d = query(containerNode);
          _d.modal('show');
          _d.removeClass('hide');
        }
      },
      /* The support dialog */
      _createSupportDialog = function (showDialog) {
        containerNode = dom.byId(DIALOG_REQUEST_SUPPORT);
        if (containerNode) {
          if (showDialog) {
            _showDialog();
          }
          return containerNode;
        }
        //var totalSteps = skipVisitorConfirmation ? 2 : 3;
        // Create Flow Chart
        // vertical centering: see http://blog.themeforest.net/tutorials/vertical-centering-with-css/
        var flowChartTemplate = _createFlowChartStep({
          type: 'first',
          number: 1,
          label: i18next.t('SUPPORT_STEP1_LABEL')
        });
        var step2Type = skipVisitorConfirmation ? 'last' : 'center';
        flowChartTemplate += _createFlowChartStep({
          type: step2Type,
          number: 2,
          label: i18next.t('SUPPORT_STEP2_LABEL')
        });
        if (!skipVisitorConfirmation) {
          flowChartTemplate += _createFlowChartStep({
            type: 'last',
            number: 3,
            label: i18next.t('SUPPORT_STEP3_LABEL')
          });
        }
        var props = {};
        var imageUrl = config[CATEGORY_UI_SUPPORT_DIALOG].supportDialogImage;
        imageUrl = string.substitute(imageUrl, config);
        props.supportDialogImage = imageUrl;
        props.flowContainerDisplay = has('ie') && has('ie') <= 7 ? 'block' : 'table';
        props.flowChartTemplate = flowChartTemplate;
        props.dialogWidth = DIALOG_WIDTH;
        // Set dialog template variables
        props.DIALOG_REQUEST_SUPPORT = DIALOG_REQUEST_SUPPORT;
        dialogTemplate = string.trim(dialogTemplate);
        var dialogContent = i18next.replace(dialogTemplate, props);
        var dialogContainer = dom.byId(SYNCHRONITE_WIDGETS) || domConstruct.create('div', { id: SYNCHRONITE_WIDGETS }, baseWindow.body());
        var dialog = domConstruct.place(dialogContent, dialogContainer);
        var cfg = config.integration;
        var goupTerms = dom.byId('terms-group');
        if (cfg && cfg.termsOfService === 'hide') {
          domStyle.set(goupTerms, { display: 'none' });
        } else {
          domStyle.set(goupTerms, { display: 'block' });
          var showTerms = cfg && cfg.termsOfService === 'show', acceptTerms = cfg && cfg.termsOfService === 'accept';
          var showTermsLink;
          if (showTerms || acceptTerms) {
            showTermsLink = query('#terms-group a');
            showTermsLink.on('click', function (event) {
              var termsURL = string.substitute(cfg.termsOfServiceURL, synchroniteConfig);
              //${serverUrl}
              window.open(termsURL, 'termsPopup');
              event.preventDefault();
            });
          }
          if (showTerms) {
            query('#terms-group label').style({ display: 'none' });
          } else if (acceptTerms) {
            showTermsLink.style({ marginLeft: '18px' });
          }
        }
        query('#' + MAIL_INPUT_ID).closest(BS_FORM_CLASS).style({ display: cfg.mail ? 'block' : 'none' });
        var bsDialog = query(dialog);
        bsDialog.on('show.bs.modal', function () {
          // hide service dialog when support dialog is displayed
          if (main.serviceDialog && main.serviceDialog.isShown()) {
            main.serviceDialog.hide();
          }
        });
        bsDialog.modal({
          backdrop: false,
          // deactivate backdrop as it would require a global style on the page
          show: showDialog
        });
        acceptButton = dom.byId(ACCEPT_BUTTON_ID);
        requestButton = dom.byId(REQUEST_BUTTON_ID);
        cancelButton = dom.byId(CANCEL_BUTTON_ID);
        nameInput = dom.byId(USERNAME_TEXT_BOX_ID);
        mailInput = dom.byId(MAIL_INPUT_ID);
        termsCheckbox = dom.byId(TERMS_CHECKBOX_ID);
        on(acceptButton, 'click', onAcceptButtonClick);
        on(requestButton, 'click', onRequestSupportButtonClicked);
        on(cancelButton, 'click', onCancelSupportButtonClick);
        query('.close', dialog).on('click', onCancelSupportButtonClick);
        console.debug('Created the \'' + DIALOG_REQUEST_SUPPORT + '\' dialog. Shown=' + showDialog);
        return dialog;
      }, onAcceptButtonClick = function () {
        if (isValidInput()) {
          var userName = nameInput.value;
          var termsAccepted = termsCheckbox.checked;
          domClass.add(ACCEPT_BUTTON_ID, 'disabled');
          visitorInfo.setTermsAccepted(termsAccepted);
          visitorInfo.setFullname(userName);
          domConstruct.destroy(DIALOG_REQUEST_SUPPORT);
          main.io.prepareTicket();
        }
      }, _hideDialog = function () {
        if (supportDialog.isShown()) {
          query('#' + DIALOG_REQUEST_SUPPORT).modal('hide');
        }
      },
      /* this method will be called if the user clicked cancel at
       * the support dialog an declined the support offer.
       * the method hides the support dialog and publishs via
       * comet or xhr that the user denied the support. */
      onCancelSupportButtonClick = function () {
        console.debug('gui Cancel button clicked.');
        _hideDialog();
        console.debug('gui Hide the support dialog.');
        if (main.io && !main.io.isDisconnected() && main.io.state != STATE_NOTHING) {
          //FIXED: We only publish this message, when the visitor has already requested
          //       support (main.io.state)
          main.io.publishDeclineSupport();
        }
      }, isValidInput = function () {
        // check name
        var userName = nameInput.value;
        var nameValid = userName && userName.length >= 3;
        query(nameInput).closest(BS_FORM_CLASS).toggleClass('error', !nameValid);
        if (!nameValid) {
          nameInput.focus();
        }
        // check terms
        var termsValid = true;
        if (config.integration.termsOfService == 'accept') {
          termsValid = termsCheckbox && termsCheckbox.checked;
        }
        query(termsCheckbox).closest(BS_FORM_CLASS).toggleClass('error', !termsValid);
        // check email
        var emailValid = true;
        if (config.integration.mail) {
          var mail = mailInput.value;
          emailValid = mail && mail.length >= 3;
          query(mailInput).closest(BS_FORM_CLASS).toggleClass('error', !emailValid);
        }
        return nameValid && termsValid && emailValid;
      },
      /* this method requests support (if the user isn't logged in */
      onRequestSupportButtonClicked = function () {
        if (isValidInput()) {
          var userName = nameInput.value;
          var termsAccepted = termsCheckbox.checked;
          visitorInfo.setFullname(userName);
          visitorInfo.setTermsAccepted(termsAccepted);
          if (config.integration.mail) {
            visitorInfo.setMail(mailInput.value);
          }
          // FIXED: We need to persist session state here. Otherwise we lose the state w
          visitorInfo.persist();
          supportDialog.prepare(STEP2);
          if (!main.io || main.io.isDisconnected()) {
            main.iCM().then(function (cometConnect) {
              cometConnect.publishSupportRequest();
            });
          } else {
            main.io.publishSupportRequest();
          }
        }
      }, _highlightStep = function (STEP) {
        var boxProperties = {
          height: {
            start: 110,
            end: 130
          }
        };
        var arrowProps = {
          borderTopWidth: {
            start: 55,
            end: 65
          },
          borderBottomWidth: {
            start: 55,
            end: 65
          }
        };
        var isBoxNode = function (node) {
          return domClass.contains(node, 'firstbox') || domClass.contains(node, 'centerbox') || domClass.contains(node, 'lastbox');
        };
        //reset colors
        //FIXED: also reset subsequent steps not only i<STEP
        for (var i = 1; i <= STEP3; i++) {
          var isCompleted = i < STEP;
          query('.step' + i).forEach(function (node) {
            domClass.toggle(node, 'completeStep', isCompleted);
            domClass.toggle(node, 'uncompleteStep', !isCompleted);
            if (isBoxNode(node)) {
              domStyle.set(node, { height: '110px' });
            }
            if (domClass.contains(node, 'outer-arrow')) {
              domStyle.set(node, {
                borderTopWidth: '55px',
                borderBottomWidth: '55px'
              });
            }
            if (domClass.contains(node, 'inner-arrow')) {
              domStyle.set(node, {
                borderTopWidth: '55px',
                borderBottomWidth: '55px'
              });
            }
          });
        }
        query('.step' + STEP).forEach(function (node) {
          domClass.remove(node, 'completeStep');
          domClass.remove(node, 'uncompleteStep');
          domClass.add(node, 'activeStep');
          var props = isBoxNode(node) ? boxProperties : arrowProps;
          if (props) {
            baseFx.animateProperty({
              node: node,
              duration: 500,
              properties: props
            }).play();
          }
        });
      };
    var acceptButton, requestButton, cancelButton, mailInput, nameInput, termsCheckbox;
    /////////////////////////////////////
    // PUBLIC METHODS
    //////////////////////////////////////
    var supportDialog = {
      create: function (showDialog, _main, _visitorInfo) {
        var deferred = new Deferred(), that = this;
        main = _main;
        visitorInfo = _visitorInfo;
        i18next.loadNamespaces([
          'integration',
          'common'
        ], function () {
          _createSupportDialog(showDialog);
          deferred.resolve(that);
        });
        return deferred;
      },
      hide: _hideDialog,
      show: _showDialog,
      isShown: function () {
        var dialog = dom.byId(DIALOG_REQUEST_SUPPORT), modal;
        if (dialog) {
          modal = query(dialog).data('modal');
          return modal && modal.length && modal[0].isShown;
        }
        return false;
      },
      skipVisitorConfirmation: skipVisitorConfirmation,
      skipEnterDetailsWhenVisitorIsKnown: skipEnterDetailsWhenVisitorIsKnown,
      //processStep (siehe oben in der Prozessbeschreibung)
      //processStep = 0, 1, 2, 3
      prepare: function (processStep) {
        //prepare dyncamic elements of dialog
        var processInfo = dom.byId('processInfo');
        var statusContainer = dom.byId('support-status-container');
        var userName = visitorInfo.fullname(true);
        if (processStep === STEP1) {
          var termsMayBeSkipped = integrationConfig.termsOfService !== 'accept' || visitorInfo.termsAccepted();
          if (userName && skipEnterDetailsWhenVisitorIsKnown && termsMayBeSkipped) {
            processStep = STEP2;
          }
        }
        if (processStep === STEP_SUPPORT_UNAVAILABLE) {
          processInfo.style.display = 'none';
          query('.step2 .box-content span')[0].innerHTML = i18next.t('SUPPORT_STEP2_LABEL');
          domStyle.set(statusContainer, { display: 'block' });
          domAttr.set(SUPPORT_STATUS, 'innerHTML', '<b>' + i18next.t('NO_SUPPORT_DIALOG_HEADER') + '</b> ' + i18next.t('NO_SUPPORT_DIALOG_CENTER'));
          requestButton.style.display = 'none';
          acceptButton.style.display = 'none';
        } else if (processStep === STEP1) {
          //Live-Support Button clicked
          processInfo.style.display = 'block';
          domStyle.set(statusContainer, { display: 'none' });
          nameInput.value = userName || '';
          domClass.remove(requestButton, 'disabled');
          requestButton.style.display = 'inline-block';
          acceptButton.style.display = 'none';
          _highlightStep(processStep);
        } else if (processStep === STEP2) {
          //Clicked on requestSupport-Button
          processInfo.style.display = 'block';
          domStyle.set(statusContainer, { display: 'none' });
          query('.step2 .box-content span')[0].innerHTML = i18next.t('SUPPORT_STEP2_LABEL');
          nameInput.value = userName || '';
          requestButton.style.display = 'none';
          acceptButton.style.display = 'none';
          _highlightStep(processStep);
        } else if (processStep === STEP3) {
          // Received Support Offer
          processInfo.style.display = 'block';
          domStyle.set(statusContainer, { display: 'none' });
          //display the support username in the support dialog and show this dialog
          query('.step2 .box-content span')[0].innerHTML = i18next.t('SUPPORT_DIALOG_AGENT_IS') + ' <b>' + visitorInfo.connectedAgentAlias + '</b>';
          nameInput.value = userName || '';
          requestButton.style.display = 'none';
          acceptButton.style.display = 'inline-block';
          domClass.remove(acceptButton, 'disabled');
          _highlightStep(processStep);
          console.debug('gui Updated support dialog. The support user is: ' + visitorInfo.connectedAgentAlias);
        }
      }
    };
    return supportDialog;
  }(dojo__base_fx, dojo_Deferred, dojo__base_window, dojo_on, dojo_dom, dojo_dom_construct, dojo_dom_style, dojo_dom_attr, dojo_dom_class, dojo_string, dojo_has, dojo_query, i18next_loader, dojo_text_synchronite_integration_templates_SupportDialoghtml, bootstrap_Modal);
  (function (domReady, has, strings, synchDom, storage) {
    var win = window, doc = win.document, config = win.synchroniteConfig, className = 'className';
    // This is not obvious, so to prevent end-user frustration we'll let them know
    // explicitly rather than failing with a bunch of permission errors. We don't
    // handle this using an OT Exception as it's really only a development thing.
    if (location.protocol === 'file:') {
      alert('You cannot test synchronite through the file system due to browser permissions. You must run it over a web server.');
      return;
    }
    var synchroniteReady = function (integration) {
      try {
        if (config.readyCallback) {
          console.log('synchronite integration: Calling ready listener integration=' + integration);
          config.readyCallback();
        }
      } catch (e) {
        console.warn('Error calling ready event.');
      }
    };
    // Preconditions for loading the synchronite script.
    /////////////////////////////////////////////////////
    var synchroniteSessionActive = function () {
        try {
          var fE = win.frameElement;
          if (fE) {
            if (fE.id == strings.SYNCHRONIZED_WINDOW || fE[className] == 'popupFrame') {
              return true;
            }
          }
          if (!config.supportCoBrowsingInIFrame && top.synch) {
            return true;
          }
          if (win.isCobrowsingActive) {
            return true;
          }
        } catch (err) {
          return true;
        }
        return false;
      }, integrationDisabled = function () {
        return config.disableSupport && config.disableSupport();
      }, tenantIdMissing = function () {
        if (config.tenantId) {
          return false;
        } else {
          if (console && console['warn']) {
            console['warn']('Synchronite is not configured correctly. Please make sure \'synchroniteConfig.tenantId\' is set to your account name.');
          }
          return true;
        }
      }, isBrowserUnsupported = function () {
        if (has('ie') <= 6) {
          console.warn('synchronite integration: Quitting - unsupported browser detected.');
        }
      }, isProxylessActive = function (callback) {
        storage.getValue('s.tid', function (data) {
          if (data) {
            callback(true);
          } else {
            callback(false);
          }
        });
      }, startProxyless = function () {
        var cacheBust = config && config.cacheBust || 1;
        var scriptUrl = 'https://' + config.tenantHost + '/js/synchronite/proxyless/run.js?cacheBust=' + encodeURIComponent(cacheBust);
        synchDom.loadScript(document, 'script', scriptUrl, 'cobrowse-proxyless-run', function () {
          console.log('PROXYLESS RUN SCRIPT LOADED');
        });
        console.log('proxyless session is active - proxyless run script injected');
      };
    function getNamespace(global, path) {
      var obj = global;
      if (path && path.length) {
        for (var i = 0; i < path.length; i++) {
          obj = obj[path[i]] = obj[path[i]] || {};
        }
      }
      return obj;
    }
    function exportApi(global, namespace, obj) {
      if (typeof namespace == 'string') {
        namespace = namespace.split('.');
      }
      var lastKey = namespace.pop();
      var parentObject = getNamespace(global, namespace);
      parentObject[lastKey] = obj;
      return obj;
    }
    domReady(function () {
      storage.init({
        site: config.tenantId,
        cobrowseBaseUrl: 'https://' + config.tenantHost
      });
      // check preconditions for loading synchronite
      isProxylessActive(function (proxylessActive) {
        if (proxylessActive) {
          startProxyless();
          return;
        }
        var continueLoading = !(synchroniteSessionActive() || integrationDisabled() || tenantIdMissing() || isBrowserUnsupported() || proxylessActive);
        if (continueLoading) {
          // Integration Script should only be loaded when we are not inside a synchronite session
          console.info('synchronite integration: ENABLED.');
          (function (integrationMain) {
            var namespace = config.namespace || 'synchronite';
            exportApi(win, namespace, integrationMain);
            // Expose public synchronite API
            integrationMain.initialize();
            console.log('synchronite integration: Finished loading.');
            synchroniteReady(integrationMain);
          }(synchronite_integration_main));
        } else {
          console.info('synchronite integration: DISABLED.');
        }
      });
    });
  }(dojo_domReady, dojo_has, synchronite_constants_strings, synchronite_micro_dom, synchronite_proxyless_storage));
  synchronite_integration_run = undefined;
  synchronite_integration_run_build = undefined;
}());
}());